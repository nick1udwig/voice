#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use hyperprocess_macro::hyperprocess;
use hyperware_process_lib::http::server::{send_ws_push, WsMessageType};
use hyperware_process_lib::{kiprintln, LazyLoadBlob};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use rand::seq::SliceRandom;
pub enum Role {
    Listener,
    Chatter,
    Speaker,
    Admin,
}
#[automatically_derived]
impl ::core::fmt::Debug for Role {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::write_str(
            f,
            match self {
                Role::Listener => "Listener",
                Role::Chatter => "Chatter",
                Role::Speaker => "Speaker",
                Role::Admin => "Admin",
            },
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for Role {
    #[inline]
    fn clone(&self) -> Role {
        match self {
            Role::Listener => Role::Listener,
            Role::Chatter => Role::Chatter,
            Role::Speaker => Role::Speaker,
            Role::Admin => Role::Admin,
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for Role {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                Role::Listener => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Role",
                        0u32,
                        "Listener",
                    )
                }
                Role::Chatter => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Role",
                        1u32,
                        "Chatter",
                    )
                }
                Role::Speaker => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Role",
                        2u32,
                        "Speaker",
                    )
                }
                Role::Admin => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Role",
                        3u32,
                        "Admin",
                    )
                }
            }
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for Role {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "variant identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 4",
                                ),
                            )
                        }
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "Listener" => _serde::__private::Ok(__Field::__field0),
                        "Chatter" => _serde::__private::Ok(__Field::__field1),
                        "Speaker" => _serde::__private::Ok(__Field::__field2),
                        "Admin" => _serde::__private::Ok(__Field::__field3),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"Listener" => _serde::__private::Ok(__Field::__field0),
                        b"Chatter" => _serde::__private::Ok(__Field::__field1),
                        b"Speaker" => _serde::__private::Ok(__Field::__field2),
                        b"Admin" => _serde::__private::Ok(__Field::__field3),
                        _ => {
                            let __value = &_serde::__private::from_utf8_lossy(__value);
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<Role>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = Role;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "enum Role")
                }
                fn visit_enum<__A>(
                    self,
                    __data: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::EnumAccess<'de>,
                {
                    match _serde::de::EnumAccess::variant(__data)? {
                        (__Field::__field0, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Role::Listener)
                        }
                        (__Field::__field1, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Role::Chatter)
                        }
                        (__Field::__field2, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Role::Speaker)
                        }
                        (__Field::__field3, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(Role::Admin)
                        }
                    }
                }
            }
            #[doc(hidden)]
            const VARIANTS: &'static [&'static str] = &[
                "Listener",
                "Chatter",
                "Speaker",
                "Admin",
            ];
            _serde::Deserializer::deserialize_enum(
                __deserializer,
                "Role",
                VARIANTS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<Role>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
pub enum ConnectionType {
    Node(String),
    Browser,
}
#[automatically_derived]
impl ::core::fmt::Debug for ConnectionType {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            ConnectionType::Node(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Node", &__self_0)
            }
            ConnectionType::Browser => ::core::fmt::Formatter::write_str(f, "Browser"),
        }
    }
}
#[automatically_derived]
impl ::core::clone::Clone for ConnectionType {
    #[inline]
    fn clone(&self) -> ConnectionType {
        match self {
            ConnectionType::Node(__self_0) => {
                ConnectionType::Node(::core::clone::Clone::clone(__self_0))
            }
            ConnectionType::Browser => ConnectionType::Browser,
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for ConnectionType {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                ConnectionType::Node(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "ConnectionType",
                        0u32,
                        "Node",
                        __field0,
                    )
                }
                ConnectionType::Browser => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "ConnectionType",
                        1u32,
                        "Browser",
                    )
                }
            }
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for ConnectionType {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "variant identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 2",
                                ),
                            )
                        }
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "Node" => _serde::__private::Ok(__Field::__field0),
                        "Browser" => _serde::__private::Ok(__Field::__field1),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"Node" => _serde::__private::Ok(__Field::__field0),
                        b"Browser" => _serde::__private::Ok(__Field::__field1),
                        _ => {
                            let __value = &_serde::__private::from_utf8_lossy(__value);
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<ConnectionType>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = ConnectionType;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "enum ConnectionType",
                    )
                }
                fn visit_enum<__A>(
                    self,
                    __data: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::EnumAccess<'de>,
                {
                    match _serde::de::EnumAccess::variant(__data)? {
                        (__Field::__field0, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    String,
                                >(__variant),
                                ConnectionType::Node,
                            )
                        }
                        (__Field::__field1, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(ConnectionType::Browser)
                        }
                    }
                }
            }
            #[doc(hidden)]
            const VARIANTS: &'static [&'static str] = &["Node", "Browser"];
            _serde::Deserializer::deserialize_enum(
                __deserializer,
                "ConnectionType",
                VARIANTS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<ConnectionType>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[serde(rename_all = "camelCase")]
pub struct CreateCallReq {
    pub default_role: Role,
}
#[automatically_derived]
impl ::core::fmt::Debug for CreateCallReq {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field1_finish(
            f,
            "CreateCallReq",
            "default_role",
            &&self.default_role,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for CreateCallReq {
    #[inline]
    fn clone(&self) -> CreateCallReq {
        CreateCallReq {
            default_role: ::core::clone::Clone::clone(&self.default_role),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for CreateCallReq {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "CreateCallReq",
                false as usize + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "defaultRole",
                &self.default_role,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for CreateCallReq {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "defaultRole" => _serde::__private::Ok(__Field::__field0),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"defaultRole" => _serde::__private::Ok(__Field::__field0),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<CreateCallReq>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = CreateCallReq;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct CreateCallReq",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        Role,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct CreateCallReq with 1 element",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(CreateCallReq {
                        default_role: __field0,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<Role> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "defaultRole",
                                        ),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<Role>(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("defaultRole")?
                        }
                    };
                    _serde::__private::Ok(CreateCallReq {
                        default_role: __field0,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["defaultRole"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "CreateCallReq",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<CreateCallReq>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[serde(rename_all = "camelCase")]
pub struct CallInfo {
    pub id: String,
    pub created_at: u64,
    pub participant_count: u32,
    pub default_role: Role,
}
#[automatically_derived]
impl ::core::fmt::Debug for CallInfo {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field4_finish(
            f,
            "CallInfo",
            "id",
            &self.id,
            "created_at",
            &self.created_at,
            "participant_count",
            &self.participant_count,
            "default_role",
            &&self.default_role,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for CallInfo {
    #[inline]
    fn clone(&self) -> CallInfo {
        CallInfo {
            id: ::core::clone::Clone::clone(&self.id),
            created_at: ::core::clone::Clone::clone(&self.created_at),
            participant_count: ::core::clone::Clone::clone(&self.participant_count),
            default_role: ::core::clone::Clone::clone(&self.default_role),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for CallInfo {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "CallInfo",
                false as usize + 1 + 1 + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "id",
                &self.id,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "createdAt",
                &self.created_at,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "participantCount",
                &self.participant_count,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "defaultRole",
                &self.default_role,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for CallInfo {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "id" => _serde::__private::Ok(__Field::__field0),
                        "createdAt" => _serde::__private::Ok(__Field::__field1),
                        "participantCount" => _serde::__private::Ok(__Field::__field2),
                        "defaultRole" => _serde::__private::Ok(__Field::__field3),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"id" => _serde::__private::Ok(__Field::__field0),
                        b"createdAt" => _serde::__private::Ok(__Field::__field1),
                        b"participantCount" => _serde::__private::Ok(__Field::__field2),
                        b"defaultRole" => _serde::__private::Ok(__Field::__field3),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<CallInfo>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = CallInfo;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct CallInfo",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct CallInfo with 4 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        u64,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct CallInfo with 4 elements",
                                ),
                            );
                        }
                    };
                    let __field2 = match _serde::de::SeqAccess::next_element::<
                        u32,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct CallInfo with 4 elements",
                                ),
                            );
                        }
                    };
                    let __field3 = match _serde::de::SeqAccess::next_element::<
                        Role,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct CallInfo with 4 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(CallInfo {
                        id: __field0,
                        created_at: __field1,
                        participant_count: __field2,
                        default_role: __field3,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<u64> = _serde::__private::None;
                    let mut __field2: _serde::__private::Option<u32> = _serde::__private::None;
                    let mut __field3: _serde::__private::Option<Role> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "createdAt",
                                        ),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private::Option::is_some(&__field2) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "participantCount",
                                        ),
                                    );
                                }
                                __field2 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                );
                            }
                            __Field::__field3 => {
                                if _serde::__private::Option::is_some(&__field3) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "defaultRole",
                                        ),
                                    );
                                }
                                __field3 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<Role>(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("id")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("createdAt")?
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private::Some(__field2) => __field2,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("participantCount")?
                        }
                    };
                    let __field3 = match __field3 {
                        _serde::__private::Some(__field3) => __field3,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("defaultRole")?
                        }
                    };
                    _serde::__private::Ok(CallInfo {
                        id: __field0,
                        created_at: __field1,
                        participant_count: __field2,
                        default_role: __field3,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &[
                "id",
                "createdAt",
                "participantCount",
                "defaultRole",
            ];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "CallInfo",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<CallInfo>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[serde(rename_all = "camelCase")]
pub struct JoinCallReq {
    pub call_id: String,
    pub node_auth: Option<String>,
}
#[automatically_derived]
impl ::core::fmt::Debug for JoinCallReq {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field2_finish(
            f,
            "JoinCallReq",
            "call_id",
            &self.call_id,
            "node_auth",
            &&self.node_auth,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for JoinCallReq {
    #[inline]
    fn clone(&self) -> JoinCallReq {
        JoinCallReq {
            call_id: ::core::clone::Clone::clone(&self.call_id),
            node_auth: ::core::clone::Clone::clone(&self.node_auth),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for JoinCallReq {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "JoinCallReq",
                false as usize + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "callId",
                &self.call_id,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "nodeAuth",
                &self.node_auth,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for JoinCallReq {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "callId" => _serde::__private::Ok(__Field::__field0),
                        "nodeAuth" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"callId" => _serde::__private::Ok(__Field::__field0),
                        b"nodeAuth" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<JoinCallReq>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = JoinCallReq;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct JoinCallReq",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct JoinCallReq with 2 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        Option<String>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct JoinCallReq with 2 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(JoinCallReq {
                        call_id: __field0,
                        node_auth: __field1,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<Option<String>> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("callId"),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "nodeAuth",
                                        ),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        Option<String>,
                                    >(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("callId")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("nodeAuth")?
                        }
                    };
                    _serde::__private::Ok(JoinCallReq {
                        call_id: __field0,
                        node_auth: __field1,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["callId", "nodeAuth"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "JoinCallReq",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<JoinCallReq>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[serde(rename_all = "camelCase")]
pub struct JoinInfo {
    pub call_id: String,
    pub participant_id: String,
    pub role: Role,
    pub auth_token: Option<String>,
}
#[automatically_derived]
impl ::core::fmt::Debug for JoinInfo {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field4_finish(
            f,
            "JoinInfo",
            "call_id",
            &self.call_id,
            "participant_id",
            &self.participant_id,
            "role",
            &self.role,
            "auth_token",
            &&self.auth_token,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for JoinInfo {
    #[inline]
    fn clone(&self) -> JoinInfo {
        JoinInfo {
            call_id: ::core::clone::Clone::clone(&self.call_id),
            participant_id: ::core::clone::Clone::clone(&self.participant_id),
            role: ::core::clone::Clone::clone(&self.role),
            auth_token: ::core::clone::Clone::clone(&self.auth_token),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for JoinInfo {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "JoinInfo",
                false as usize + 1 + 1 + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "callId",
                &self.call_id,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "participantId",
                &self.participant_id,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "role",
                &self.role,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "authToken",
                &self.auth_token,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for JoinInfo {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "callId" => _serde::__private::Ok(__Field::__field0),
                        "participantId" => _serde::__private::Ok(__Field::__field1),
                        "role" => _serde::__private::Ok(__Field::__field2),
                        "authToken" => _serde::__private::Ok(__Field::__field3),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"callId" => _serde::__private::Ok(__Field::__field0),
                        b"participantId" => _serde::__private::Ok(__Field::__field1),
                        b"role" => _serde::__private::Ok(__Field::__field2),
                        b"authToken" => _serde::__private::Ok(__Field::__field3),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<JoinInfo>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = JoinInfo;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct JoinInfo",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct JoinInfo with 4 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct JoinInfo with 4 elements",
                                ),
                            );
                        }
                    };
                    let __field2 = match _serde::de::SeqAccess::next_element::<
                        Role,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct JoinInfo with 4 elements",
                                ),
                            );
                        }
                    };
                    let __field3 = match _serde::de::SeqAccess::next_element::<
                        Option<String>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct JoinInfo with 4 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(JoinInfo {
                        call_id: __field0,
                        participant_id: __field1,
                        role: __field2,
                        auth_token: __field3,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field2: _serde::__private::Option<Role> = _serde::__private::None;
                    let mut __field3: _serde::__private::Option<Option<String>> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("callId"),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "participantId",
                                        ),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private::Option::is_some(&__field2) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("role"),
                                    );
                                }
                                __field2 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<Role>(&mut __map)?,
                                );
                            }
                            __Field::__field3 => {
                                if _serde::__private::Option::is_some(&__field3) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "authToken",
                                        ),
                                    );
                                }
                                __field3 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        Option<String>,
                                    >(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("callId")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("participantId")?
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private::Some(__field2) => __field2,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("role")?
                        }
                    };
                    let __field3 = match __field3 {
                        _serde::__private::Some(__field3) => __field3,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("authToken")?
                        }
                    };
                    _serde::__private::Ok(JoinInfo {
                        call_id: __field0,
                        participant_id: __field1,
                        role: __field2,
                        auth_token: __field3,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &[
                "callId",
                "participantId",
                "role",
                "authToken",
            ];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "JoinInfo",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<JoinInfo>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[serde(rename_all = "camelCase")]
pub struct CallState {
    pub call_info: CallInfo,
    pub participants: Vec<ParticipantInfo>,
    pub chat_history: Vec<ChatMessage>,
}
#[automatically_derived]
impl ::core::fmt::Debug for CallState {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field3_finish(
            f,
            "CallState",
            "call_info",
            &self.call_info,
            "participants",
            &self.participants,
            "chat_history",
            &&self.chat_history,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for CallState {
    #[inline]
    fn clone(&self) -> CallState {
        CallState {
            call_info: ::core::clone::Clone::clone(&self.call_info),
            participants: ::core::clone::Clone::clone(&self.participants),
            chat_history: ::core::clone::Clone::clone(&self.chat_history),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for CallState {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "CallState",
                false as usize + 1 + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "callInfo",
                &self.call_info,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "participants",
                &self.participants,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "chatHistory",
                &self.chat_history,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for CallState {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "callInfo" => _serde::__private::Ok(__Field::__field0),
                        "participants" => _serde::__private::Ok(__Field::__field1),
                        "chatHistory" => _serde::__private::Ok(__Field::__field2),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"callInfo" => _serde::__private::Ok(__Field::__field0),
                        b"participants" => _serde::__private::Ok(__Field::__field1),
                        b"chatHistory" => _serde::__private::Ok(__Field::__field2),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<CallState>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = CallState;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct CallState",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        CallInfo,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct CallState with 3 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        Vec<ParticipantInfo>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct CallState with 3 elements",
                                ),
                            );
                        }
                    };
                    let __field2 = match _serde::de::SeqAccess::next_element::<
                        Vec<ChatMessage>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct CallState with 3 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(CallState {
                        call_info: __field0,
                        participants: __field1,
                        chat_history: __field2,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<CallInfo> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<Vec<ParticipantInfo>> = _serde::__private::None;
                    let mut __field2: _serde::__private::Option<Vec<ChatMessage>> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "callInfo",
                                        ),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<CallInfo>(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "participants",
                                        ),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        Vec<ParticipantInfo>,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private::Option::is_some(&__field2) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "chatHistory",
                                        ),
                                    );
                                }
                                __field2 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        Vec<ChatMessage>,
                                    >(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("callInfo")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("participants")?
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private::Some(__field2) => __field2,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("chatHistory")?
                        }
                    };
                    _serde::__private::Ok(CallState {
                        call_info: __field0,
                        participants: __field1,
                        chat_history: __field2,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &[
                "callInfo",
                "participants",
                "chatHistory",
            ];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "CallState",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<CallState>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[serde(rename_all = "camelCase")]
pub struct ParticipantInfo {
    pub id: String,
    pub display_name: String,
    pub role: Role,
    pub is_muted: bool,
}
#[automatically_derived]
impl ::core::fmt::Debug for ParticipantInfo {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field4_finish(
            f,
            "ParticipantInfo",
            "id",
            &self.id,
            "display_name",
            &self.display_name,
            "role",
            &self.role,
            "is_muted",
            &&self.is_muted,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for ParticipantInfo {
    #[inline]
    fn clone(&self) -> ParticipantInfo {
        ParticipantInfo {
            id: ::core::clone::Clone::clone(&self.id),
            display_name: ::core::clone::Clone::clone(&self.display_name),
            role: ::core::clone::Clone::clone(&self.role),
            is_muted: ::core::clone::Clone::clone(&self.is_muted),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for ParticipantInfo {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "ParticipantInfo",
                false as usize + 1 + 1 + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "id",
                &self.id,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "displayName",
                &self.display_name,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "role",
                &self.role,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "isMuted",
                &self.is_muted,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for ParticipantInfo {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "id" => _serde::__private::Ok(__Field::__field0),
                        "displayName" => _serde::__private::Ok(__Field::__field1),
                        "role" => _serde::__private::Ok(__Field::__field2),
                        "isMuted" => _serde::__private::Ok(__Field::__field3),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"id" => _serde::__private::Ok(__Field::__field0),
                        b"displayName" => _serde::__private::Ok(__Field::__field1),
                        b"role" => _serde::__private::Ok(__Field::__field2),
                        b"isMuted" => _serde::__private::Ok(__Field::__field3),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<ParticipantInfo>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = ParticipantInfo;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct ParticipantInfo",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct ParticipantInfo with 4 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct ParticipantInfo with 4 elements",
                                ),
                            );
                        }
                    };
                    let __field2 = match _serde::de::SeqAccess::next_element::<
                        Role,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct ParticipantInfo with 4 elements",
                                ),
                            );
                        }
                    };
                    let __field3 = match _serde::de::SeqAccess::next_element::<
                        bool,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct ParticipantInfo with 4 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(ParticipantInfo {
                        id: __field0,
                        display_name: __field1,
                        role: __field2,
                        is_muted: __field3,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field2: _serde::__private::Option<Role> = _serde::__private::None;
                    let mut __field3: _serde::__private::Option<bool> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "displayName",
                                        ),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private::Option::is_some(&__field2) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("role"),
                                    );
                                }
                                __field2 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<Role>(&mut __map)?,
                                );
                            }
                            __Field::__field3 => {
                                if _serde::__private::Option::is_some(&__field3) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "isMuted",
                                        ),
                                    );
                                }
                                __field3 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("id")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("displayName")?
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private::Some(__field2) => __field2,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("role")?
                        }
                    };
                    let __field3 = match __field3 {
                        _serde::__private::Some(__field3) => __field3,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("isMuted")?
                        }
                    };
                    _serde::__private::Ok(ParticipantInfo {
                        id: __field0,
                        display_name: __field1,
                        role: __field2,
                        is_muted: __field3,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &[
                "id",
                "displayName",
                "role",
                "isMuted",
            ];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "ParticipantInfo",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<ParticipantInfo>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[serde(rename_all = "camelCase")]
pub struct ChatMessage {
    pub id: String,
    pub sender_id: String,
    pub sender_name: String,
    pub content: String,
    pub timestamp: u64,
}
#[automatically_derived]
impl ::core::fmt::Debug for ChatMessage {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field5_finish(
            f,
            "ChatMessage",
            "id",
            &self.id,
            "sender_id",
            &self.sender_id,
            "sender_name",
            &self.sender_name,
            "content",
            &self.content,
            "timestamp",
            &&self.timestamp,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for ChatMessage {
    #[inline]
    fn clone(&self) -> ChatMessage {
        ChatMessage {
            id: ::core::clone::Clone::clone(&self.id),
            sender_id: ::core::clone::Clone::clone(&self.sender_id),
            sender_name: ::core::clone::Clone::clone(&self.sender_name),
            content: ::core::clone::Clone::clone(&self.content),
            timestamp: ::core::clone::Clone::clone(&self.timestamp),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for ChatMessage {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "ChatMessage",
                false as usize + 1 + 1 + 1 + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "id",
                &self.id,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "senderId",
                &self.sender_id,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "senderName",
                &self.sender_name,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "content",
                &self.content,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "timestamp",
                &self.timestamp,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for ChatMessage {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __field4,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        4u64 => _serde::__private::Ok(__Field::__field4),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "id" => _serde::__private::Ok(__Field::__field0),
                        "senderId" => _serde::__private::Ok(__Field::__field1),
                        "senderName" => _serde::__private::Ok(__Field::__field2),
                        "content" => _serde::__private::Ok(__Field::__field3),
                        "timestamp" => _serde::__private::Ok(__Field::__field4),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"id" => _serde::__private::Ok(__Field::__field0),
                        b"senderId" => _serde::__private::Ok(__Field::__field1),
                        b"senderName" => _serde::__private::Ok(__Field::__field2),
                        b"content" => _serde::__private::Ok(__Field::__field3),
                        b"timestamp" => _serde::__private::Ok(__Field::__field4),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<ChatMessage>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = ChatMessage;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct ChatMessage",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct ChatMessage with 5 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct ChatMessage with 5 elements",
                                ),
                            );
                        }
                    };
                    let __field2 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct ChatMessage with 5 elements",
                                ),
                            );
                        }
                    };
                    let __field3 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct ChatMessage with 5 elements",
                                ),
                            );
                        }
                    };
                    let __field4 = match _serde::de::SeqAccess::next_element::<
                        u64,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    4usize,
                                    &"struct ChatMessage with 5 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(ChatMessage {
                        id: __field0,
                        sender_id: __field1,
                        sender_name: __field2,
                        content: __field3,
                        timestamp: __field4,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field4: _serde::__private::Option<u64> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "senderId",
                                        ),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private::Option::is_some(&__field2) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "senderName",
                                        ),
                                    );
                                }
                                __field2 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field3 => {
                                if _serde::__private::Option::is_some(&__field3) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "content",
                                        ),
                                    );
                                }
                                __field3 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field4 => {
                                if _serde::__private::Option::is_some(&__field4) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "timestamp",
                                        ),
                                    );
                                }
                                __field4 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("id")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("senderId")?
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private::Some(__field2) => __field2,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("senderName")?
                        }
                    };
                    let __field3 = match __field3 {
                        _serde::__private::Some(__field3) => __field3,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("content")?
                        }
                    };
                    let __field4 = match __field4 {
                        _serde::__private::Some(__field4) => __field4,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("timestamp")?
                        }
                    };
                    _serde::__private::Ok(ChatMessage {
                        id: __field0,
                        sender_id: __field1,
                        sender_name: __field2,
                        content: __field3,
                        timestamp: __field4,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &[
                "id",
                "senderId",
                "senderName",
                "content",
                "timestamp",
            ];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "ChatMessage",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<ChatMessage>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[serde(rename_all = "camelCase")]
pub struct LeaveCallReq {
    pub call_id: String,
    pub participant_id: String,
}
#[automatically_derived]
impl ::core::fmt::Debug for LeaveCallReq {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field2_finish(
            f,
            "LeaveCallReq",
            "call_id",
            &self.call_id,
            "participant_id",
            &&self.participant_id,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for LeaveCallReq {
    #[inline]
    fn clone(&self) -> LeaveCallReq {
        LeaveCallReq {
            call_id: ::core::clone::Clone::clone(&self.call_id),
            participant_id: ::core::clone::Clone::clone(&self.participant_id),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for LeaveCallReq {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "LeaveCallReq",
                false as usize + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "callId",
                &self.call_id,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "participantId",
                &self.participant_id,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for LeaveCallReq {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "callId" => _serde::__private::Ok(__Field::__field0),
                        "participantId" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"callId" => _serde::__private::Ok(__Field::__field0),
                        b"participantId" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<LeaveCallReq>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = LeaveCallReq;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct LeaveCallReq",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct LeaveCallReq with 2 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct LeaveCallReq with 2 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(LeaveCallReq {
                        call_id: __field0,
                        participant_id: __field1,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("callId"),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "participantId",
                                        ),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("callId")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("participantId")?
                        }
                    };
                    _serde::__private::Ok(LeaveCallReq {
                        call_id: __field0,
                        participant_id: __field1,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["callId", "participantId"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "LeaveCallReq",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<LeaveCallReq>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[serde(rename_all = "camelCase")]
pub struct UpdateRoleReq {
    pub call_id: String,
    pub requester_id: String,
    pub target_id: String,
    pub new_role: Role,
}
#[automatically_derived]
impl ::core::fmt::Debug for UpdateRoleReq {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field4_finish(
            f,
            "UpdateRoleReq",
            "call_id",
            &self.call_id,
            "requester_id",
            &self.requester_id,
            "target_id",
            &self.target_id,
            "new_role",
            &&self.new_role,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for UpdateRoleReq {
    #[inline]
    fn clone(&self) -> UpdateRoleReq {
        UpdateRoleReq {
            call_id: ::core::clone::Clone::clone(&self.call_id),
            requester_id: ::core::clone::Clone::clone(&self.requester_id),
            target_id: ::core::clone::Clone::clone(&self.target_id),
            new_role: ::core::clone::Clone::clone(&self.new_role),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for UpdateRoleReq {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "UpdateRoleReq",
                false as usize + 1 + 1 + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "callId",
                &self.call_id,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "requesterId",
                &self.requester_id,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "targetId",
                &self.target_id,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "newRole",
                &self.new_role,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for UpdateRoleReq {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "callId" => _serde::__private::Ok(__Field::__field0),
                        "requesterId" => _serde::__private::Ok(__Field::__field1),
                        "targetId" => _serde::__private::Ok(__Field::__field2),
                        "newRole" => _serde::__private::Ok(__Field::__field3),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"callId" => _serde::__private::Ok(__Field::__field0),
                        b"requesterId" => _serde::__private::Ok(__Field::__field1),
                        b"targetId" => _serde::__private::Ok(__Field::__field2),
                        b"newRole" => _serde::__private::Ok(__Field::__field3),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<UpdateRoleReq>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = UpdateRoleReq;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct UpdateRoleReq",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct UpdateRoleReq with 4 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct UpdateRoleReq with 4 elements",
                                ),
                            );
                        }
                    };
                    let __field2 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct UpdateRoleReq with 4 elements",
                                ),
                            );
                        }
                    };
                    let __field3 = match _serde::de::SeqAccess::next_element::<
                        Role,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct UpdateRoleReq with 4 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(UpdateRoleReq {
                        call_id: __field0,
                        requester_id: __field1,
                        target_id: __field2,
                        new_role: __field3,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field3: _serde::__private::Option<Role> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("callId"),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "requesterId",
                                        ),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private::Option::is_some(&__field2) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "targetId",
                                        ),
                                    );
                                }
                                __field2 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field3 => {
                                if _serde::__private::Option::is_some(&__field3) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "newRole",
                                        ),
                                    );
                                }
                                __field3 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<Role>(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("callId")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("requesterId")?
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private::Some(__field2) => __field2,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("targetId")?
                        }
                    };
                    let __field3 = match __field3 {
                        _serde::__private::Some(__field3) => __field3,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("newRole")?
                        }
                    };
                    _serde::__private::Ok(UpdateRoleReq {
                        call_id: __field0,
                        requester_id: __field1,
                        target_id: __field2,
                        new_role: __field3,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &[
                "callId",
                "requesterId",
                "targetId",
                "newRole",
            ];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "UpdateRoleReq",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<UpdateRoleReq>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[serde(rename_all = "camelCase")]
pub struct NodeHandshakeReq {
    pub call_id: String,
}
#[automatically_derived]
impl ::core::fmt::Debug for NodeHandshakeReq {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field1_finish(
            f,
            "NodeHandshakeReq",
            "call_id",
            &&self.call_id,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for NodeHandshakeReq {
    #[inline]
    fn clone(&self) -> NodeHandshakeReq {
        NodeHandshakeReq {
            call_id: ::core::clone::Clone::clone(&self.call_id),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for NodeHandshakeReq {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "NodeHandshakeReq",
                false as usize + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "callId",
                &self.call_id,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for NodeHandshakeReq {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "callId" => _serde::__private::Ok(__Field::__field0),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"callId" => _serde::__private::Ok(__Field::__field0),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<NodeHandshakeReq>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = NodeHandshakeReq;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct NodeHandshakeReq",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct NodeHandshakeReq with 1 element",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(NodeHandshakeReq {
                        call_id: __field0,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("callId"),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("callId")?
                        }
                    };
                    _serde::__private::Ok(NodeHandshakeReq {
                        call_id: __field0,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["callId"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "NodeHandshakeReq",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<NodeHandshakeReq>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[serde(rename_all = "camelCase")]
pub struct NodeHandshakeResp {
    pub auth_token: String,
    pub redirect_url: String,
}
#[automatically_derived]
impl ::core::fmt::Debug for NodeHandshakeResp {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field2_finish(
            f,
            "NodeHandshakeResp",
            "auth_token",
            &self.auth_token,
            "redirect_url",
            &&self.redirect_url,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for NodeHandshakeResp {
    #[inline]
    fn clone(&self) -> NodeHandshakeResp {
        NodeHandshakeResp {
            auth_token: ::core::clone::Clone::clone(&self.auth_token),
            redirect_url: ::core::clone::Clone::clone(&self.redirect_url),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for NodeHandshakeResp {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "NodeHandshakeResp",
                false as usize + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "authToken",
                &self.auth_token,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "redirectUrl",
                &self.redirect_url,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for NodeHandshakeResp {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "authToken" => _serde::__private::Ok(__Field::__field0),
                        "redirectUrl" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"authToken" => _serde::__private::Ok(__Field::__field0),
                        b"redirectUrl" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<NodeHandshakeResp>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = NodeHandshakeResp;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct NodeHandshakeResp",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct NodeHandshakeResp with 2 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct NodeHandshakeResp with 2 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(NodeHandshakeResp {
                        auth_token: __field0,
                        redirect_url: __field1,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "authToken",
                                        ),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "redirectUrl",
                                        ),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("authToken")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("redirectUrl")?
                        }
                    };
                    _serde::__private::Ok(NodeHandshakeResp {
                        auth_token: __field0,
                        redirect_url: __field1,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["authToken", "redirectUrl"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "NodeHandshakeResp",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<NodeHandshakeResp>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
pub enum WsClientMessage {
    #[serde(rename_all = "camelCase")]
    Authenticate { participant_id: String, auth_token: String },
    Chat(String),
    Mute(bool),
    WebrtcSignal(SignalData),
    Heartbeat,
}
#[automatically_derived]
impl ::core::fmt::Debug for WsClientMessage {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            WsClientMessage::Authenticate {
                participant_id: __self_0,
                auth_token: __self_1,
            } => {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "Authenticate",
                    "participant_id",
                    __self_0,
                    "auth_token",
                    &__self_1,
                )
            }
            WsClientMessage::Chat(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Chat", &__self_0)
            }
            WsClientMessage::Mute(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Mute", &__self_0)
            }
            WsClientMessage::WebrtcSignal(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "WebrtcSignal",
                    &__self_0,
                )
            }
            WsClientMessage::Heartbeat => {
                ::core::fmt::Formatter::write_str(f, "Heartbeat")
            }
        }
    }
}
#[automatically_derived]
impl ::core::clone::Clone for WsClientMessage {
    #[inline]
    fn clone(&self) -> WsClientMessage {
        match self {
            WsClientMessage::Authenticate {
                participant_id: __self_0,
                auth_token: __self_1,
            } => {
                WsClientMessage::Authenticate {
                    participant_id: ::core::clone::Clone::clone(__self_0),
                    auth_token: ::core::clone::Clone::clone(__self_1),
                }
            }
            WsClientMessage::Chat(__self_0) => {
                WsClientMessage::Chat(::core::clone::Clone::clone(__self_0))
            }
            WsClientMessage::Mute(__self_0) => {
                WsClientMessage::Mute(::core::clone::Clone::clone(__self_0))
            }
            WsClientMessage::WebrtcSignal(__self_0) => {
                WsClientMessage::WebrtcSignal(::core::clone::Clone::clone(__self_0))
            }
            WsClientMessage::Heartbeat => WsClientMessage::Heartbeat,
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for WsClientMessage {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                WsClientMessage::Authenticate { ref participant_id, ref auth_token } => {
                    let mut __serde_state = _serde::Serializer::serialize_struct_variant(
                        __serializer,
                        "WsClientMessage",
                        0u32,
                        "Authenticate",
                        0 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStructVariant::serialize_field(
                        &mut __serde_state,
                        "participantId",
                        participant_id,
                    )?;
                    _serde::ser::SerializeStructVariant::serialize_field(
                        &mut __serde_state,
                        "authToken",
                        auth_token,
                    )?;
                    _serde::ser::SerializeStructVariant::end(__serde_state)
                }
                WsClientMessage::Chat(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "WsClientMessage",
                        1u32,
                        "Chat",
                        __field0,
                    )
                }
                WsClientMessage::Mute(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "WsClientMessage",
                        2u32,
                        "Mute",
                        __field0,
                    )
                }
                WsClientMessage::WebrtcSignal(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "WsClientMessage",
                        3u32,
                        "WebrtcSignal",
                        __field0,
                    )
                }
                WsClientMessage::Heartbeat => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "WsClientMessage",
                        4u32,
                        "Heartbeat",
                    )
                }
            }
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for WsClientMessage {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __field4,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "variant identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        4u64 => _serde::__private::Ok(__Field::__field4),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 5",
                                ),
                            )
                        }
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "Authenticate" => _serde::__private::Ok(__Field::__field0),
                        "Chat" => _serde::__private::Ok(__Field::__field1),
                        "Mute" => _serde::__private::Ok(__Field::__field2),
                        "WebrtcSignal" => _serde::__private::Ok(__Field::__field3),
                        "Heartbeat" => _serde::__private::Ok(__Field::__field4),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"Authenticate" => _serde::__private::Ok(__Field::__field0),
                        b"Chat" => _serde::__private::Ok(__Field::__field1),
                        b"Mute" => _serde::__private::Ok(__Field::__field2),
                        b"WebrtcSignal" => _serde::__private::Ok(__Field::__field3),
                        b"Heartbeat" => _serde::__private::Ok(__Field::__field4),
                        _ => {
                            let __value = &_serde::__private::from_utf8_lossy(__value);
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<WsClientMessage>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = WsClientMessage;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "enum WsClientMessage",
                    )
                }
                fn visit_enum<__A>(
                    self,
                    __data: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::EnumAccess<'de>,
                {
                    match _serde::de::EnumAccess::variant(__data)? {
                        (__Field::__field0, __variant) => {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __field0,
                                __field1,
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "participantId" => _serde::__private::Ok(__Field::__field0),
                                        "authToken" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"participantId" => _serde::__private::Ok(__Field::__field0),
                                        b"authToken" => _serde::__private::Ok(__Field::__field1),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<WsClientMessage>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = WsClientMessage;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct variant WsClientMessage::Authenticate",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"struct variant WsClientMessage::Authenticate with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct variant WsClientMessage::Authenticate with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(WsClientMessage::Authenticate {
                                        participant_id: __field0,
                                        auth_token: __field1,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "participantId",
                                                        ),
                                                    );
                                                }
                                                __field0 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde::__private::Err(
                                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                                            "authToken",
                                                        ),
                                                    );
                                                }
                                                __field1 = _serde::__private::Some(
                                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                );
                                            }
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("participantId")?
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            _serde::__private::de::missing_field("authToken")?
                                        }
                                    };
                                    _serde::__private::Ok(WsClientMessage::Authenticate {
                                        participant_id: __field0,
                                        auth_token: __field1,
                                    })
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[
                                "participantId",
                                "authToken",
                            ];
                            _serde::de::VariantAccess::struct_variant(
                                __variant,
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<WsClientMessage>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                        (__Field::__field1, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    String,
                                >(__variant),
                                WsClientMessage::Chat,
                            )
                        }
                        (__Field::__field2, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    bool,
                                >(__variant),
                                WsClientMessage::Mute,
                            )
                        }
                        (__Field::__field3, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    SignalData,
                                >(__variant),
                                WsClientMessage::WebrtcSignal,
                            )
                        }
                        (__Field::__field4, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(WsClientMessage::Heartbeat)
                        }
                    }
                }
            }
            #[doc(hidden)]
            const VARIANTS: &'static [&'static str] = &[
                "Authenticate",
                "Chat",
                "Mute",
                "WebrtcSignal",
                "Heartbeat",
            ];
            _serde::Deserializer::deserialize_enum(
                __deserializer,
                "WsClientMessage",
                VARIANTS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<WsClientMessage>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[serde(rename_all = "camelCase")]
pub struct WsChatMessage {
    pub message: ChatMessage,
}
#[automatically_derived]
impl ::core::fmt::Debug for WsChatMessage {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field1_finish(
            f,
            "WsChatMessage",
            "message",
            &&self.message,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for WsChatMessage {
    #[inline]
    fn clone(&self) -> WsChatMessage {
        WsChatMessage {
            message: ::core::clone::Clone::clone(&self.message),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for WsChatMessage {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "WsChatMessage",
                false as usize + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "message",
                &self.message,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for WsChatMessage {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "message" => _serde::__private::Ok(__Field::__field0),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"message" => _serde::__private::Ok(__Field::__field0),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<WsChatMessage>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = WsChatMessage;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct WsChatMessage",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        ChatMessage,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct WsChatMessage with 1 element",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(WsChatMessage { message: __field0 })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<ChatMessage> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "message",
                                        ),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        ChatMessage,
                                    >(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("message")?
                        }
                    };
                    _serde::__private::Ok(WsChatMessage { message: __field0 })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["message"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "WsChatMessage",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<WsChatMessage>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[serde(rename_all = "camelCase")]
pub struct WsParticipantJoined {
    pub participant: ParticipantInfo,
}
#[automatically_derived]
impl ::core::fmt::Debug for WsParticipantJoined {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field1_finish(
            f,
            "WsParticipantJoined",
            "participant",
            &&self.participant,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for WsParticipantJoined {
    #[inline]
    fn clone(&self) -> WsParticipantJoined {
        WsParticipantJoined {
            participant: ::core::clone::Clone::clone(&self.participant),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for WsParticipantJoined {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "WsParticipantJoined",
                false as usize + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "participant",
                &self.participant,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for WsParticipantJoined {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "participant" => _serde::__private::Ok(__Field::__field0),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"participant" => _serde::__private::Ok(__Field::__field0),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<WsParticipantJoined>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = WsParticipantJoined;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct WsParticipantJoined",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        ParticipantInfo,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct WsParticipantJoined with 1 element",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(WsParticipantJoined {
                        participant: __field0,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<ParticipantInfo> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "participant",
                                        ),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        ParticipantInfo,
                                    >(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("participant")?
                        }
                    };
                    _serde::__private::Ok(WsParticipantJoined {
                        participant: __field0,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["participant"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "WsParticipantJoined",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<WsParticipantJoined>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[serde(rename_all = "camelCase")]
pub struct WsRoleUpdate {
    pub participant_id: String,
    pub new_role: Role,
}
#[automatically_derived]
impl ::core::fmt::Debug for WsRoleUpdate {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field2_finish(
            f,
            "WsRoleUpdate",
            "participant_id",
            &self.participant_id,
            "new_role",
            &&self.new_role,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for WsRoleUpdate {
    #[inline]
    fn clone(&self) -> WsRoleUpdate {
        WsRoleUpdate {
            participant_id: ::core::clone::Clone::clone(&self.participant_id),
            new_role: ::core::clone::Clone::clone(&self.new_role),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for WsRoleUpdate {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "WsRoleUpdate",
                false as usize + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "participantId",
                &self.participant_id,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "newRole",
                &self.new_role,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for WsRoleUpdate {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "participantId" => _serde::__private::Ok(__Field::__field0),
                        "newRole" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"participantId" => _serde::__private::Ok(__Field::__field0),
                        b"newRole" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<WsRoleUpdate>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = WsRoleUpdate;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct WsRoleUpdate",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct WsRoleUpdate with 2 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        Role,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct WsRoleUpdate with 2 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(WsRoleUpdate {
                        participant_id: __field0,
                        new_role: __field1,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<Role> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "participantId",
                                        ),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "newRole",
                                        ),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<Role>(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("participantId")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("newRole")?
                        }
                    };
                    _serde::__private::Ok(WsRoleUpdate {
                        participant_id: __field0,
                        new_role: __field1,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["participantId", "newRole"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "WsRoleUpdate",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<WsRoleUpdate>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[serde(rename_all = "camelCase")]
pub struct WsParticipantMuted {
    pub participant_id: String,
    pub is_muted: bool,
}
#[automatically_derived]
impl ::core::fmt::Debug for WsParticipantMuted {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field2_finish(
            f,
            "WsParticipantMuted",
            "participant_id",
            &self.participant_id,
            "is_muted",
            &&self.is_muted,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for WsParticipantMuted {
    #[inline]
    fn clone(&self) -> WsParticipantMuted {
        WsParticipantMuted {
            participant_id: ::core::clone::Clone::clone(&self.participant_id),
            is_muted: ::core::clone::Clone::clone(&self.is_muted),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for WsParticipantMuted {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "WsParticipantMuted",
                false as usize + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "participantId",
                &self.participant_id,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "isMuted",
                &self.is_muted,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for WsParticipantMuted {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "participantId" => _serde::__private::Ok(__Field::__field0),
                        "isMuted" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"participantId" => _serde::__private::Ok(__Field::__field0),
                        b"isMuted" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<WsParticipantMuted>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = WsParticipantMuted;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct WsParticipantMuted",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct WsParticipantMuted with 2 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        bool,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct WsParticipantMuted with 2 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(WsParticipantMuted {
                        participant_id: __field0,
                        is_muted: __field1,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<bool> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "participantId",
                                        ),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "isMuted",
                                        ),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("participantId")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("isMuted")?
                        }
                    };
                    _serde::__private::Ok(WsParticipantMuted {
                        participant_id: __field0,
                        is_muted: __field1,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["participantId", "isMuted"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "WsParticipantMuted",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<WsParticipantMuted>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[serde(rename_all = "camelCase")]
pub struct WsWebrtcSignal {
    pub sender_id: String,
    pub signal: SignalData,
}
#[automatically_derived]
impl ::core::fmt::Debug for WsWebrtcSignal {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field2_finish(
            f,
            "WsWebrtcSignal",
            "sender_id",
            &self.sender_id,
            "signal",
            &&self.signal,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for WsWebrtcSignal {
    #[inline]
    fn clone(&self) -> WsWebrtcSignal {
        WsWebrtcSignal {
            sender_id: ::core::clone::Clone::clone(&self.sender_id),
            signal: ::core::clone::Clone::clone(&self.signal),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for WsWebrtcSignal {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "WsWebrtcSignal",
                false as usize + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "senderId",
                &self.sender_id,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "signal",
                &self.signal,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for WsWebrtcSignal {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "senderId" => _serde::__private::Ok(__Field::__field0),
                        "signal" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"senderId" => _serde::__private::Ok(__Field::__field0),
                        b"signal" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<WsWebrtcSignal>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = WsWebrtcSignal;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct WsWebrtcSignal",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct WsWebrtcSignal with 2 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        SignalData,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct WsWebrtcSignal with 2 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(WsWebrtcSignal {
                        sender_id: __field0,
                        signal: __field1,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<SignalData> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "senderId",
                                        ),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("signal"),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<SignalData>(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("senderId")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("signal")?
                        }
                    };
                    _serde::__private::Ok(WsWebrtcSignal {
                        sender_id: __field0,
                        signal: __field1,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["senderId", "signal"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "WsWebrtcSignal",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<WsWebrtcSignal>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
pub enum WsServerMessage {
    Chat(WsChatMessage),
    ParticipantJoined(WsParticipantJoined),
    ParticipantLeft(String),
    RoleUpdated(WsRoleUpdate),
    ParticipantMuted(WsParticipantMuted),
    WebrtcSignal(WsWebrtcSignal),
    Error(String),
    CallEnded,
}
#[automatically_derived]
impl ::core::fmt::Debug for WsServerMessage {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            WsServerMessage::Chat(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Chat", &__self_0)
            }
            WsServerMessage::ParticipantJoined(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "ParticipantJoined",
                    &__self_0,
                )
            }
            WsServerMessage::ParticipantLeft(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "ParticipantLeft",
                    &__self_0,
                )
            }
            WsServerMessage::RoleUpdated(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "RoleUpdated",
                    &__self_0,
                )
            }
            WsServerMessage::ParticipantMuted(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "ParticipantMuted",
                    &__self_0,
                )
            }
            WsServerMessage::WebrtcSignal(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "WebrtcSignal",
                    &__self_0,
                )
            }
            WsServerMessage::Error(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Error", &__self_0)
            }
            WsServerMessage::CallEnded => {
                ::core::fmt::Formatter::write_str(f, "CallEnded")
            }
        }
    }
}
#[automatically_derived]
impl ::core::clone::Clone for WsServerMessage {
    #[inline]
    fn clone(&self) -> WsServerMessage {
        match self {
            WsServerMessage::Chat(__self_0) => {
                WsServerMessage::Chat(::core::clone::Clone::clone(__self_0))
            }
            WsServerMessage::ParticipantJoined(__self_0) => {
                WsServerMessage::ParticipantJoined(::core::clone::Clone::clone(__self_0))
            }
            WsServerMessage::ParticipantLeft(__self_0) => {
                WsServerMessage::ParticipantLeft(::core::clone::Clone::clone(__self_0))
            }
            WsServerMessage::RoleUpdated(__self_0) => {
                WsServerMessage::RoleUpdated(::core::clone::Clone::clone(__self_0))
            }
            WsServerMessage::ParticipantMuted(__self_0) => {
                WsServerMessage::ParticipantMuted(::core::clone::Clone::clone(__self_0))
            }
            WsServerMessage::WebrtcSignal(__self_0) => {
                WsServerMessage::WebrtcSignal(::core::clone::Clone::clone(__self_0))
            }
            WsServerMessage::Error(__self_0) => {
                WsServerMessage::Error(::core::clone::Clone::clone(__self_0))
            }
            WsServerMessage::CallEnded => WsServerMessage::CallEnded,
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for WsServerMessage {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                WsServerMessage::Chat(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "WsServerMessage",
                        0u32,
                        "Chat",
                        __field0,
                    )
                }
                WsServerMessage::ParticipantJoined(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "WsServerMessage",
                        1u32,
                        "ParticipantJoined",
                        __field0,
                    )
                }
                WsServerMessage::ParticipantLeft(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "WsServerMessage",
                        2u32,
                        "ParticipantLeft",
                        __field0,
                    )
                }
                WsServerMessage::RoleUpdated(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "WsServerMessage",
                        3u32,
                        "RoleUpdated",
                        __field0,
                    )
                }
                WsServerMessage::ParticipantMuted(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "WsServerMessage",
                        4u32,
                        "ParticipantMuted",
                        __field0,
                    )
                }
                WsServerMessage::WebrtcSignal(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "WsServerMessage",
                        5u32,
                        "WebrtcSignal",
                        __field0,
                    )
                }
                WsServerMessage::Error(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "WsServerMessage",
                        6u32,
                        "Error",
                        __field0,
                    )
                }
                WsServerMessage::CallEnded => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "WsServerMessage",
                        7u32,
                        "CallEnded",
                    )
                }
            }
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for WsServerMessage {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __field4,
                __field5,
                __field6,
                __field7,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "variant identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        4u64 => _serde::__private::Ok(__Field::__field4),
                        5u64 => _serde::__private::Ok(__Field::__field5),
                        6u64 => _serde::__private::Ok(__Field::__field6),
                        7u64 => _serde::__private::Ok(__Field::__field7),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 8",
                                ),
                            )
                        }
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "Chat" => _serde::__private::Ok(__Field::__field0),
                        "ParticipantJoined" => _serde::__private::Ok(__Field::__field1),
                        "ParticipantLeft" => _serde::__private::Ok(__Field::__field2),
                        "RoleUpdated" => _serde::__private::Ok(__Field::__field3),
                        "ParticipantMuted" => _serde::__private::Ok(__Field::__field4),
                        "WebrtcSignal" => _serde::__private::Ok(__Field::__field5),
                        "Error" => _serde::__private::Ok(__Field::__field6),
                        "CallEnded" => _serde::__private::Ok(__Field::__field7),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"Chat" => _serde::__private::Ok(__Field::__field0),
                        b"ParticipantJoined" => _serde::__private::Ok(__Field::__field1),
                        b"ParticipantLeft" => _serde::__private::Ok(__Field::__field2),
                        b"RoleUpdated" => _serde::__private::Ok(__Field::__field3),
                        b"ParticipantMuted" => _serde::__private::Ok(__Field::__field4),
                        b"WebrtcSignal" => _serde::__private::Ok(__Field::__field5),
                        b"Error" => _serde::__private::Ok(__Field::__field6),
                        b"CallEnded" => _serde::__private::Ok(__Field::__field7),
                        _ => {
                            let __value = &_serde::__private::from_utf8_lossy(__value);
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<WsServerMessage>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = WsServerMessage;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "enum WsServerMessage",
                    )
                }
                fn visit_enum<__A>(
                    self,
                    __data: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::EnumAccess<'de>,
                {
                    match _serde::de::EnumAccess::variant(__data)? {
                        (__Field::__field0, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    WsChatMessage,
                                >(__variant),
                                WsServerMessage::Chat,
                            )
                        }
                        (__Field::__field1, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    WsParticipantJoined,
                                >(__variant),
                                WsServerMessage::ParticipantJoined,
                            )
                        }
                        (__Field::__field2, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    String,
                                >(__variant),
                                WsServerMessage::ParticipantLeft,
                            )
                        }
                        (__Field::__field3, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    WsRoleUpdate,
                                >(__variant),
                                WsServerMessage::RoleUpdated,
                            )
                        }
                        (__Field::__field4, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    WsParticipantMuted,
                                >(__variant),
                                WsServerMessage::ParticipantMuted,
                            )
                        }
                        (__Field::__field5, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    WsWebrtcSignal,
                                >(__variant),
                                WsServerMessage::WebrtcSignal,
                            )
                        }
                        (__Field::__field6, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    String,
                                >(__variant),
                                WsServerMessage::Error,
                            )
                        }
                        (__Field::__field7, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(WsServerMessage::CallEnded)
                        }
                    }
                }
            }
            #[doc(hidden)]
            const VARIANTS: &'static [&'static str] = &[
                "Chat",
                "ParticipantJoined",
                "ParticipantLeft",
                "RoleUpdated",
                "ParticipantMuted",
                "WebrtcSignal",
                "Error",
                "CallEnded",
            ];
            _serde::Deserializer::deserialize_enum(
                __deserializer,
                "WsServerMessage",
                VARIANTS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<WsServerMessage>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[serde(rename_all = "camelCase")]
pub struct SignalData {
    pub target: String,
    pub signal_type: String,
    pub payload: String,
}
#[automatically_derived]
impl ::core::fmt::Debug for SignalData {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field3_finish(
            f,
            "SignalData",
            "target",
            &self.target,
            "signal_type",
            &self.signal_type,
            "payload",
            &&self.payload,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for SignalData {
    #[inline]
    fn clone(&self) -> SignalData {
        SignalData {
            target: ::core::clone::Clone::clone(&self.target),
            signal_type: ::core::clone::Clone::clone(&self.signal_type),
            payload: ::core::clone::Clone::clone(&self.payload),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for SignalData {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "SignalData",
                false as usize + 1 + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "target",
                &self.target,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "signalType",
                &self.signal_type,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "payload",
                &self.payload,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for SignalData {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "target" => _serde::__private::Ok(__Field::__field0),
                        "signalType" => _serde::__private::Ok(__Field::__field1),
                        "payload" => _serde::__private::Ok(__Field::__field2),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"target" => _serde::__private::Ok(__Field::__field0),
                        b"signalType" => _serde::__private::Ok(__Field::__field1),
                        b"payload" => _serde::__private::Ok(__Field::__field2),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<SignalData>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = SignalData;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct SignalData",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct SignalData with 3 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct SignalData with 3 elements",
                                ),
                            );
                        }
                    };
                    let __field2 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct SignalData with 3 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(SignalData {
                        target: __field0,
                        signal_type: __field1,
                        payload: __field2,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "signalType",
                                        ),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private::Option::is_some(&__field2) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "payload",
                                        ),
                                    );
                                }
                                __field2 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("target")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("signalType")?
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private::Some(__field2) => __field2,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("payload")?
                        }
                    };
                    _serde::__private::Ok(SignalData {
                        target: __field0,
                        signal_type: __field1,
                        payload: __field2,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["target", "signalType", "payload"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "SignalData",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<SignalData>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
struct VoiceState {
    calls: HashMap<String, Call>,
    connections: HashMap<u32, String>,
    participant_channels: HashMap<String, u32>,
    word_dictionary: Vec<String>,
    used_pleb_names: HashMap<String, Vec<String>>,
    node_auth_tokens: HashMap<String, String>,
}
#[automatically_derived]
impl ::core::default::Default for VoiceState {
    #[inline]
    fn default() -> VoiceState {
        VoiceState {
            calls: ::core::default::Default::default(),
            connections: ::core::default::Default::default(),
            participant_channels: ::core::default::Default::default(),
            word_dictionary: ::core::default::Default::default(),
            used_pleb_names: ::core::default::Default::default(),
            node_auth_tokens: ::core::default::Default::default(),
        }
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for VoiceState {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        let names: &'static _ = &[
            "calls",
            "connections",
            "participant_channels",
            "word_dictionary",
            "used_pleb_names",
            "node_auth_tokens",
        ];
        let values: &[&dyn ::core::fmt::Debug] = &[
            &self.calls,
            &self.connections,
            &self.participant_channels,
            &self.word_dictionary,
            &self.used_pleb_names,
            &&self.node_auth_tokens,
        ];
        ::core::fmt::Formatter::debug_struct_fields_finish(
            f,
            "VoiceState",
            names,
            values,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for VoiceState {
    #[inline]
    fn clone(&self) -> VoiceState {
        VoiceState {
            calls: ::core::clone::Clone::clone(&self.calls),
            connections: ::core::clone::Clone::clone(&self.connections),
            participant_channels: ::core::clone::Clone::clone(
                &self.participant_channels,
            ),
            word_dictionary: ::core::clone::Clone::clone(&self.word_dictionary),
            used_pleb_names: ::core::clone::Clone::clone(&self.used_pleb_names),
            node_auth_tokens: ::core::clone::Clone::clone(&self.node_auth_tokens),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for VoiceState {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "VoiceState",
                false as usize + 1 + 1 + 1 + 1 + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "calls",
                &self.calls,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "connections",
                &self.connections,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "participant_channels",
                &self.participant_channels,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "word_dictionary",
                &self.word_dictionary,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "used_pleb_names",
                &self.used_pleb_names,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "node_auth_tokens",
                &self.node_auth_tokens,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for VoiceState {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __field4,
                __field5,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        4u64 => _serde::__private::Ok(__Field::__field4),
                        5u64 => _serde::__private::Ok(__Field::__field5),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "calls" => _serde::__private::Ok(__Field::__field0),
                        "connections" => _serde::__private::Ok(__Field::__field1),
                        "participant_channels" => {
                            _serde::__private::Ok(__Field::__field2)
                        }
                        "word_dictionary" => _serde::__private::Ok(__Field::__field3),
                        "used_pleb_names" => _serde::__private::Ok(__Field::__field4),
                        "node_auth_tokens" => _serde::__private::Ok(__Field::__field5),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"calls" => _serde::__private::Ok(__Field::__field0),
                        b"connections" => _serde::__private::Ok(__Field::__field1),
                        b"participant_channels" => {
                            _serde::__private::Ok(__Field::__field2)
                        }
                        b"word_dictionary" => _serde::__private::Ok(__Field::__field3),
                        b"used_pleb_names" => _serde::__private::Ok(__Field::__field4),
                        b"node_auth_tokens" => _serde::__private::Ok(__Field::__field5),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<VoiceState>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = VoiceState;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct VoiceState",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        HashMap<String, Call>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct VoiceState with 6 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        HashMap<u32, String>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct VoiceState with 6 elements",
                                ),
                            );
                        }
                    };
                    let __field2 = match _serde::de::SeqAccess::next_element::<
                        HashMap<String, u32>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct VoiceState with 6 elements",
                                ),
                            );
                        }
                    };
                    let __field3 = match _serde::de::SeqAccess::next_element::<
                        Vec<String>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct VoiceState with 6 elements",
                                ),
                            );
                        }
                    };
                    let __field4 = match _serde::de::SeqAccess::next_element::<
                        HashMap<String, Vec<String>>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    4usize,
                                    &"struct VoiceState with 6 elements",
                                ),
                            );
                        }
                    };
                    let __field5 = match _serde::de::SeqAccess::next_element::<
                        HashMap<String, String>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    5usize,
                                    &"struct VoiceState with 6 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(VoiceState {
                        calls: __field0,
                        connections: __field1,
                        participant_channels: __field2,
                        word_dictionary: __field3,
                        used_pleb_names: __field4,
                        node_auth_tokens: __field5,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<HashMap<String, Call>> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<HashMap<u32, String>> = _serde::__private::None;
                    let mut __field2: _serde::__private::Option<HashMap<String, u32>> = _serde::__private::None;
                    let mut __field3: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                    let mut __field4: _serde::__private::Option<
                        HashMap<String, Vec<String>>,
                    > = _serde::__private::None;
                    let mut __field5: _serde::__private::Option<
                        HashMap<String, String>,
                    > = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("calls"),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        HashMap<String, Call>,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "connections",
                                        ),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        HashMap<u32, String>,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private::Option::is_some(&__field2) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "participant_channels",
                                        ),
                                    );
                                }
                                __field2 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        HashMap<String, u32>,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field3 => {
                                if _serde::__private::Option::is_some(&__field3) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "word_dictionary",
                                        ),
                                    );
                                }
                                __field3 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        Vec<String>,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field4 => {
                                if _serde::__private::Option::is_some(&__field4) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "used_pleb_names",
                                        ),
                                    );
                                }
                                __field4 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        HashMap<String, Vec<String>>,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field5 => {
                                if _serde::__private::Option::is_some(&__field5) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "node_auth_tokens",
                                        ),
                                    );
                                }
                                __field5 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        HashMap<String, String>,
                                    >(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("calls")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("connections")?
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private::Some(__field2) => __field2,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("participant_channels")?
                        }
                    };
                    let __field3 = match __field3 {
                        _serde::__private::Some(__field3) => __field3,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("word_dictionary")?
                        }
                    };
                    let __field4 = match __field4 {
                        _serde::__private::Some(__field4) => __field4,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("used_pleb_names")?
                        }
                    };
                    let __field5 = match __field5 {
                        _serde::__private::Some(__field5) => __field5,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("node_auth_tokens")?
                        }
                    };
                    _serde::__private::Ok(VoiceState {
                        calls: __field0,
                        connections: __field1,
                        participant_channels: __field2,
                        word_dictionary: __field3,
                        used_pleb_names: __field4,
                        node_auth_tokens: __field5,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &[
                "calls",
                "connections",
                "participant_channels",
                "word_dictionary",
                "used_pleb_names",
                "node_auth_tokens",
            ];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "VoiceState",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<VoiceState>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
struct Call {
    id: String,
    participants: HashMap<String, Participant>,
    chat_history: Vec<ChatMessage>,
    created_at: u64,
    default_role: Role,
    creator_id: Option<String>,
}
#[automatically_derived]
impl ::core::fmt::Debug for Call {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        let names: &'static _ = &[
            "id",
            "participants",
            "chat_history",
            "created_at",
            "default_role",
            "creator_id",
        ];
        let values: &[&dyn ::core::fmt::Debug] = &[
            &self.id,
            &self.participants,
            &self.chat_history,
            &self.created_at,
            &self.default_role,
            &&self.creator_id,
        ];
        ::core::fmt::Formatter::debug_struct_fields_finish(f, "Call", names, values)
    }
}
#[automatically_derived]
impl ::core::clone::Clone for Call {
    #[inline]
    fn clone(&self) -> Call {
        Call {
            id: ::core::clone::Clone::clone(&self.id),
            participants: ::core::clone::Clone::clone(&self.participants),
            chat_history: ::core::clone::Clone::clone(&self.chat_history),
            created_at: ::core::clone::Clone::clone(&self.created_at),
            default_role: ::core::clone::Clone::clone(&self.default_role),
            creator_id: ::core::clone::Clone::clone(&self.creator_id),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for Call {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "Call",
                false as usize + 1 + 1 + 1 + 1 + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "id",
                &self.id,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "participants",
                &self.participants,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "chat_history",
                &self.chat_history,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "created_at",
                &self.created_at,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "default_role",
                &self.default_role,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "creator_id",
                &self.creator_id,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for Call {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __field4,
                __field5,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        4u64 => _serde::__private::Ok(__Field::__field4),
                        5u64 => _serde::__private::Ok(__Field::__field5),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "id" => _serde::__private::Ok(__Field::__field0),
                        "participants" => _serde::__private::Ok(__Field::__field1),
                        "chat_history" => _serde::__private::Ok(__Field::__field2),
                        "created_at" => _serde::__private::Ok(__Field::__field3),
                        "default_role" => _serde::__private::Ok(__Field::__field4),
                        "creator_id" => _serde::__private::Ok(__Field::__field5),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"id" => _serde::__private::Ok(__Field::__field0),
                        b"participants" => _serde::__private::Ok(__Field::__field1),
                        b"chat_history" => _serde::__private::Ok(__Field::__field2),
                        b"created_at" => _serde::__private::Ok(__Field::__field3),
                        b"default_role" => _serde::__private::Ok(__Field::__field4),
                        b"creator_id" => _serde::__private::Ok(__Field::__field5),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<Call>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = Call;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "struct Call")
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct Call with 6 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        HashMap<String, Participant>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct Call with 6 elements",
                                ),
                            );
                        }
                    };
                    let __field2 = match _serde::de::SeqAccess::next_element::<
                        Vec<ChatMessage>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct Call with 6 elements",
                                ),
                            );
                        }
                    };
                    let __field3 = match _serde::de::SeqAccess::next_element::<
                        u64,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct Call with 6 elements",
                                ),
                            );
                        }
                    };
                    let __field4 = match _serde::de::SeqAccess::next_element::<
                        Role,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    4usize,
                                    &"struct Call with 6 elements",
                                ),
                            );
                        }
                    };
                    let __field5 = match _serde::de::SeqAccess::next_element::<
                        Option<String>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    5usize,
                                    &"struct Call with 6 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(Call {
                        id: __field0,
                        participants: __field1,
                        chat_history: __field2,
                        created_at: __field3,
                        default_role: __field4,
                        creator_id: __field5,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<
                        HashMap<String, Participant>,
                    > = _serde::__private::None;
                    let mut __field2: _serde::__private::Option<Vec<ChatMessage>> = _serde::__private::None;
                    let mut __field3: _serde::__private::Option<u64> = _serde::__private::None;
                    let mut __field4: _serde::__private::Option<Role> = _serde::__private::None;
                    let mut __field5: _serde::__private::Option<Option<String>> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "participants",
                                        ),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        HashMap<String, Participant>,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private::Option::is_some(&__field2) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "chat_history",
                                        ),
                                    );
                                }
                                __field2 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        Vec<ChatMessage>,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field3 => {
                                if _serde::__private::Option::is_some(&__field3) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "created_at",
                                        ),
                                    );
                                }
                                __field3 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                );
                            }
                            __Field::__field4 => {
                                if _serde::__private::Option::is_some(&__field4) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "default_role",
                                        ),
                                    );
                                }
                                __field4 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<Role>(&mut __map)?,
                                );
                            }
                            __Field::__field5 => {
                                if _serde::__private::Option::is_some(&__field5) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "creator_id",
                                        ),
                                    );
                                }
                                __field5 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        Option<String>,
                                    >(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("id")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("participants")?
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private::Some(__field2) => __field2,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("chat_history")?
                        }
                    };
                    let __field3 = match __field3 {
                        _serde::__private::Some(__field3) => __field3,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("created_at")?
                        }
                    };
                    let __field4 = match __field4 {
                        _serde::__private::Some(__field4) => __field4,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("default_role")?
                        }
                    };
                    let __field5 = match __field5 {
                        _serde::__private::Some(__field5) => __field5,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("creator_id")?
                        }
                    };
                    _serde::__private::Ok(Call {
                        id: __field0,
                        participants: __field1,
                        chat_history: __field2,
                        created_at: __field3,
                        default_role: __field4,
                        creator_id: __field5,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &[
                "id",
                "participants",
                "chat_history",
                "created_at",
                "default_role",
                "creator_id",
            ];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "Call",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<Call>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
struct Participant {
    id: String,
    display_name: String,
    role: Role,
    connection_type: ConnectionType,
    is_muted: bool,
}
#[automatically_derived]
impl ::core::fmt::Debug for Participant {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field5_finish(
            f,
            "Participant",
            "id",
            &self.id,
            "display_name",
            &self.display_name,
            "role",
            &self.role,
            "connection_type",
            &self.connection_type,
            "is_muted",
            &&self.is_muted,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for Participant {
    #[inline]
    fn clone(&self) -> Participant {
        Participant {
            id: ::core::clone::Clone::clone(&self.id),
            display_name: ::core::clone::Clone::clone(&self.display_name),
            role: ::core::clone::Clone::clone(&self.role),
            connection_type: ::core::clone::Clone::clone(&self.connection_type),
            is_muted: ::core::clone::Clone::clone(&self.is_muted),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for Participant {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "Participant",
                false as usize + 1 + 1 + 1 + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "id",
                &self.id,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "display_name",
                &self.display_name,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "role",
                &self.role,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "connection_type",
                &self.connection_type,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "is_muted",
                &self.is_muted,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for Participant {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __field4,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        4u64 => _serde::__private::Ok(__Field::__field4),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "id" => _serde::__private::Ok(__Field::__field0),
                        "display_name" => _serde::__private::Ok(__Field::__field1),
                        "role" => _serde::__private::Ok(__Field::__field2),
                        "connection_type" => _serde::__private::Ok(__Field::__field3),
                        "is_muted" => _serde::__private::Ok(__Field::__field4),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"id" => _serde::__private::Ok(__Field::__field0),
                        b"display_name" => _serde::__private::Ok(__Field::__field1),
                        b"role" => _serde::__private::Ok(__Field::__field2),
                        b"connection_type" => _serde::__private::Ok(__Field::__field3),
                        b"is_muted" => _serde::__private::Ok(__Field::__field4),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<Participant>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = Participant;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct Participant",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct Participant with 5 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct Participant with 5 elements",
                                ),
                            );
                        }
                    };
                    let __field2 = match _serde::de::SeqAccess::next_element::<
                        Role,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct Participant with 5 elements",
                                ),
                            );
                        }
                    };
                    let __field3 = match _serde::de::SeqAccess::next_element::<
                        ConnectionType,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct Participant with 5 elements",
                                ),
                            );
                        }
                    };
                    let __field4 = match _serde::de::SeqAccess::next_element::<
                        bool,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    4usize,
                                    &"struct Participant with 5 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(Participant {
                        id: __field0,
                        display_name: __field1,
                        role: __field2,
                        connection_type: __field3,
                        is_muted: __field4,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field2: _serde::__private::Option<Role> = _serde::__private::None;
                    let mut __field3: _serde::__private::Option<ConnectionType> = _serde::__private::None;
                    let mut __field4: _serde::__private::Option<bool> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "display_name",
                                        ),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private::Option::is_some(&__field2) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("role"),
                                    );
                                }
                                __field2 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<Role>(&mut __map)?,
                                );
                            }
                            __Field::__field3 => {
                                if _serde::__private::Option::is_some(&__field3) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "connection_type",
                                        ),
                                    );
                                }
                                __field3 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        ConnectionType,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field4 => {
                                if _serde::__private::Option::is_some(&__field4) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "is_muted",
                                        ),
                                    );
                                }
                                __field4 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("id")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("display_name")?
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private::Some(__field2) => __field2,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("role")?
                        }
                    };
                    let __field3 = match __field3 {
                        _serde::__private::Some(__field3) => __field3,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("connection_type")?
                        }
                    };
                    let __field4 = match __field4 {
                        _serde::__private::Some(__field4) => __field4,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("is_muted")?
                        }
                    };
                    _serde::__private::Ok(Participant {
                        id: __field0,
                        display_name: __field1,
                        role: __field2,
                        connection_type: __field3,
                        is_muted: __field4,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &[
                "id",
                "display_name",
                "role",
                "connection_type",
                "is_muted",
            ];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "Participant",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<Participant>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_init_cabi<T: Guest>(arg0: *mut u8, arg1: usize) {
    let len0 = arg1;
    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
    T::init(_rt::string_lift(bytes0));
}
pub trait Guest {
    fn init(our: _rt::String);
}
#[doc(hidden)]
pub(crate) use __export_world_voice_sys_v0_cabi;
#[allow(dead_code, clippy::all)]
pub mod hyperware {
    pub mod process {
        #[allow(dead_code, clippy::all)]
        pub mod standard {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            ///   
            /// System Types
            ///   
            /// JSON is passed over Wasm boundary as a string.
            pub type Json = _rt::String;
            /// In types passed from kernel, node-id will be a valid Kimap entry.
            pub type NodeId = _rt::String;
            /// Context, like a message body, is a protocol-defined serialized byte
            /// array. It is used when building a Request to save information that
            /// will not be part of a Response, in order to more easily handle
            /// ("contextualize") that Response.
            pub type Context = _rt::Vec<u8>;
            pub struct ProcessId {
                pub process_name: _rt::String,
                pub package_name: _rt::String,
                pub publisher_node: NodeId,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ProcessId {
                #[inline]
                fn clone(&self) -> ProcessId {
                    ProcessId {
                        process_name: ::core::clone::Clone::clone(&self.process_name),
                        package_name: ::core::clone::Clone::clone(&self.package_name),
                        publisher_node: ::core::clone::Clone::clone(&self.publisher_node),
                    }
                }
            }
            impl From<ProcessId> for Vec<u8> {
                fn from(value: ProcessId) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a ProcessId> for Vec<u8> {
                fn from(value: &'a ProcessId) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for ProcessId {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for ProcessId {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ProcessId {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "process_name" => _serde::__private::Ok(__Field::__field0),
                                    "package_name" => _serde::__private::Ok(__Field::__field1),
                                    "publisher_node" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"process_name" => _serde::__private::Ok(__Field::__field0),
                                    b"package_name" => _serde::__private::Ok(__Field::__field1),
                                    b"publisher_node" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<ProcessId>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ProcessId;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ProcessId",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ProcessId with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ProcessId with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    NodeId,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct ProcessId with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(ProcessId {
                                    process_name: __field0,
                                    package_name: __field1,
                                    publisher_node: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<NodeId> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "process_name",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "package_name",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "publisher_node",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<NodeId>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("process_name")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("package_name")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("publisher_node")?
                                    }
                                };
                                _serde::__private::Ok(ProcessId {
                                    process_name: __field0,
                                    package_name: __field1,
                                    publisher_node: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "process_name",
                            "package_name",
                            "publisher_node",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ProcessId",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<ProcessId>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ProcessId {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "ProcessId",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "process_name",
                            &self.process_name,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "package_name",
                            &self.package_name,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "publisher_node",
                            &self.publisher_node,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for ProcessId {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ProcessId")
                        .field("process-name", &self.process_name)
                        .field("package-name", &self.package_name)
                        .field("publisher-node", &self.publisher_node)
                        .finish()
                }
            }
            pub struct PackageId {
                pub package_name: _rt::String,
                pub publisher_node: NodeId,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for PackageId {
                #[inline]
                fn clone(&self) -> PackageId {
                    PackageId {
                        package_name: ::core::clone::Clone::clone(&self.package_name),
                        publisher_node: ::core::clone::Clone::clone(&self.publisher_node),
                    }
                }
            }
            impl From<PackageId> for Vec<u8> {
                fn from(value: PackageId) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a PackageId> for Vec<u8> {
                fn from(value: &'a PackageId) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for PackageId {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for PackageId {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for PackageId {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "package_name" => _serde::__private::Ok(__Field::__field0),
                                    "publisher_node" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"package_name" => _serde::__private::Ok(__Field::__field0),
                                    b"publisher_node" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<PackageId>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = PackageId;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct PackageId",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct PackageId with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    NodeId,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct PackageId with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(PackageId {
                                    package_name: __field0,
                                    publisher_node: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<NodeId> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "package_name",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "publisher_node",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<NodeId>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("package_name")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("publisher_node")?
                                    }
                                };
                                _serde::__private::Ok(PackageId {
                                    package_name: __field0,
                                    publisher_node: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "package_name",
                            "publisher_node",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "PackageId",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<PackageId>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for PackageId {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "PackageId",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "package_name",
                            &self.package_name,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "publisher_node",
                            &self.publisher_node,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for PackageId {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("PackageId")
                        .field("package-name", &self.package_name)
                        .field("publisher-node", &self.publisher_node)
                        .finish()
                }
            }
            pub struct Address {
                pub node: NodeId,
                pub process: ProcessId,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Address {
                #[inline]
                fn clone(&self) -> Address {
                    Address {
                        node: ::core::clone::Clone::clone(&self.node),
                        process: ::core::clone::Clone::clone(&self.process),
                    }
                }
            }
            impl From<Address> for Vec<u8> {
                fn from(value: Address) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a Address> for Vec<u8> {
                fn from(value: &'a Address) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for Address {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for Address {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Address {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "node" => _serde::__private::Ok(__Field::__field0),
                                    "process" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"node" => _serde::__private::Ok(__Field::__field0),
                                    b"process" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Address>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Address;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct Address",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    NodeId,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct Address with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    ProcessId,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct Address with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(Address {
                                    node: __field0,
                                    process: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<NodeId> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<ProcessId> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("node"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<NodeId>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "process",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<ProcessId>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("node")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("process")?
                                    }
                                };
                                _serde::__private::Ok(Address {
                                    node: __field0,
                                    process: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["node", "process"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "Address",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Address>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Address {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "Address",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "node",
                            &self.node,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "process",
                            &self.process,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for Address {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Address")
                        .field("node", &self.node)
                        .field("process", &self.process)
                        .finish()
                }
            }
            pub struct LazyLoadBlob {
                pub mime: Option<_rt::String>,
                pub bytes: _rt::Vec<u8>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for LazyLoadBlob {
                #[inline]
                fn clone(&self) -> LazyLoadBlob {
                    LazyLoadBlob {
                        mime: ::core::clone::Clone::clone(&self.mime),
                        bytes: ::core::clone::Clone::clone(&self.bytes),
                    }
                }
            }
            impl From<LazyLoadBlob> for Vec<u8> {
                fn from(value: LazyLoadBlob) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a LazyLoadBlob> for Vec<u8> {
                fn from(value: &'a LazyLoadBlob) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for LazyLoadBlob {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for LazyLoadBlob {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for LazyLoadBlob {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "mime" => _serde::__private::Ok(__Field::__field0),
                                    "bytes" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"mime" => _serde::__private::Ok(__Field::__field0),
                                    b"bytes" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<LazyLoadBlob>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = LazyLoadBlob;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct LazyLoadBlob",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    Option<_rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct LazyLoadBlob with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::Vec<u8>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct LazyLoadBlob with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(LazyLoadBlob {
                                    mime: __field0,
                                    bytes: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    Option<_rt::String>,
                                > = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::Vec<u8>> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("mime"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<_rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("bytes"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::Vec<u8>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("mime")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("bytes")?
                                    }
                                };
                                _serde::__private::Ok(LazyLoadBlob {
                                    mime: __field0,
                                    bytes: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["mime", "bytes"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "LazyLoadBlob",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<LazyLoadBlob>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for LazyLoadBlob {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "LazyLoadBlob",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "mime",
                            &self.mime,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "bytes",
                            &self.bytes,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for LazyLoadBlob {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("LazyLoadBlob")
                        .field("mime", &self.mime)
                        .field("bytes", &self.bytes)
                        .finish()
                }
            }
            pub struct Capability {
                pub issuer: Address,
                pub params: Json,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Capability {
                #[inline]
                fn clone(&self) -> Capability {
                    Capability {
                        issuer: ::core::clone::Clone::clone(&self.issuer),
                        params: ::core::clone::Clone::clone(&self.params),
                    }
                }
            }
            impl From<Capability> for Vec<u8> {
                fn from(value: Capability) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a Capability> for Vec<u8> {
                fn from(value: &'a Capability) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for Capability {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for Capability {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Capability {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "issuer" => _serde::__private::Ok(__Field::__field0),
                                    "params" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"issuer" => _serde::__private::Ok(__Field::__field0),
                                    b"params" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Capability>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Capability;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct Capability",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    Address,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct Capability with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Json,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct Capability with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(Capability {
                                    issuer: __field0,
                                    params: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<Address> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Json> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("issuer"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Address>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Json>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("issuer")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("params")?
                                    }
                                };
                                _serde::__private::Ok(Capability {
                                    issuer: __field0,
                                    params: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["issuer", "params"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "Capability",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Capability>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Capability {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "Capability",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "issuer",
                            &self.issuer,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "params",
                            &self.params,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for Capability {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Capability")
                        .field("issuer", &self.issuer)
                        .field("params", &self.params)
                        .finish()
                }
            }
            pub struct Request {
                /// set in order to inherit lazy-load-blob from parent message, and if
                /// expects-response is none, direct response to source of parent.
                /// also carries forward certain aspects of parent message in kernel,
                /// see documentation for formal spec and examples:
                /// https://docs.rs/hyperware_process_lib/latest/hyperware_process_lib/struct.Request.html
                pub inherit: bool,
                /// if some, request expects a response in the given number of seconds
                pub expects_response: Option<u64>,
                pub body: _rt::Vec<u8>,
                pub metadata: Option<Json>,
                pub capabilities: _rt::Vec<Capability>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Request {
                #[inline]
                fn clone(&self) -> Request {
                    Request {
                        inherit: ::core::clone::Clone::clone(&self.inherit),
                        expects_response: ::core::clone::Clone::clone(
                            &self.expects_response,
                        ),
                        body: ::core::clone::Clone::clone(&self.body),
                        metadata: ::core::clone::Clone::clone(&self.metadata),
                        capabilities: ::core::clone::Clone::clone(&self.capabilities),
                    }
                }
            }
            impl From<Request> for Vec<u8> {
                fn from(value: Request) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a Request> for Vec<u8> {
                fn from(value: &'a Request) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for Request {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for Request {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Request {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "inherit" => _serde::__private::Ok(__Field::__field0),
                                    "expects_response" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    "body" => _serde::__private::Ok(__Field::__field2),
                                    "metadata" => _serde::__private::Ok(__Field::__field3),
                                    "capabilities" => _serde::__private::Ok(__Field::__field4),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"inherit" => _serde::__private::Ok(__Field::__field0),
                                    b"expects_response" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    b"body" => _serde::__private::Ok(__Field::__field2),
                                    b"metadata" => _serde::__private::Ok(__Field::__field3),
                                    b"capabilities" => _serde::__private::Ok(__Field::__field4),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Request>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Request;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct Request",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    bool,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct Request with 5 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Option<u64>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct Request with 5 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    _rt::Vec<u8>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct Request with 5 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    Option<Json>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct Request with 5 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field4 = match _serde::de::SeqAccess::next_element::<
                                    _rt::Vec<Capability>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                4usize,
                                                &"struct Request with 5 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(Request {
                                    inherit: __field0,
                                    expects_response: __field1,
                                    body: __field2,
                                    metadata: __field3,
                                    capabilities: __field4,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Option<u64>> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<_rt::Vec<u8>> = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<Option<Json>> = _serde::__private::None;
                                let mut __field4: _serde::__private::Option<
                                    _rt::Vec<Capability>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "inherit",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "expects_response",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<u64>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("body"),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::Vec<u8>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "metadata",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<Json>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field4 => {
                                            if _serde::__private::Option::is_some(&__field4) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "capabilities",
                                                    ),
                                                );
                                            }
                                            __field4 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::Vec<Capability>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("inherit")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("expects_response")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("body")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("metadata")?
                                    }
                                };
                                let __field4 = match __field4 {
                                    _serde::__private::Some(__field4) => __field4,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("capabilities")?
                                    }
                                };
                                _serde::__private::Ok(Request {
                                    inherit: __field0,
                                    expects_response: __field1,
                                    body: __field2,
                                    metadata: __field3,
                                    capabilities: __field4,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "inherit",
                            "expects_response",
                            "body",
                            "metadata",
                            "capabilities",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "Request",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Request>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Request {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "Request",
                            false as usize + 1 + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "inherit",
                            &self.inherit,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "expects_response",
                            &self.expects_response,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "body",
                            &self.body,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "metadata",
                            &self.metadata,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "capabilities",
                            &self.capabilities,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for Request {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Request")
                        .field("inherit", &self.inherit)
                        .field("expects-response", &self.expects_response)
                        .field("body", &self.body)
                        .field("metadata", &self.metadata)
                        .field("capabilities", &self.capabilities)
                        .finish()
                }
            }
            pub struct Response {
                pub inherit: bool,
                pub body: _rt::Vec<u8>,
                pub metadata: Option<Json>,
                pub capabilities: _rt::Vec<Capability>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Response {
                #[inline]
                fn clone(&self) -> Response {
                    Response {
                        inherit: ::core::clone::Clone::clone(&self.inherit),
                        body: ::core::clone::Clone::clone(&self.body),
                        metadata: ::core::clone::Clone::clone(&self.metadata),
                        capabilities: ::core::clone::Clone::clone(&self.capabilities),
                    }
                }
            }
            impl From<Response> for Vec<u8> {
                fn from(value: Response) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a Response> for Vec<u8> {
                fn from(value: &'a Response) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for Response {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for Response {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Response {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "inherit" => _serde::__private::Ok(__Field::__field0),
                                    "body" => _serde::__private::Ok(__Field::__field1),
                                    "metadata" => _serde::__private::Ok(__Field::__field2),
                                    "capabilities" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"inherit" => _serde::__private::Ok(__Field::__field0),
                                    b"body" => _serde::__private::Ok(__Field::__field1),
                                    b"metadata" => _serde::__private::Ok(__Field::__field2),
                                    b"capabilities" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Response>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Response;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct Response",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    bool,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct Response with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::Vec<u8>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct Response with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Option<Json>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct Response with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    _rt::Vec<Capability>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct Response with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(Response {
                                    inherit: __field0,
                                    body: __field1,
                                    metadata: __field2,
                                    capabilities: __field3,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::Vec<u8>> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<Option<Json>> = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<
                                    _rt::Vec<Capability>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "inherit",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("body"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::Vec<u8>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "metadata",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<Json>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "capabilities",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::Vec<Capability>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("inherit")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("body")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("metadata")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("capabilities")?
                                    }
                                };
                                _serde::__private::Ok(Response {
                                    inherit: __field0,
                                    body: __field1,
                                    metadata: __field2,
                                    capabilities: __field3,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "inherit",
                            "body",
                            "metadata",
                            "capabilities",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "Response",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Response>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Response {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "Response",
                            false as usize + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "inherit",
                            &self.inherit,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "body",
                            &self.body,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "metadata",
                            &self.metadata,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "capabilities",
                            &self.capabilities,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for Response {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Response")
                        .field("inherit", &self.inherit)
                        .field("body", &self.body)
                        .field("metadata", &self.metadata)
                        .field("capabilities", &self.capabilities)
                        .finish()
                }
            }
            /// A message can be a request or a response. Within a response, there is
            /// a result which surfaces any error that happened because of a request.
            /// A successful response will contain the context of the request it
            /// matches, if any was set.
            pub enum Message {
                Request(Request),
                Response((Response, Option<Context>)),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Message {
                #[inline]
                fn clone(&self) -> Message {
                    match self {
                        Message::Request(__self_0) => {
                            Message::Request(::core::clone::Clone::clone(__self_0))
                        }
                        Message::Response(__self_0) => {
                            Message::Response(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            impl From<Message> for Vec<u8> {
                fn from(value: Message) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a Message> for Vec<u8> {
                fn from(value: &'a Message) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for Message {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for Message {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Message {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 2",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "Request" => _serde::__private::Ok(__Field::__field0),
                                    "Response" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"Request" => _serde::__private::Ok(__Field::__field0),
                                    b"Response" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Message>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Message;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum Message",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                Request,
                                            >(__variant),
                                            Message::Request,
                                        )
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                (Response, Option<Context>),
                                            >(__variant),
                                            Message::Response,
                                        )
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "Request",
                            "Response",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "Message",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Message>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Message {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            Message::Request(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "Message",
                                    0u32,
                                    "Request",
                                    __field0,
                                )
                            }
                            Message::Response(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "Message",
                                    1u32,
                                    "Response",
                                    __field0,
                                )
                            }
                        }
                    }
                }
            };
            impl ::core::fmt::Debug for Message {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        Message::Request(e) => {
                            f.debug_tuple("Message::Request").field(e).finish()
                        }
                        Message::Response(e) => {
                            f.debug_tuple("Message::Response").field(e).finish()
                        }
                    }
                }
            }
            /// On-exit is a setting that determines what happens when a process
            /// panics, completes, or otherwise "ends".
            /// NOTE: requests will always have expects-response set to false by kernel.
            pub enum OnExit {
                None,
                Restart,
                Requests(_rt::Vec<(Address, Request, Option<LazyLoadBlob>)>),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for OnExit {
                #[inline]
                fn clone(&self) -> OnExit {
                    match self {
                        OnExit::None => OnExit::None,
                        OnExit::Restart => OnExit::Restart,
                        OnExit::Requests(__self_0) => {
                            OnExit::Requests(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            impl From<OnExit> for Vec<u8> {
                fn from(value: OnExit) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a OnExit> for Vec<u8> {
                fn from(value: &'a OnExit) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for OnExit {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for OnExit {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for OnExit {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 3",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "None" => _serde::__private::Ok(__Field::__field0),
                                    "Restart" => _serde::__private::Ok(__Field::__field1),
                                    "Requests" => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"None" => _serde::__private::Ok(__Field::__field0),
                                    b"Restart" => _serde::__private::Ok(__Field::__field1),
                                    b"Requests" => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<OnExit>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = OnExit;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum OnExit",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(OnExit::None)
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(OnExit::Restart)
                                    }
                                    (__Field::__field2, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                _rt::Vec<(Address, Request, Option<LazyLoadBlob>)>,
                                            >(__variant),
                                            OnExit::Requests,
                                        )
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "None",
                            "Restart",
                            "Requests",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "OnExit",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<OnExit>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for OnExit {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            OnExit::None => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "OnExit",
                                    0u32,
                                    "None",
                                )
                            }
                            OnExit::Restart => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "OnExit",
                                    1u32,
                                    "Restart",
                                )
                            }
                            OnExit::Requests(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "OnExit",
                                    2u32,
                                    "Requests",
                                    __field0,
                                )
                            }
                        }
                    }
                }
            };
            impl ::core::fmt::Debug for OnExit {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        OnExit::None => f.debug_tuple("OnExit::None").finish(),
                        OnExit::Restart => f.debug_tuple("OnExit::Restart").finish(),
                        OnExit::Requests(e) => {
                            f.debug_tuple("OnExit::Requests").field(e).finish()
                        }
                    }
                }
            }
            #[repr(u8)]
            pub enum SendErrorKind {
                Offline,
                Timeout,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for SendErrorKind {
                #[inline]
                fn clone(&self) -> SendErrorKind {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for SendErrorKind {}
            #[automatically_derived]
            impl ::core::cmp::Eq for SendErrorKind {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for SendErrorKind {
                #[inline]
                fn cmp(&self, other: &SendErrorKind) -> ::core::cmp::Ordering {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for SendErrorKind {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for SendErrorKind {
                #[inline]
                fn eq(&self, other: &SendErrorKind) -> bool {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for SendErrorKind {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &SendErrorKind,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
                }
            }
            impl From<SendErrorKind> for Vec<u8> {
                fn from(value: SendErrorKind) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a SendErrorKind> for Vec<u8> {
                fn from(value: &'a SendErrorKind) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for SendErrorKind {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for SendErrorKind {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for SendErrorKind {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 2",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "Offline" => _serde::__private::Ok(__Field::__field0),
                                    "Timeout" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"Offline" => _serde::__private::Ok(__Field::__field0),
                                    b"Timeout" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<SendErrorKind>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = SendErrorKind;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum SendErrorKind",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(SendErrorKind::Offline)
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(SendErrorKind::Timeout)
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "Offline",
                            "Timeout",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "SendErrorKind",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<SendErrorKind>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for SendErrorKind {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            SendErrorKind::Offline => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "SendErrorKind",
                                    0u32,
                                    "Offline",
                                )
                            }
                            SendErrorKind::Timeout => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "SendErrorKind",
                                    1u32,
                                    "Timeout",
                                )
                            }
                        }
                    }
                }
            };
            impl ::core::fmt::Debug for SendErrorKind {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        SendErrorKind::Offline => {
                            f.debug_tuple("SendErrorKind::Offline").finish()
                        }
                        SendErrorKind::Timeout => {
                            f.debug_tuple("SendErrorKind::Timeout").finish()
                        }
                    }
                }
            }
            impl SendErrorKind {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> SendErrorKind {
                    if !true {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => SendErrorKind::Offline,
                        1 => SendErrorKind::Timeout,
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("invalid enum discriminant"),
                            );
                        }
                    }
                }
            }
            /// Send errors come from trying to send a message to another process,
            /// either locally or on another node.
            /// A message can fail by timing out, or by the node being entirely
            /// unreachable (offline or can't be found in PKI). In either case,
            /// the message is not delivered and the process that sent it receives
            /// that message back along with any assigned context and/or lazy-load-blob,
            /// and is free to handle it as it sees fit.
            /// In the local case, only timeout errors are possible and also cover the case
            /// in which a process is not running or does not exist.
            pub struct SendError {
                pub kind: SendErrorKind,
                pub target: Address,
                pub message: Message,
                pub lazy_load_blob: Option<LazyLoadBlob>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for SendError {
                #[inline]
                fn clone(&self) -> SendError {
                    SendError {
                        kind: ::core::clone::Clone::clone(&self.kind),
                        target: ::core::clone::Clone::clone(&self.target),
                        message: ::core::clone::Clone::clone(&self.message),
                        lazy_load_blob: ::core::clone::Clone::clone(&self.lazy_load_blob),
                    }
                }
            }
            impl From<SendError> for Vec<u8> {
                fn from(value: SendError) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a SendError> for Vec<u8> {
                fn from(value: &'a SendError) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for SendError {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for SendError {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for SendError {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "kind" => _serde::__private::Ok(__Field::__field0),
                                    "target" => _serde::__private::Ok(__Field::__field1),
                                    "message" => _serde::__private::Ok(__Field::__field2),
                                    "lazy_load_blob" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"kind" => _serde::__private::Ok(__Field::__field0),
                                    b"target" => _serde::__private::Ok(__Field::__field1),
                                    b"message" => _serde::__private::Ok(__Field::__field2),
                                    b"lazy_load_blob" => {
                                        _serde::__private::Ok(__Field::__field3)
                                    }
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<SendError>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = SendError;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct SendError",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    SendErrorKind,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct SendError with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Address,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct SendError with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Message,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct SendError with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    Option<LazyLoadBlob>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct SendError with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(SendError {
                                    kind: __field0,
                                    target: __field1,
                                    message: __field2,
                                    lazy_load_blob: __field3,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    SendErrorKind,
                                > = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Address> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<Message> = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<
                                    Option<LazyLoadBlob>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("kind"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    SendErrorKind,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Address>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "message",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Message>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "lazy_load_blob",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<LazyLoadBlob>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("kind")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("message")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("lazy_load_blob")?
                                    }
                                };
                                _serde::__private::Ok(SendError {
                                    kind: __field0,
                                    target: __field1,
                                    message: __field2,
                                    lazy_load_blob: __field3,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "kind",
                            "target",
                            "message",
                            "lazy_load_blob",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "SendError",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<SendError>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for SendError {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "SendError",
                            false as usize + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "kind",
                            &self.kind,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "message",
                            &self.message,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "lazy_load_blob",
                            &self.lazy_load_blob,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for SendError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("SendError")
                        .field("kind", &self.kind)
                        .field("target", &self.target)
                        .field("message", &self.message)
                        .field("lazy-load-blob", &self.lazy_load_blob)
                        .finish()
                }
            }
            impl ::core::fmt::Display for SendError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.write_fmt(format_args!("{0:?}", self))
                }
            }
            impl std::error::Error for SendError {}
            #[repr(u8)]
            pub enum SpawnError {
                NameTaken,
                NoFileAtPath,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for SpawnError {
                #[inline]
                fn clone(&self) -> SpawnError {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for SpawnError {}
            #[automatically_derived]
            impl ::core::cmp::Eq for SpawnError {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for SpawnError {
                #[inline]
                fn cmp(&self, other: &SpawnError) -> ::core::cmp::Ordering {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for SpawnError {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for SpawnError {
                #[inline]
                fn eq(&self, other: &SpawnError) -> bool {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for SpawnError {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &SpawnError,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
                }
            }
            impl From<SpawnError> for Vec<u8> {
                fn from(value: SpawnError) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a SpawnError> for Vec<u8> {
                fn from(value: &'a SpawnError) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for SpawnError {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for SpawnError {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for SpawnError {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 2",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "NameTaken" => _serde::__private::Ok(__Field::__field0),
                                    "NoFileAtPath" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"NameTaken" => _serde::__private::Ok(__Field::__field0),
                                    b"NoFileAtPath" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<SpawnError>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = SpawnError;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum SpawnError",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(SpawnError::NameTaken)
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(SpawnError::NoFileAtPath)
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "NameTaken",
                            "NoFileAtPath",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "SpawnError",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<SpawnError>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for SpawnError {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            SpawnError::NameTaken => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "SpawnError",
                                    0u32,
                                    "NameTaken",
                                )
                            }
                            SpawnError::NoFileAtPath => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "SpawnError",
                                    1u32,
                                    "NoFileAtPath",
                                )
                            }
                        }
                    }
                }
            };
            impl SpawnError {
                pub fn name(&self) -> &'static str {
                    match self {
                        SpawnError::NameTaken => "name-taken",
                        SpawnError::NoFileAtPath => "no-file-at-path",
                    }
                }
                pub fn message(&self) -> &'static str {
                    match self {
                        SpawnError::NameTaken => "",
                        SpawnError::NoFileAtPath => "",
                    }
                }
            }
            impl ::core::fmt::Debug for SpawnError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("SpawnError")
                        .field("code", &(*self as i32))
                        .field("name", &self.name())
                        .field("message", &self.message())
                        .finish()
                }
            }
            impl ::core::fmt::Display for SpawnError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.write_fmt(
                        format_args!("{0} (error {1})", self.name(), *self as i32),
                    )
                }
            }
            impl std::error::Error for SpawnError {}
            impl SpawnError {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> SpawnError {
                    if !true {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => SpawnError::NameTaken,
                        1 => SpawnError::NoFileAtPath,
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("invalid enum discriminant"),
                            );
                        }
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            ///   
            /// System Utils
            ///   
            /// Prints to the terminal at a given verbosity level.
            /// Higher verbosity levels print more information.
            /// Level 0 is always printed -- use sparingly.
            pub fn print_to_terminal(verbosity: u8, message: &str) {
                unsafe {
                    let vec0 = message;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32, _: *mut u8, _: usize) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(_rt::as_i32(&verbosity), ptr0.cast_mut(), len0);
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Returns the address of the process.
            pub fn our() -> Address {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 32]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 32]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0);
                    let l1 = *ptr0.add(0).cast::<*mut u8>();
                    let l2 = *ptr0.add(4).cast::<usize>();
                    let len3 = l2;
                    let bytes3 = _rt::Vec::from_raw_parts(l1.cast(), len3, len3);
                    let l4 = *ptr0.add(8).cast::<*mut u8>();
                    let l5 = *ptr0.add(12).cast::<usize>();
                    let len6 = l5;
                    let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                    let l7 = *ptr0.add(16).cast::<*mut u8>();
                    let l8 = *ptr0.add(20).cast::<usize>();
                    let len9 = l8;
                    let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                    let l10 = *ptr0.add(24).cast::<*mut u8>();
                    let l11 = *ptr0.add(28).cast::<usize>();
                    let len12 = l11;
                    let bytes12 = _rt::Vec::from_raw_parts(l10.cast(), len12, len12);
                    Address {
                        node: _rt::string_lift(bytes3),
                        process: ProcessId {
                            process_name: _rt::string_lift(bytes6),
                            package_name: _rt::string_lift(bytes9),
                            publisher_node: _rt::string_lift(bytes12),
                        },
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            ///   
            /// Process Management
            ///   
            pub fn get_on_exit() -> OnExit {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0);
                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                    let v53 = match l1 {
                        0 => OnExit::None,
                        1 => OnExit::Restart,
                        n => {
                            if true {
                                match (&n, &2) {
                                    (left_val, right_val) => {
                                        if !(*left_val == *right_val) {
                                            let kind = ::core::panicking::AssertKind::Eq;
                                            ::core::panicking::assert_failed(
                                                kind,
                                                &*left_val,
                                                &*right_val,
                                                ::core::option::Option::Some(
                                                    format_args!("invalid enum discriminant"),
                                                ),
                                            );
                                        }
                                    }
                                };
                            }
                            let e53 = {
                                let l2 = *ptr0.add(4).cast::<*mut u8>();
                                let l3 = *ptr0.add(8).cast::<usize>();
                                let base52 = l2;
                                let len52 = l3;
                                let mut result52 = _rt::Vec::with_capacity(len52);
                                for i in 0..len52 {
                                    let base = base52.add(i * 112);
                                    let e52 = {
                                        let l4 = *base.add(0).cast::<*mut u8>();
                                        let l5 = *base.add(4).cast::<usize>();
                                        let len6 = l5;
                                        let bytes6 = _rt::Vec::from_raw_parts(
                                            l4.cast(),
                                            len6,
                                            len6,
                                        );
                                        let l7 = *base.add(8).cast::<*mut u8>();
                                        let l8 = *base.add(12).cast::<usize>();
                                        let len9 = l8;
                                        let bytes9 = _rt::Vec::from_raw_parts(
                                            l7.cast(),
                                            len9,
                                            len9,
                                        );
                                        let l10 = *base.add(16).cast::<*mut u8>();
                                        let l11 = *base.add(20).cast::<usize>();
                                        let len12 = l11;
                                        let bytes12 = _rt::Vec::from_raw_parts(
                                            l10.cast(),
                                            len12,
                                            len12,
                                        );
                                        let l13 = *base.add(24).cast::<*mut u8>();
                                        let l14 = *base.add(28).cast::<usize>();
                                        let len15 = l14;
                                        let bytes15 = _rt::Vec::from_raw_parts(
                                            l13.cast(),
                                            len15,
                                            len15,
                                        );
                                        let l16 = i32::from(*base.add(32).cast::<u8>());
                                        let l17 = i32::from(*base.add(40).cast::<u8>());
                                        let l19 = *base.add(56).cast::<*mut u8>();
                                        let l20 = *base.add(60).cast::<usize>();
                                        let len21 = l20;
                                        let l22 = i32::from(*base.add(64).cast::<u8>());
                                        let l26 = *base.add(76).cast::<*mut u8>();
                                        let l27 = *base.add(80).cast::<usize>();
                                        let base43 = l26;
                                        let len43 = l27;
                                        let mut result43 = _rt::Vec::with_capacity(len43);
                                        for i in 0..len43 {
                                            let base = base43.add(i * 40);
                                            let e43 = {
                                                let l28 = *base.add(0).cast::<*mut u8>();
                                                let l29 = *base.add(4).cast::<usize>();
                                                let len30 = l29;
                                                let bytes30 = _rt::Vec::from_raw_parts(
                                                    l28.cast(),
                                                    len30,
                                                    len30,
                                                );
                                                let l31 = *base.add(8).cast::<*mut u8>();
                                                let l32 = *base.add(12).cast::<usize>();
                                                let len33 = l32;
                                                let bytes33 = _rt::Vec::from_raw_parts(
                                                    l31.cast(),
                                                    len33,
                                                    len33,
                                                );
                                                let l34 = *base.add(16).cast::<*mut u8>();
                                                let l35 = *base.add(20).cast::<usize>();
                                                let len36 = l35;
                                                let bytes36 = _rt::Vec::from_raw_parts(
                                                    l34.cast(),
                                                    len36,
                                                    len36,
                                                );
                                                let l37 = *base.add(24).cast::<*mut u8>();
                                                let l38 = *base.add(28).cast::<usize>();
                                                let len39 = l38;
                                                let bytes39 = _rt::Vec::from_raw_parts(
                                                    l37.cast(),
                                                    len39,
                                                    len39,
                                                );
                                                let l40 = *base.add(32).cast::<*mut u8>();
                                                let l41 = *base.add(36).cast::<usize>();
                                                let len42 = l41;
                                                let bytes42 = _rt::Vec::from_raw_parts(
                                                    l40.cast(),
                                                    len42,
                                                    len42,
                                                );
                                                Capability {
                                                    issuer: Address {
                                                        node: _rt::string_lift(bytes30),
                                                        process: ProcessId {
                                                            process_name: _rt::string_lift(bytes33),
                                                            package_name: _rt::string_lift(bytes36),
                                                            publisher_node: _rt::string_lift(bytes39),
                                                        },
                                                    },
                                                    params: _rt::string_lift(bytes42),
                                                }
                                            };
                                            result43.push(e43);
                                        }
                                        _rt::cabi_dealloc(base43, len43 * 40, 4);
                                        let l44 = i32::from(*base.add(88).cast::<u8>());
                                        (
                                            Address {
                                                node: _rt::string_lift(bytes6),
                                                process: ProcessId {
                                                    process_name: _rt::string_lift(bytes9),
                                                    package_name: _rt::string_lift(bytes12),
                                                    publisher_node: _rt::string_lift(bytes15),
                                                },
                                            },
                                            Request {
                                                inherit: _rt::bool_lift(l16 as u8),
                                                expects_response: match l17 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l18 = *base.add(48).cast::<i64>();
                                                            l18 as u64
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                body: _rt::Vec::from_raw_parts(l19.cast(), len21, len21),
                                                metadata: match l22 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l23 = *base.add(68).cast::<*mut u8>();
                                                            let l24 = *base.add(72).cast::<usize>();
                                                            let len25 = l24;
                                                            let bytes25 = _rt::Vec::from_raw_parts(
                                                                l23.cast(),
                                                                len25,
                                                                len25,
                                                            );
                                                            _rt::string_lift(bytes25)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                capabilities: result43,
                                            },
                                            match l44 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l45 = i32::from(*base.add(92).cast::<u8>());
                                                        let l49 = *base.add(104).cast::<*mut u8>();
                                                        let l50 = *base.add(108).cast::<usize>();
                                                        let len51 = l50;
                                                        LazyLoadBlob {
                                                            mime: match l45 {
                                                                0 => None,
                                                                1 => {
                                                                    let e = {
                                                                        let l46 = *base.add(96).cast::<*mut u8>();
                                                                        let l47 = *base.add(100).cast::<usize>();
                                                                        let len48 = l47;
                                                                        let bytes48 = _rt::Vec::from_raw_parts(
                                                                            l46.cast(),
                                                                            len48,
                                                                            len48,
                                                                        );
                                                                        _rt::string_lift(bytes48)
                                                                    };
                                                                    Some(e)
                                                                }
                                                                _ => _rt::invalid_enum_discriminant(),
                                                            },
                                                            bytes: _rt::Vec::from_raw_parts(l49.cast(), len51, len51),
                                                        }
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            },
                                        )
                                    };
                                    result52.push(e52);
                                }
                                _rt::cabi_dealloc(base52, len52 * 112, 8);
                                result52
                            };
                            OnExit::Requests(e53)
                        }
                    };
                    v53
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn set_on_exit(on_exit: &OnExit) {
                unsafe {
                    let mut cleanup_list = _rt::Vec::new();
                    let (result23_0, result23_1, result23_2) = match on_exit {
                        OnExit::None => (0i32, ::core::ptr::null_mut(), 0usize),
                        OnExit::Restart => (1i32, ::core::ptr::null_mut(), 0usize),
                        OnExit::Requests(e) => {
                            let vec22 = e;
                            let len22 = vec22.len();
                            let layout22 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec22.len() * 112,
                                8,
                            );
                            let result22 = if layout22.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout22).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout22);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec22.into_iter().enumerate() {
                                let base = result22.add(i * 112);
                                {
                                    let (t0_0, t0_1, t0_2) = e;
                                    let Address { node: node1, process: process1 } = t0_0;
                                    let vec2 = node1;
                                    let ptr2 = vec2.as_ptr().cast::<u8>();
                                    let len2 = vec2.len();
                                    *base.add(4).cast::<usize>() = len2;
                                    *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                                    let ProcessId {
                                        process_name: process_name3,
                                        package_name: package_name3,
                                        publisher_node: publisher_node3,
                                    } = process1;
                                    let vec4 = process_name3;
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    *base.add(12).cast::<usize>() = len4;
                                    *base.add(8).cast::<*mut u8>() = ptr4.cast_mut();
                                    let vec5 = package_name3;
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    *base.add(20).cast::<usize>() = len5;
                                    *base.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                    let vec6 = publisher_node3;
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    *base.add(28).cast::<usize>() = len6;
                                    *base.add(24).cast::<*mut u8>() = ptr6.cast_mut();
                                    let Request {
                                        inherit: inherit7,
                                        expects_response: expects_response7,
                                        body: body7,
                                        metadata: metadata7,
                                        capabilities: capabilities7,
                                    } = t0_1;
                                    *base.add(32).cast::<u8>() = (match inherit7 {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                    match expects_response7 {
                                        Some(e) => {
                                            *base.add(40).cast::<u8>() = (1i32) as u8;
                                            *base.add(48).cast::<i64>() = _rt::as_i64(e);
                                        }
                                        None => {
                                            *base.add(40).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec8 = body7;
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    *base.add(60).cast::<usize>() = len8;
                                    *base.add(56).cast::<*mut u8>() = ptr8.cast_mut();
                                    match metadata7 {
                                        Some(e) => {
                                            *base.add(64).cast::<u8>() = (1i32) as u8;
                                            let vec9 = e;
                                            let ptr9 = vec9.as_ptr().cast::<u8>();
                                            let len9 = vec9.len();
                                            *base.add(72).cast::<usize>() = len9;
                                            *base.add(68).cast::<*mut u8>() = ptr9.cast_mut();
                                        }
                                        None => {
                                            *base.add(64).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec18 = capabilities7;
                                    let len18 = vec18.len();
                                    let layout18 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec18.len() * 40,
                                        4,
                                    );
                                    let result18 = if layout18.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout18).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout18);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec18.into_iter().enumerate() {
                                        let base = result18.add(i * 40);
                                        {
                                            let Capability { issuer: issuer10, params: params10 } = e;
                                            let Address { node: node11, process: process11 } = issuer10;
                                            let vec12 = node11;
                                            let ptr12 = vec12.as_ptr().cast::<u8>();
                                            let len12 = vec12.len();
                                            *base.add(4).cast::<usize>() = len12;
                                            *base.add(0).cast::<*mut u8>() = ptr12.cast_mut();
                                            let ProcessId {
                                                process_name: process_name13,
                                                package_name: package_name13,
                                                publisher_node: publisher_node13,
                                            } = process11;
                                            let vec14 = process_name13;
                                            let ptr14 = vec14.as_ptr().cast::<u8>();
                                            let len14 = vec14.len();
                                            *base.add(12).cast::<usize>() = len14;
                                            *base.add(8).cast::<*mut u8>() = ptr14.cast_mut();
                                            let vec15 = package_name13;
                                            let ptr15 = vec15.as_ptr().cast::<u8>();
                                            let len15 = vec15.len();
                                            *base.add(20).cast::<usize>() = len15;
                                            *base.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                            let vec16 = publisher_node13;
                                            let ptr16 = vec16.as_ptr().cast::<u8>();
                                            let len16 = vec16.len();
                                            *base.add(28).cast::<usize>() = len16;
                                            *base.add(24).cast::<*mut u8>() = ptr16.cast_mut();
                                            let vec17 = params10;
                                            let ptr17 = vec17.as_ptr().cast::<u8>();
                                            let len17 = vec17.len();
                                            *base.add(36).cast::<usize>() = len17;
                                            *base.add(32).cast::<*mut u8>() = ptr17.cast_mut();
                                        }
                                    }
                                    *base.add(80).cast::<usize>() = len18;
                                    *base.add(76).cast::<*mut u8>() = result18;
                                    match t0_2 {
                                        Some(e) => {
                                            *base.add(88).cast::<u8>() = (1i32) as u8;
                                            let LazyLoadBlob { mime: mime19, bytes: bytes19 } = e;
                                            match mime19 {
                                                Some(e) => {
                                                    *base.add(92).cast::<u8>() = (1i32) as u8;
                                                    let vec20 = e;
                                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                                    let len20 = vec20.len();
                                                    *base.add(100).cast::<usize>() = len20;
                                                    *base.add(96).cast::<*mut u8>() = ptr20.cast_mut();
                                                }
                                                None => {
                                                    *base.add(92).cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                            let vec21 = bytes19;
                                            let ptr21 = vec21.as_ptr().cast::<u8>();
                                            let len21 = vec21.len();
                                            *base.add(108).cast::<usize>() = len21;
                                            *base.add(104).cast::<*mut u8>() = ptr21.cast_mut();
                                        }
                                        None => {
                                            *base.add(88).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    cleanup_list.extend_from_slice(&[(result18, layout18)]);
                                }
                            }
                            cleanup_list.extend_from_slice(&[(result22, layout22)]);
                            (2i32, result22, len22)
                        }
                    };
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32, _: *mut u8, _: usize) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(result23_0, result23_1, result23_2);
                    for (ptr, layout) in cleanup_list {
                        if layout.size() != 0 {
                            _rt::alloc::dealloc(ptr.cast(), layout);
                        }
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_state() -> Option<_rt::Vec<u8>> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0);
                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                    match l1 {
                        0 => None,
                        1 => {
                            let e = {
                                let l2 = *ptr0.add(4).cast::<*mut u8>();
                                let l3 = *ptr0.add(8).cast::<usize>();
                                let len4 = l3;
                                _rt::Vec::from_raw_parts(l2.cast(), len4, len4)
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn set_state(bytes: &[u8]) {
                unsafe {
                    let vec0 = bytes;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0.cast_mut(), len0);
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn clear_state() {
                unsafe {
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import();
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn spawn(
                name: Option<&str>,
                wasm_path: &str,
                on_exit: &OnExit,
                request_capabilities: &[Capability],
                grant_capabilities: &[(ProcessId, Json)],
                public: bool,
            ) -> Result<ProcessId, SpawnError> {
                unsafe {
                    let mut cleanup_list = _rt::Vec::new();
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 28]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
                    let (result1_0, result1_1, result1_2) = match name {
                        Some(e) => {
                            let vec0 = e;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            (1i32, ptr0.cast_mut(), len0)
                        }
                        None => (0i32, ::core::ptr::null_mut(), 0usize),
                    };
                    let vec2 = wasm_path;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    let (result26_0, result26_1, result26_2) = match on_exit {
                        OnExit::None => (0i32, ::core::ptr::null_mut(), 0usize),
                        OnExit::Restart => (1i32, ::core::ptr::null_mut(), 0usize),
                        OnExit::Requests(e) => {
                            let vec25 = e;
                            let len25 = vec25.len();
                            let layout25 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec25.len() * 112,
                                8,
                            );
                            let result25 = if layout25.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout25).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout25);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec25.into_iter().enumerate() {
                                let base = result25.add(i * 112);
                                {
                                    let (t3_0, t3_1, t3_2) = e;
                                    let Address { node: node4, process: process4 } = t3_0;
                                    let vec5 = node4;
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    *base.add(4).cast::<usize>() = len5;
                                    *base.add(0).cast::<*mut u8>() = ptr5.cast_mut();
                                    let ProcessId {
                                        process_name: process_name6,
                                        package_name: package_name6,
                                        publisher_node: publisher_node6,
                                    } = process4;
                                    let vec7 = process_name6;
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    *base.add(12).cast::<usize>() = len7;
                                    *base.add(8).cast::<*mut u8>() = ptr7.cast_mut();
                                    let vec8 = package_name6;
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    *base.add(20).cast::<usize>() = len8;
                                    *base.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                    let vec9 = publisher_node6;
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    *base.add(28).cast::<usize>() = len9;
                                    *base.add(24).cast::<*mut u8>() = ptr9.cast_mut();
                                    let Request {
                                        inherit: inherit10,
                                        expects_response: expects_response10,
                                        body: body10,
                                        metadata: metadata10,
                                        capabilities: capabilities10,
                                    } = t3_1;
                                    *base.add(32).cast::<u8>() = (match inherit10 {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                    match expects_response10 {
                                        Some(e) => {
                                            *base.add(40).cast::<u8>() = (1i32) as u8;
                                            *base.add(48).cast::<i64>() = _rt::as_i64(e);
                                        }
                                        None => {
                                            *base.add(40).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec11 = body10;
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    *base.add(60).cast::<usize>() = len11;
                                    *base.add(56).cast::<*mut u8>() = ptr11.cast_mut();
                                    match metadata10 {
                                        Some(e) => {
                                            *base.add(64).cast::<u8>() = (1i32) as u8;
                                            let vec12 = e;
                                            let ptr12 = vec12.as_ptr().cast::<u8>();
                                            let len12 = vec12.len();
                                            *base.add(72).cast::<usize>() = len12;
                                            *base.add(68).cast::<*mut u8>() = ptr12.cast_mut();
                                        }
                                        None => {
                                            *base.add(64).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec21 = capabilities10;
                                    let len21 = vec21.len();
                                    let layout21 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec21.len() * 40,
                                        4,
                                    );
                                    let result21 = if layout21.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout21).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout21);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec21.into_iter().enumerate() {
                                        let base = result21.add(i * 40);
                                        {
                                            let Capability { issuer: issuer13, params: params13 } = e;
                                            let Address { node: node14, process: process14 } = issuer13;
                                            let vec15 = node14;
                                            let ptr15 = vec15.as_ptr().cast::<u8>();
                                            let len15 = vec15.len();
                                            *base.add(4).cast::<usize>() = len15;
                                            *base.add(0).cast::<*mut u8>() = ptr15.cast_mut();
                                            let ProcessId {
                                                process_name: process_name16,
                                                package_name: package_name16,
                                                publisher_node: publisher_node16,
                                            } = process14;
                                            let vec17 = process_name16;
                                            let ptr17 = vec17.as_ptr().cast::<u8>();
                                            let len17 = vec17.len();
                                            *base.add(12).cast::<usize>() = len17;
                                            *base.add(8).cast::<*mut u8>() = ptr17.cast_mut();
                                            let vec18 = package_name16;
                                            let ptr18 = vec18.as_ptr().cast::<u8>();
                                            let len18 = vec18.len();
                                            *base.add(20).cast::<usize>() = len18;
                                            *base.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                            let vec19 = publisher_node16;
                                            let ptr19 = vec19.as_ptr().cast::<u8>();
                                            let len19 = vec19.len();
                                            *base.add(28).cast::<usize>() = len19;
                                            *base.add(24).cast::<*mut u8>() = ptr19.cast_mut();
                                            let vec20 = params13;
                                            let ptr20 = vec20.as_ptr().cast::<u8>();
                                            let len20 = vec20.len();
                                            *base.add(36).cast::<usize>() = len20;
                                            *base.add(32).cast::<*mut u8>() = ptr20.cast_mut();
                                        }
                                    }
                                    *base.add(80).cast::<usize>() = len21;
                                    *base.add(76).cast::<*mut u8>() = result21;
                                    match t3_2 {
                                        Some(e) => {
                                            *base.add(88).cast::<u8>() = (1i32) as u8;
                                            let LazyLoadBlob { mime: mime22, bytes: bytes22 } = e;
                                            match mime22 {
                                                Some(e) => {
                                                    *base.add(92).cast::<u8>() = (1i32) as u8;
                                                    let vec23 = e;
                                                    let ptr23 = vec23.as_ptr().cast::<u8>();
                                                    let len23 = vec23.len();
                                                    *base.add(100).cast::<usize>() = len23;
                                                    *base.add(96).cast::<*mut u8>() = ptr23.cast_mut();
                                                }
                                                None => {
                                                    *base.add(92).cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                            let vec24 = bytes22;
                                            let ptr24 = vec24.as_ptr().cast::<u8>();
                                            let len24 = vec24.len();
                                            *base.add(108).cast::<usize>() = len24;
                                            *base.add(104).cast::<*mut u8>() = ptr24.cast_mut();
                                        }
                                        None => {
                                            *base.add(88).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    cleanup_list.extend_from_slice(&[(result21, layout21)]);
                                }
                            }
                            cleanup_list.extend_from_slice(&[(result25, layout25)]);
                            (2i32, result25, len25)
                        }
                    };
                    let vec35 = request_capabilities;
                    let len35 = vec35.len();
                    let layout35 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec35.len() * 40,
                        4,
                    );
                    let result35 = if layout35.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout35).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout35);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec35.into_iter().enumerate() {
                        let base = result35.add(i * 40);
                        {
                            let Capability { issuer: issuer27, params: params27 } = e;
                            let Address { node: node28, process: process28 } = issuer27;
                            let vec29 = node28;
                            let ptr29 = vec29.as_ptr().cast::<u8>();
                            let len29 = vec29.len();
                            *base.add(4).cast::<usize>() = len29;
                            *base.add(0).cast::<*mut u8>() = ptr29.cast_mut();
                            let ProcessId {
                                process_name: process_name30,
                                package_name: package_name30,
                                publisher_node: publisher_node30,
                            } = process28;
                            let vec31 = process_name30;
                            let ptr31 = vec31.as_ptr().cast::<u8>();
                            let len31 = vec31.len();
                            *base.add(12).cast::<usize>() = len31;
                            *base.add(8).cast::<*mut u8>() = ptr31.cast_mut();
                            let vec32 = package_name30;
                            let ptr32 = vec32.as_ptr().cast::<u8>();
                            let len32 = vec32.len();
                            *base.add(20).cast::<usize>() = len32;
                            *base.add(16).cast::<*mut u8>() = ptr32.cast_mut();
                            let vec33 = publisher_node30;
                            let ptr33 = vec33.as_ptr().cast::<u8>();
                            let len33 = vec33.len();
                            *base.add(28).cast::<usize>() = len33;
                            *base.add(24).cast::<*mut u8>() = ptr33.cast_mut();
                            let vec34 = params27;
                            let ptr34 = vec34.as_ptr().cast::<u8>();
                            let len34 = vec34.len();
                            *base.add(36).cast::<usize>() = len34;
                            *base.add(32).cast::<*mut u8>() = ptr34.cast_mut();
                        }
                    }
                    let vec42 = grant_capabilities;
                    let len42 = vec42.len();
                    let layout42 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec42.len() * 32,
                        4,
                    );
                    let result42 = if layout42.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout42).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout42);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec42.into_iter().enumerate() {
                        let base = result42.add(i * 32);
                        {
                            let (t36_0, t36_1) = e;
                            let ProcessId {
                                process_name: process_name37,
                                package_name: package_name37,
                                publisher_node: publisher_node37,
                            } = t36_0;
                            let vec38 = process_name37;
                            let ptr38 = vec38.as_ptr().cast::<u8>();
                            let len38 = vec38.len();
                            *base.add(4).cast::<usize>() = len38;
                            *base.add(0).cast::<*mut u8>() = ptr38.cast_mut();
                            let vec39 = package_name37;
                            let ptr39 = vec39.as_ptr().cast::<u8>();
                            let len39 = vec39.len();
                            *base.add(12).cast::<usize>() = len39;
                            *base.add(8).cast::<*mut u8>() = ptr39.cast_mut();
                            let vec40 = publisher_node37;
                            let ptr40 = vec40.as_ptr().cast::<u8>();
                            let len40 = vec40.len();
                            *base.add(20).cast::<usize>() = len40;
                            *base.add(16).cast::<*mut u8>() = ptr40.cast_mut();
                            let vec41 = t36_1;
                            let ptr41 = vec41.as_ptr().cast::<u8>();
                            let len41 = vec41.len();
                            *base.add(28).cast::<usize>() = len41;
                            *base.add(24).cast::<*mut u8>() = ptr41.cast_mut();
                        }
                    }
                    let ptr43 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: i32,
                        _: *mut u8,
                    ) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(
                        result1_0,
                        result1_1,
                        result1_2,
                        ptr2.cast_mut(),
                        len2,
                        result26_0,
                        result26_1,
                        result26_2,
                        result35,
                        len35,
                        result42,
                        len42,
                        match &public {
                            true => 1,
                            false => 0,
                        },
                        ptr43,
                    );
                    let l44 = i32::from(*ptr43.add(0).cast::<u8>());
                    if layout35.size() != 0 {
                        _rt::alloc::dealloc(result35.cast(), layout35);
                    }
                    if layout42.size() != 0 {
                        _rt::alloc::dealloc(result42.cast(), layout42);
                    }
                    for (ptr, layout) in cleanup_list {
                        if layout.size() != 0 {
                            _rt::alloc::dealloc(ptr.cast(), layout);
                        }
                    }
                    match l44 {
                        0 => {
                            let e = {
                                let l45 = *ptr43.add(4).cast::<*mut u8>();
                                let l46 = *ptr43.add(8).cast::<usize>();
                                let len47 = l46;
                                let bytes47 = _rt::Vec::from_raw_parts(
                                    l45.cast(),
                                    len47,
                                    len47,
                                );
                                let l48 = *ptr43.add(12).cast::<*mut u8>();
                                let l49 = *ptr43.add(16).cast::<usize>();
                                let len50 = l49;
                                let bytes50 = _rt::Vec::from_raw_parts(
                                    l48.cast(),
                                    len50,
                                    len50,
                                );
                                let l51 = *ptr43.add(20).cast::<*mut u8>();
                                let l52 = *ptr43.add(24).cast::<usize>();
                                let len53 = l52;
                                let bytes53 = _rt::Vec::from_raw_parts(
                                    l51.cast(),
                                    len53,
                                    len53,
                                );
                                ProcessId {
                                    process_name: _rt::string_lift(bytes47),
                                    package_name: _rt::string_lift(bytes50),
                                    publisher_node: _rt::string_lift(bytes53),
                                }
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l54 = i32::from(*ptr43.add(4).cast::<u8>());
                                SpawnError::_lift(l54 as u8)
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            ///   
            /// Capabilities Management
            ///   
            /// Saves the capabilities to persisted process state.
            pub fn save_capabilities(caps: &[Capability]) {
                unsafe {
                    let vec8 = caps;
                    let len8 = vec8.len();
                    let layout8 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec8.len() * 40,
                        4,
                    );
                    let result8 = if layout8.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout8).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout8);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec8.into_iter().enumerate() {
                        let base = result8.add(i * 40);
                        {
                            let Capability { issuer: issuer0, params: params0 } = e;
                            let Address { node: node1, process: process1 } = issuer0;
                            let vec2 = node1;
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            *base.add(4).cast::<usize>() = len2;
                            *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                            let ProcessId {
                                process_name: process_name3,
                                package_name: package_name3,
                                publisher_node: publisher_node3,
                            } = process1;
                            let vec4 = process_name3;
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            *base.add(12).cast::<usize>() = len4;
                            *base.add(8).cast::<*mut u8>() = ptr4.cast_mut();
                            let vec5 = package_name3;
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            *base.add(20).cast::<usize>() = len5;
                            *base.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                            let vec6 = publisher_node3;
                            let ptr6 = vec6.as_ptr().cast::<u8>();
                            let len6 = vec6.len();
                            *base.add(28).cast::<usize>() = len6;
                            *base.add(24).cast::<*mut u8>() = ptr6.cast_mut();
                            let vec7 = params0;
                            let ptr7 = vec7.as_ptr().cast::<u8>();
                            let len7 = vec7.len();
                            *base.add(36).cast::<usize>() = len7;
                            *base.add(32).cast::<*mut u8>() = ptr7.cast_mut();
                        }
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(result8, len8);
                    if layout8.size() != 0 {
                        _rt::alloc::dealloc(result8.cast(), layout8);
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Deletes the capabilities from persisted process state.
            pub fn drop_capabilities(caps: &[Capability]) {
                unsafe {
                    let vec8 = caps;
                    let len8 = vec8.len();
                    let layout8 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec8.len() * 40,
                        4,
                    );
                    let result8 = if layout8.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout8).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout8);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec8.into_iter().enumerate() {
                        let base = result8.add(i * 40);
                        {
                            let Capability { issuer: issuer0, params: params0 } = e;
                            let Address { node: node1, process: process1 } = issuer0;
                            let vec2 = node1;
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            *base.add(4).cast::<usize>() = len2;
                            *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                            let ProcessId {
                                process_name: process_name3,
                                package_name: package_name3,
                                publisher_node: publisher_node3,
                            } = process1;
                            let vec4 = process_name3;
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            *base.add(12).cast::<usize>() = len4;
                            *base.add(8).cast::<*mut u8>() = ptr4.cast_mut();
                            let vec5 = package_name3;
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            *base.add(20).cast::<usize>() = len5;
                            *base.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                            let vec6 = publisher_node3;
                            let ptr6 = vec6.as_ptr().cast::<u8>();
                            let len6 = vec6.len();
                            *base.add(28).cast::<usize>() = len6;
                            *base.add(24).cast::<*mut u8>() = ptr6.cast_mut();
                            let vec7 = params0;
                            let ptr7 = vec7.as_ptr().cast::<u8>();
                            let len7 = vec7.len();
                            *base.add(36).cast::<usize>() = len7;
                            *base.add(32).cast::<*mut u8>() = ptr7.cast_mut();
                        }
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(result8, len8);
                    if layout8.size() != 0 {
                        _rt::alloc::dealloc(result8.cast(), layout8);
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Gets all capabilities from persisted process state.
            pub fn our_capabilities() -> _rt::Vec<Capability> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0);
                    let l1 = *ptr0.add(0).cast::<*mut u8>();
                    let l2 = *ptr0.add(4).cast::<usize>();
                    let base18 = l1;
                    let len18 = l2;
                    let mut result18 = _rt::Vec::with_capacity(len18);
                    for i in 0..len18 {
                        let base = base18.add(i * 40);
                        let e18 = {
                            let l3 = *base.add(0).cast::<*mut u8>();
                            let l4 = *base.add(4).cast::<usize>();
                            let len5 = l4;
                            let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                            let l6 = *base.add(8).cast::<*mut u8>();
                            let l7 = *base.add(12).cast::<usize>();
                            let len8 = l7;
                            let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);
                            let l9 = *base.add(16).cast::<*mut u8>();
                            let l10 = *base.add(20).cast::<usize>();
                            let len11 = l10;
                            let bytes11 = _rt::Vec::from_raw_parts(
                                l9.cast(),
                                len11,
                                len11,
                            );
                            let l12 = *base.add(24).cast::<*mut u8>();
                            let l13 = *base.add(28).cast::<usize>();
                            let len14 = l13;
                            let bytes14 = _rt::Vec::from_raw_parts(
                                l12.cast(),
                                len14,
                                len14,
                            );
                            let l15 = *base.add(32).cast::<*mut u8>();
                            let l16 = *base.add(36).cast::<usize>();
                            let len17 = l16;
                            let bytes17 = _rt::Vec::from_raw_parts(
                                l15.cast(),
                                len17,
                                len17,
                            );
                            Capability {
                                issuer: Address {
                                    node: _rt::string_lift(bytes5),
                                    process: ProcessId {
                                        process_name: _rt::string_lift(bytes8),
                                        package_name: _rt::string_lift(bytes11),
                                        publisher_node: _rt::string_lift(bytes14),
                                    },
                                },
                                params: _rt::string_lift(bytes17),
                            }
                        };
                        result18.push(e18);
                    }
                    _rt::cabi_dealloc(base18, len18 * 40, 4);
                    result18
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            ///   
            /// Message I/O
            ///   
            /// Ingest next message when it arrives along with its source.
            /// Almost all long-running processes will call this in a loop.
            pub fn receive() -> Result<
                (Address, Message),
                (SendError, Option<Context>),
            > {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 152]);
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 152],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0);
                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                    match l1 {
                        0 => {
                            let e = {
                                let l2 = *ptr0.add(8).cast::<*mut u8>();
                                let l3 = *ptr0.add(12).cast::<usize>();
                                let len4 = l3;
                                let bytes4 = _rt::Vec::from_raw_parts(
                                    l2.cast(),
                                    len4,
                                    len4,
                                );
                                let l5 = *ptr0.add(16).cast::<*mut u8>();
                                let l6 = *ptr0.add(20).cast::<usize>();
                                let len7 = l6;
                                let bytes7 = _rt::Vec::from_raw_parts(
                                    l5.cast(),
                                    len7,
                                    len7,
                                );
                                let l8 = *ptr0.add(24).cast::<*mut u8>();
                                let l9 = *ptr0.add(28).cast::<usize>();
                                let len10 = l9;
                                let bytes10 = _rt::Vec::from_raw_parts(
                                    l8.cast(),
                                    len10,
                                    len10,
                                );
                                let l11 = *ptr0.add(32).cast::<*mut u8>();
                                let l12 = *ptr0.add(36).cast::<usize>();
                                let len13 = l12;
                                let bytes13 = _rt::Vec::from_raw_parts(
                                    l11.cast(),
                                    len13,
                                    len13,
                                );
                                let l14 = i32::from(*ptr0.add(40).cast::<u8>());
                                let v73 = match l14 {
                                    0 => {
                                        let e73 = {
                                            let l15 = i32::from(*ptr0.add(48).cast::<u8>());
                                            let l16 = i32::from(*ptr0.add(56).cast::<u8>());
                                            let l18 = *ptr0.add(72).cast::<*mut u8>();
                                            let l19 = *ptr0.add(76).cast::<usize>();
                                            let len20 = l19;
                                            let l21 = i32::from(*ptr0.add(80).cast::<u8>());
                                            let l25 = *ptr0.add(92).cast::<*mut u8>();
                                            let l26 = *ptr0.add(96).cast::<usize>();
                                            let base42 = l25;
                                            let len42 = l26;
                                            let mut result42 = _rt::Vec::with_capacity(len42);
                                            for i in 0..len42 {
                                                let base = base42.add(i * 40);
                                                let e42 = {
                                                    let l27 = *base.add(0).cast::<*mut u8>();
                                                    let l28 = *base.add(4).cast::<usize>();
                                                    let len29 = l28;
                                                    let bytes29 = _rt::Vec::from_raw_parts(
                                                        l27.cast(),
                                                        len29,
                                                        len29,
                                                    );
                                                    let l30 = *base.add(8).cast::<*mut u8>();
                                                    let l31 = *base.add(12).cast::<usize>();
                                                    let len32 = l31;
                                                    let bytes32 = _rt::Vec::from_raw_parts(
                                                        l30.cast(),
                                                        len32,
                                                        len32,
                                                    );
                                                    let l33 = *base.add(16).cast::<*mut u8>();
                                                    let l34 = *base.add(20).cast::<usize>();
                                                    let len35 = l34;
                                                    let bytes35 = _rt::Vec::from_raw_parts(
                                                        l33.cast(),
                                                        len35,
                                                        len35,
                                                    );
                                                    let l36 = *base.add(24).cast::<*mut u8>();
                                                    let l37 = *base.add(28).cast::<usize>();
                                                    let len38 = l37;
                                                    let bytes38 = _rt::Vec::from_raw_parts(
                                                        l36.cast(),
                                                        len38,
                                                        len38,
                                                    );
                                                    let l39 = *base.add(32).cast::<*mut u8>();
                                                    let l40 = *base.add(36).cast::<usize>();
                                                    let len41 = l40;
                                                    let bytes41 = _rt::Vec::from_raw_parts(
                                                        l39.cast(),
                                                        len41,
                                                        len41,
                                                    );
                                                    Capability {
                                                        issuer: Address {
                                                            node: _rt::string_lift(bytes29),
                                                            process: ProcessId {
                                                                process_name: _rt::string_lift(bytes32),
                                                                package_name: _rt::string_lift(bytes35),
                                                                publisher_node: _rt::string_lift(bytes38),
                                                            },
                                                        },
                                                        params: _rt::string_lift(bytes41),
                                                    }
                                                };
                                                result42.push(e42);
                                            }
                                            _rt::cabi_dealloc(base42, len42 * 40, 4);
                                            Request {
                                                inherit: _rt::bool_lift(l15 as u8),
                                                expects_response: match l16 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l17 = *ptr0.add(64).cast::<i64>();
                                                            l17 as u64
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                body: _rt::Vec::from_raw_parts(l18.cast(), len20, len20),
                                                metadata: match l21 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l22 = *ptr0.add(84).cast::<*mut u8>();
                                                            let l23 = *ptr0.add(88).cast::<usize>();
                                                            let len24 = l23;
                                                            let bytes24 = _rt::Vec::from_raw_parts(
                                                                l22.cast(),
                                                                len24,
                                                                len24,
                                                            );
                                                            _rt::string_lift(bytes24)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                capabilities: result42,
                                            }
                                        };
                                        Message::Request(e73)
                                    }
                                    n => {
                                        if true {
                                            match (&n, &1) {
                                                (left_val, right_val) => {
                                                    if !(*left_val == *right_val) {
                                                        let kind = ::core::panicking::AssertKind::Eq;
                                                        ::core::panicking::assert_failed(
                                                            kind,
                                                            &*left_val,
                                                            &*right_val,
                                                            ::core::option::Option::Some(
                                                                format_args!("invalid enum discriminant"),
                                                            ),
                                                        );
                                                    }
                                                }
                                            };
                                        }
                                        let e73 = {
                                            let l43 = i32::from(*ptr0.add(48).cast::<u8>());
                                            let l44 = *ptr0.add(52).cast::<*mut u8>();
                                            let l45 = *ptr0.add(56).cast::<usize>();
                                            let len46 = l45;
                                            let l47 = i32::from(*ptr0.add(60).cast::<u8>());
                                            let l51 = *ptr0.add(72).cast::<*mut u8>();
                                            let l52 = *ptr0.add(76).cast::<usize>();
                                            let base68 = l51;
                                            let len68 = l52;
                                            let mut result68 = _rt::Vec::with_capacity(len68);
                                            for i in 0..len68 {
                                                let base = base68.add(i * 40);
                                                let e68 = {
                                                    let l53 = *base.add(0).cast::<*mut u8>();
                                                    let l54 = *base.add(4).cast::<usize>();
                                                    let len55 = l54;
                                                    let bytes55 = _rt::Vec::from_raw_parts(
                                                        l53.cast(),
                                                        len55,
                                                        len55,
                                                    );
                                                    let l56 = *base.add(8).cast::<*mut u8>();
                                                    let l57 = *base.add(12).cast::<usize>();
                                                    let len58 = l57;
                                                    let bytes58 = _rt::Vec::from_raw_parts(
                                                        l56.cast(),
                                                        len58,
                                                        len58,
                                                    );
                                                    let l59 = *base.add(16).cast::<*mut u8>();
                                                    let l60 = *base.add(20).cast::<usize>();
                                                    let len61 = l60;
                                                    let bytes61 = _rt::Vec::from_raw_parts(
                                                        l59.cast(),
                                                        len61,
                                                        len61,
                                                    );
                                                    let l62 = *base.add(24).cast::<*mut u8>();
                                                    let l63 = *base.add(28).cast::<usize>();
                                                    let len64 = l63;
                                                    let bytes64 = _rt::Vec::from_raw_parts(
                                                        l62.cast(),
                                                        len64,
                                                        len64,
                                                    );
                                                    let l65 = *base.add(32).cast::<*mut u8>();
                                                    let l66 = *base.add(36).cast::<usize>();
                                                    let len67 = l66;
                                                    let bytes67 = _rt::Vec::from_raw_parts(
                                                        l65.cast(),
                                                        len67,
                                                        len67,
                                                    );
                                                    Capability {
                                                        issuer: Address {
                                                            node: _rt::string_lift(bytes55),
                                                            process: ProcessId {
                                                                process_name: _rt::string_lift(bytes58),
                                                                package_name: _rt::string_lift(bytes61),
                                                                publisher_node: _rt::string_lift(bytes64),
                                                            },
                                                        },
                                                        params: _rt::string_lift(bytes67),
                                                    }
                                                };
                                                result68.push(e68);
                                            }
                                            _rt::cabi_dealloc(base68, len68 * 40, 4);
                                            let l69 = i32::from(*ptr0.add(80).cast::<u8>());
                                            (
                                                Response {
                                                    inherit: _rt::bool_lift(l43 as u8),
                                                    body: _rt::Vec::from_raw_parts(l44.cast(), len46, len46),
                                                    metadata: match l47 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l48 = *ptr0.add(64).cast::<*mut u8>();
                                                                let l49 = *ptr0.add(68).cast::<usize>();
                                                                let len50 = l49;
                                                                let bytes50 = _rt::Vec::from_raw_parts(
                                                                    l48.cast(),
                                                                    len50,
                                                                    len50,
                                                                );
                                                                _rt::string_lift(bytes50)
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                    capabilities: result68,
                                                },
                                                match l69 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l70 = *ptr0.add(84).cast::<*mut u8>();
                                                            let l71 = *ptr0.add(88).cast::<usize>();
                                                            let len72 = l71;
                                                            _rt::Vec::from_raw_parts(l70.cast(), len72, len72)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                            )
                                        };
                                        Message::Response(e73)
                                    }
                                };
                                (
                                    Address {
                                        node: _rt::string_lift(bytes4),
                                        process: ProcessId {
                                            process_name: _rt::string_lift(bytes7),
                                            package_name: _rt::string_lift(bytes10),
                                            publisher_node: _rt::string_lift(bytes13),
                                        },
                                    },
                                    v73,
                                )
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l74 = i32::from(*ptr0.add(8).cast::<u8>());
                                let l75 = *ptr0.add(12).cast::<*mut u8>();
                                let l76 = *ptr0.add(16).cast::<usize>();
                                let len77 = l76;
                                let bytes77 = _rt::Vec::from_raw_parts(
                                    l75.cast(),
                                    len77,
                                    len77,
                                );
                                let l78 = *ptr0.add(20).cast::<*mut u8>();
                                let l79 = *ptr0.add(24).cast::<usize>();
                                let len80 = l79;
                                let bytes80 = _rt::Vec::from_raw_parts(
                                    l78.cast(),
                                    len80,
                                    len80,
                                );
                                let l81 = *ptr0.add(28).cast::<*mut u8>();
                                let l82 = *ptr0.add(32).cast::<usize>();
                                let len83 = l82;
                                let bytes83 = _rt::Vec::from_raw_parts(
                                    l81.cast(),
                                    len83,
                                    len83,
                                );
                                let l84 = *ptr0.add(36).cast::<*mut u8>();
                                let l85 = *ptr0.add(40).cast::<usize>();
                                let len86 = l85;
                                let bytes86 = _rt::Vec::from_raw_parts(
                                    l84.cast(),
                                    len86,
                                    len86,
                                );
                                let l87 = i32::from(*ptr0.add(48).cast::<u8>());
                                let v146 = match l87 {
                                    0 => {
                                        let e146 = {
                                            let l88 = i32::from(*ptr0.add(56).cast::<u8>());
                                            let l89 = i32::from(*ptr0.add(64).cast::<u8>());
                                            let l91 = *ptr0.add(80).cast::<*mut u8>();
                                            let l92 = *ptr0.add(84).cast::<usize>();
                                            let len93 = l92;
                                            let l94 = i32::from(*ptr0.add(88).cast::<u8>());
                                            let l98 = *ptr0.add(100).cast::<*mut u8>();
                                            let l99 = *ptr0.add(104).cast::<usize>();
                                            let base115 = l98;
                                            let len115 = l99;
                                            let mut result115 = _rt::Vec::with_capacity(len115);
                                            for i in 0..len115 {
                                                let base = base115.add(i * 40);
                                                let e115 = {
                                                    let l100 = *base.add(0).cast::<*mut u8>();
                                                    let l101 = *base.add(4).cast::<usize>();
                                                    let len102 = l101;
                                                    let bytes102 = _rt::Vec::from_raw_parts(
                                                        l100.cast(),
                                                        len102,
                                                        len102,
                                                    );
                                                    let l103 = *base.add(8).cast::<*mut u8>();
                                                    let l104 = *base.add(12).cast::<usize>();
                                                    let len105 = l104;
                                                    let bytes105 = _rt::Vec::from_raw_parts(
                                                        l103.cast(),
                                                        len105,
                                                        len105,
                                                    );
                                                    let l106 = *base.add(16).cast::<*mut u8>();
                                                    let l107 = *base.add(20).cast::<usize>();
                                                    let len108 = l107;
                                                    let bytes108 = _rt::Vec::from_raw_parts(
                                                        l106.cast(),
                                                        len108,
                                                        len108,
                                                    );
                                                    let l109 = *base.add(24).cast::<*mut u8>();
                                                    let l110 = *base.add(28).cast::<usize>();
                                                    let len111 = l110;
                                                    let bytes111 = _rt::Vec::from_raw_parts(
                                                        l109.cast(),
                                                        len111,
                                                        len111,
                                                    );
                                                    let l112 = *base.add(32).cast::<*mut u8>();
                                                    let l113 = *base.add(36).cast::<usize>();
                                                    let len114 = l113;
                                                    let bytes114 = _rt::Vec::from_raw_parts(
                                                        l112.cast(),
                                                        len114,
                                                        len114,
                                                    );
                                                    Capability {
                                                        issuer: Address {
                                                            node: _rt::string_lift(bytes102),
                                                            process: ProcessId {
                                                                process_name: _rt::string_lift(bytes105),
                                                                package_name: _rt::string_lift(bytes108),
                                                                publisher_node: _rt::string_lift(bytes111),
                                                            },
                                                        },
                                                        params: _rt::string_lift(bytes114),
                                                    }
                                                };
                                                result115.push(e115);
                                            }
                                            _rt::cabi_dealloc(base115, len115 * 40, 4);
                                            Request {
                                                inherit: _rt::bool_lift(l88 as u8),
                                                expects_response: match l89 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l90 = *ptr0.add(72).cast::<i64>();
                                                            l90 as u64
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                body: _rt::Vec::from_raw_parts(l91.cast(), len93, len93),
                                                metadata: match l94 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l95 = *ptr0.add(92).cast::<*mut u8>();
                                                            let l96 = *ptr0.add(96).cast::<usize>();
                                                            let len97 = l96;
                                                            let bytes97 = _rt::Vec::from_raw_parts(
                                                                l95.cast(),
                                                                len97,
                                                                len97,
                                                            );
                                                            _rt::string_lift(bytes97)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                capabilities: result115,
                                            }
                                        };
                                        Message::Request(e146)
                                    }
                                    n => {
                                        if true {
                                            match (&n, &1) {
                                                (left_val, right_val) => {
                                                    if !(*left_val == *right_val) {
                                                        let kind = ::core::panicking::AssertKind::Eq;
                                                        ::core::panicking::assert_failed(
                                                            kind,
                                                            &*left_val,
                                                            &*right_val,
                                                            ::core::option::Option::Some(
                                                                format_args!("invalid enum discriminant"),
                                                            ),
                                                        );
                                                    }
                                                }
                                            };
                                        }
                                        let e146 = {
                                            let l116 = i32::from(*ptr0.add(56).cast::<u8>());
                                            let l117 = *ptr0.add(60).cast::<*mut u8>();
                                            let l118 = *ptr0.add(64).cast::<usize>();
                                            let len119 = l118;
                                            let l120 = i32::from(*ptr0.add(68).cast::<u8>());
                                            let l124 = *ptr0.add(80).cast::<*mut u8>();
                                            let l125 = *ptr0.add(84).cast::<usize>();
                                            let base141 = l124;
                                            let len141 = l125;
                                            let mut result141 = _rt::Vec::with_capacity(len141);
                                            for i in 0..len141 {
                                                let base = base141.add(i * 40);
                                                let e141 = {
                                                    let l126 = *base.add(0).cast::<*mut u8>();
                                                    let l127 = *base.add(4).cast::<usize>();
                                                    let len128 = l127;
                                                    let bytes128 = _rt::Vec::from_raw_parts(
                                                        l126.cast(),
                                                        len128,
                                                        len128,
                                                    );
                                                    let l129 = *base.add(8).cast::<*mut u8>();
                                                    let l130 = *base.add(12).cast::<usize>();
                                                    let len131 = l130;
                                                    let bytes131 = _rt::Vec::from_raw_parts(
                                                        l129.cast(),
                                                        len131,
                                                        len131,
                                                    );
                                                    let l132 = *base.add(16).cast::<*mut u8>();
                                                    let l133 = *base.add(20).cast::<usize>();
                                                    let len134 = l133;
                                                    let bytes134 = _rt::Vec::from_raw_parts(
                                                        l132.cast(),
                                                        len134,
                                                        len134,
                                                    );
                                                    let l135 = *base.add(24).cast::<*mut u8>();
                                                    let l136 = *base.add(28).cast::<usize>();
                                                    let len137 = l136;
                                                    let bytes137 = _rt::Vec::from_raw_parts(
                                                        l135.cast(),
                                                        len137,
                                                        len137,
                                                    );
                                                    let l138 = *base.add(32).cast::<*mut u8>();
                                                    let l139 = *base.add(36).cast::<usize>();
                                                    let len140 = l139;
                                                    let bytes140 = _rt::Vec::from_raw_parts(
                                                        l138.cast(),
                                                        len140,
                                                        len140,
                                                    );
                                                    Capability {
                                                        issuer: Address {
                                                            node: _rt::string_lift(bytes128),
                                                            process: ProcessId {
                                                                process_name: _rt::string_lift(bytes131),
                                                                package_name: _rt::string_lift(bytes134),
                                                                publisher_node: _rt::string_lift(bytes137),
                                                            },
                                                        },
                                                        params: _rt::string_lift(bytes140),
                                                    }
                                                };
                                                result141.push(e141);
                                            }
                                            _rt::cabi_dealloc(base141, len141 * 40, 4);
                                            let l142 = i32::from(*ptr0.add(88).cast::<u8>());
                                            (
                                                Response {
                                                    inherit: _rt::bool_lift(l116 as u8),
                                                    body: _rt::Vec::from_raw_parts(l117.cast(), len119, len119),
                                                    metadata: match l120 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l121 = *ptr0.add(72).cast::<*mut u8>();
                                                                let l122 = *ptr0.add(76).cast::<usize>();
                                                                let len123 = l122;
                                                                let bytes123 = _rt::Vec::from_raw_parts(
                                                                    l121.cast(),
                                                                    len123,
                                                                    len123,
                                                                );
                                                                _rt::string_lift(bytes123)
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                    capabilities: result141,
                                                },
                                                match l142 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l143 = *ptr0.add(92).cast::<*mut u8>();
                                                            let l144 = *ptr0.add(96).cast::<usize>();
                                                            let len145 = l144;
                                                            _rt::Vec::from_raw_parts(l143.cast(), len145, len145)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                            )
                                        };
                                        Message::Response(e146)
                                    }
                                };
                                let l147 = i32::from(*ptr0.add(112).cast::<u8>());
                                let l155 = i32::from(*ptr0.add(136).cast::<u8>());
                                (
                                    SendError {
                                        kind: SendErrorKind::_lift(l74 as u8),
                                        target: Address {
                                            node: _rt::string_lift(bytes77),
                                            process: ProcessId {
                                                process_name: _rt::string_lift(bytes80),
                                                package_name: _rt::string_lift(bytes83),
                                                publisher_node: _rt::string_lift(bytes86),
                                            },
                                        },
                                        message: v146,
                                        lazy_load_blob: match l147 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l148 = i32::from(*ptr0.add(116).cast::<u8>());
                                                    let l152 = *ptr0.add(128).cast::<*mut u8>();
                                                    let l153 = *ptr0.add(132).cast::<usize>();
                                                    let len154 = l153;
                                                    LazyLoadBlob {
                                                        mime: match l148 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l149 = *ptr0.add(120).cast::<*mut u8>();
                                                                    let l150 = *ptr0.add(124).cast::<usize>();
                                                                    let len151 = l150;
                                                                    let bytes151 = _rt::Vec::from_raw_parts(
                                                                        l149.cast(),
                                                                        len151,
                                                                        len151,
                                                                    );
                                                                    _rt::string_lift(bytes151)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        bytes: _rt::Vec::from_raw_parts(l152.cast(), len154, len154),
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                    },
                                    match l155 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l156 = *ptr0.add(140).cast::<*mut u8>();
                                                let l157 = *ptr0.add(144).cast::<usize>();
                                                let len158 = l157;
                                                _rt::Vec::from_raw_parts(l156.cast(), len158, len158)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                )
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Returns whether or not the current message has a blob.
            pub fn has_blob() -> bool {
                unsafe {
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i32 {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    let ret = wit_import();
                    _rt::bool_lift(ret as u8)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Returns the blob of the current message, if any.
            pub fn get_blob() -> Option<LazyLoadBlob> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 24]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0);
                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                    match l1 {
                        0 => None,
                        1 => {
                            let e = {
                                let l2 = i32::from(*ptr0.add(4).cast::<u8>());
                                let l6 = *ptr0.add(16).cast::<*mut u8>();
                                let l7 = *ptr0.add(20).cast::<usize>();
                                let len8 = l7;
                                LazyLoadBlob {
                                    mime: match l2 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l3 = *ptr0.add(8).cast::<*mut u8>();
                                                let l4 = *ptr0.add(12).cast::<usize>();
                                                let len5 = l4;
                                                let bytes5 = _rt::Vec::from_raw_parts(
                                                    l3.cast(),
                                                    len5,
                                                    len5,
                                                );
                                                _rt::string_lift(bytes5)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    bytes: _rt::Vec::from_raw_parts(l6.cast(), len8, len8),
                                }
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Returns the last blob this process received.
            pub fn last_blob() -> Option<LazyLoadBlob> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 24]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0);
                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                    match l1 {
                        0 => None,
                        1 => {
                            let e = {
                                let l2 = i32::from(*ptr0.add(4).cast::<u8>());
                                let l6 = *ptr0.add(16).cast::<*mut u8>();
                                let l7 = *ptr0.add(20).cast::<usize>();
                                let len8 = l7;
                                LazyLoadBlob {
                                    mime: match l2 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l3 = *ptr0.add(8).cast::<*mut u8>();
                                                let l4 = *ptr0.add(12).cast::<usize>();
                                                let len5 = l4;
                                                let bytes5 = _rt::Vec::from_raw_parts(
                                                    l3.cast(),
                                                    len5,
                                                    len5,
                                                );
                                                _rt::string_lift(bytes5)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    bytes: _rt::Vec::from_raw_parts(l6.cast(), len8, len8),
                                }
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Send request to target.
            pub fn send_request(
                target: &Address,
                request: &Request,
                context: Option<&Context>,
                lazy_load_blob: Option<&LazyLoadBlob>,
            ) {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 128]);
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 128],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    let Address { node: node1, process: process1 } = target;
                    let vec2 = node1;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    *ptr0.add(4).cast::<usize>() = len2;
                    *ptr0.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    let ProcessId {
                        process_name: process_name3,
                        package_name: package_name3,
                        publisher_node: publisher_node3,
                    } = process1;
                    let vec4 = process_name3;
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    *ptr0.add(12).cast::<usize>() = len4;
                    *ptr0.add(8).cast::<*mut u8>() = ptr4.cast_mut();
                    let vec5 = package_name3;
                    let ptr5 = vec5.as_ptr().cast::<u8>();
                    let len5 = vec5.len();
                    *ptr0.add(20).cast::<usize>() = len5;
                    *ptr0.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                    let vec6 = publisher_node3;
                    let ptr6 = vec6.as_ptr().cast::<u8>();
                    let len6 = vec6.len();
                    *ptr0.add(28).cast::<usize>() = len6;
                    *ptr0.add(24).cast::<*mut u8>() = ptr6.cast_mut();
                    let Request {
                        inherit: inherit7,
                        expects_response: expects_response7,
                        body: body7,
                        metadata: metadata7,
                        capabilities: capabilities7,
                    } = request;
                    *ptr0.add(32).cast::<u8>() = (match inherit7 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    match expects_response7 {
                        Some(e) => {
                            *ptr0.add(40).cast::<u8>() = (1i32) as u8;
                            *ptr0.add(48).cast::<i64>() = _rt::as_i64(e);
                        }
                        None => {
                            *ptr0.add(40).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    let vec8 = body7;
                    let ptr8 = vec8.as_ptr().cast::<u8>();
                    let len8 = vec8.len();
                    *ptr0.add(60).cast::<usize>() = len8;
                    *ptr0.add(56).cast::<*mut u8>() = ptr8.cast_mut();
                    match metadata7 {
                        Some(e) => {
                            *ptr0.add(64).cast::<u8>() = (1i32) as u8;
                            let vec9 = e;
                            let ptr9 = vec9.as_ptr().cast::<u8>();
                            let len9 = vec9.len();
                            *ptr0.add(72).cast::<usize>() = len9;
                            *ptr0.add(68).cast::<*mut u8>() = ptr9.cast_mut();
                        }
                        None => {
                            *ptr0.add(64).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    let vec18 = capabilities7;
                    let len18 = vec18.len();
                    let layout18 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec18.len() * 40,
                        4,
                    );
                    let result18 = if layout18.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout18).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout18);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec18.into_iter().enumerate() {
                        let base = result18.add(i * 40);
                        {
                            let Capability { issuer: issuer10, params: params10 } = e;
                            let Address { node: node11, process: process11 } = issuer10;
                            let vec12 = node11;
                            let ptr12 = vec12.as_ptr().cast::<u8>();
                            let len12 = vec12.len();
                            *base.add(4).cast::<usize>() = len12;
                            *base.add(0).cast::<*mut u8>() = ptr12.cast_mut();
                            let ProcessId {
                                process_name: process_name13,
                                package_name: package_name13,
                                publisher_node: publisher_node13,
                            } = process11;
                            let vec14 = process_name13;
                            let ptr14 = vec14.as_ptr().cast::<u8>();
                            let len14 = vec14.len();
                            *base.add(12).cast::<usize>() = len14;
                            *base.add(8).cast::<*mut u8>() = ptr14.cast_mut();
                            let vec15 = package_name13;
                            let ptr15 = vec15.as_ptr().cast::<u8>();
                            let len15 = vec15.len();
                            *base.add(20).cast::<usize>() = len15;
                            *base.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                            let vec16 = publisher_node13;
                            let ptr16 = vec16.as_ptr().cast::<u8>();
                            let len16 = vec16.len();
                            *base.add(28).cast::<usize>() = len16;
                            *base.add(24).cast::<*mut u8>() = ptr16.cast_mut();
                            let vec17 = params10;
                            let ptr17 = vec17.as_ptr().cast::<u8>();
                            let len17 = vec17.len();
                            *base.add(36).cast::<usize>() = len17;
                            *base.add(32).cast::<*mut u8>() = ptr17.cast_mut();
                        }
                    }
                    *ptr0.add(80).cast::<usize>() = len18;
                    *ptr0.add(76).cast::<*mut u8>() = result18;
                    match context {
                        Some(e) => {
                            *ptr0.add(88).cast::<u8>() = (1i32) as u8;
                            let vec19 = e;
                            let ptr19 = vec19.as_ptr().cast::<u8>();
                            let len19 = vec19.len();
                            *ptr0.add(96).cast::<usize>() = len19;
                            *ptr0.add(92).cast::<*mut u8>() = ptr19.cast_mut();
                        }
                        None => {
                            *ptr0.add(88).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    match lazy_load_blob {
                        Some(e) => {
                            *ptr0.add(100).cast::<u8>() = (1i32) as u8;
                            let LazyLoadBlob { mime: mime20, bytes: bytes20 } = e;
                            match mime20 {
                                Some(e) => {
                                    *ptr0.add(104).cast::<u8>() = (1i32) as u8;
                                    let vec21 = e;
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    *ptr0.add(112).cast::<usize>() = len21;
                                    *ptr0.add(108).cast::<*mut u8>() = ptr21.cast_mut();
                                }
                                None => {
                                    *ptr0.add(104).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            let vec22 = bytes20;
                            let ptr22 = vec22.as_ptr().cast::<u8>();
                            let len22 = vec22.len();
                            *ptr0.add(120).cast::<usize>() = len22;
                            *ptr0.add(116).cast::<*mut u8>() = ptr22.cast_mut();
                        }
                        None => {
                            *ptr0.add(100).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0);
                    if layout18.size() != 0 {
                        _rt::alloc::dealloc(result18.cast(), layout18);
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Send requests to targets.
            pub fn send_requests(
                requests: &[(Address, Request, Option<Context>, Option<LazyLoadBlob>)],
            ) {
                unsafe {
                    let mut cleanup_list = _rt::Vec::new();
                    let vec23 = requests;
                    let len23 = vec23.len();
                    let layout23 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec23.len() * 128,
                        8,
                    );
                    let result23 = if layout23.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout23).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout23);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec23.into_iter().enumerate() {
                        let base = result23.add(i * 128);
                        {
                            let (t0_0, t0_1, t0_2, t0_3) = e;
                            let Address { node: node1, process: process1 } = t0_0;
                            let vec2 = node1;
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            *base.add(4).cast::<usize>() = len2;
                            *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                            let ProcessId {
                                process_name: process_name3,
                                package_name: package_name3,
                                publisher_node: publisher_node3,
                            } = process1;
                            let vec4 = process_name3;
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            *base.add(12).cast::<usize>() = len4;
                            *base.add(8).cast::<*mut u8>() = ptr4.cast_mut();
                            let vec5 = package_name3;
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            *base.add(20).cast::<usize>() = len5;
                            *base.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                            let vec6 = publisher_node3;
                            let ptr6 = vec6.as_ptr().cast::<u8>();
                            let len6 = vec6.len();
                            *base.add(28).cast::<usize>() = len6;
                            *base.add(24).cast::<*mut u8>() = ptr6.cast_mut();
                            let Request {
                                inherit: inherit7,
                                expects_response: expects_response7,
                                body: body7,
                                metadata: metadata7,
                                capabilities: capabilities7,
                            } = t0_1;
                            *base.add(32).cast::<u8>() = (match inherit7 {
                                true => 1,
                                false => 0,
                            }) as u8;
                            match expects_response7 {
                                Some(e) => {
                                    *base.add(40).cast::<u8>() = (1i32) as u8;
                                    *base.add(48).cast::<i64>() = _rt::as_i64(e);
                                }
                                None => {
                                    *base.add(40).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            let vec8 = body7;
                            let ptr8 = vec8.as_ptr().cast::<u8>();
                            let len8 = vec8.len();
                            *base.add(60).cast::<usize>() = len8;
                            *base.add(56).cast::<*mut u8>() = ptr8.cast_mut();
                            match metadata7 {
                                Some(e) => {
                                    *base.add(64).cast::<u8>() = (1i32) as u8;
                                    let vec9 = e;
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    *base.add(72).cast::<usize>() = len9;
                                    *base.add(68).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                None => {
                                    *base.add(64).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            let vec18 = capabilities7;
                            let len18 = vec18.len();
                            let layout18 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec18.len() * 40,
                                4,
                            );
                            let result18 = if layout18.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout18).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout18);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec18.into_iter().enumerate() {
                                let base = result18.add(i * 40);
                                {
                                    let Capability { issuer: issuer10, params: params10 } = e;
                                    let Address { node: node11, process: process11 } = issuer10;
                                    let vec12 = node11;
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    *base.add(4).cast::<usize>() = len12;
                                    *base.add(0).cast::<*mut u8>() = ptr12.cast_mut();
                                    let ProcessId {
                                        process_name: process_name13,
                                        package_name: package_name13,
                                        publisher_node: publisher_node13,
                                    } = process11;
                                    let vec14 = process_name13;
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    *base.add(12).cast::<usize>() = len14;
                                    *base.add(8).cast::<*mut u8>() = ptr14.cast_mut();
                                    let vec15 = package_name13;
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    *base.add(20).cast::<usize>() = len15;
                                    *base.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                    let vec16 = publisher_node13;
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    *base.add(28).cast::<usize>() = len16;
                                    *base.add(24).cast::<*mut u8>() = ptr16.cast_mut();
                                    let vec17 = params10;
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    *base.add(36).cast::<usize>() = len17;
                                    *base.add(32).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                            }
                            *base.add(80).cast::<usize>() = len18;
                            *base.add(76).cast::<*mut u8>() = result18;
                            match t0_2 {
                                Some(e) => {
                                    *base.add(88).cast::<u8>() = (1i32) as u8;
                                    let vec19 = e;
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    *base.add(96).cast::<usize>() = len19;
                                    *base.add(92).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                None => {
                                    *base.add(88).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            match t0_3 {
                                Some(e) => {
                                    *base.add(100).cast::<u8>() = (1i32) as u8;
                                    let LazyLoadBlob { mime: mime20, bytes: bytes20 } = e;
                                    match mime20 {
                                        Some(e) => {
                                            *base.add(104).cast::<u8>() = (1i32) as u8;
                                            let vec21 = e;
                                            let ptr21 = vec21.as_ptr().cast::<u8>();
                                            let len21 = vec21.len();
                                            *base.add(112).cast::<usize>() = len21;
                                            *base.add(108).cast::<*mut u8>() = ptr21.cast_mut();
                                        }
                                        None => {
                                            *base.add(104).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec22 = bytes20;
                                    let ptr22 = vec22.as_ptr().cast::<u8>();
                                    let len22 = vec22.len();
                                    *base.add(120).cast::<usize>() = len22;
                                    *base.add(116).cast::<*mut u8>() = ptr22.cast_mut();
                                }
                                None => {
                                    *base.add(100).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            cleanup_list.extend_from_slice(&[(result18, layout18)]);
                        }
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(result23, len23);
                    if layout23.size() != 0 {
                        _rt::alloc::dealloc(result23.cast(), layout23);
                    }
                    for (ptr, layout) in cleanup_list {
                        if layout.size() != 0 {
                            _rt::alloc::dealloc(ptr.cast(), layout);
                        }
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Send response to the request currently being handled.
            pub fn send_response(
                response: &Response,
                lazy_load_blob: Option<&LazyLoadBlob>,
            ) {
                unsafe {
                    let Response {
                        inherit: inherit0,
                        body: body0,
                        metadata: metadata0,
                        capabilities: capabilities0,
                    } = response;
                    let vec1 = body0;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let (result3_0, result3_1, result3_2) = match metadata0 {
                        Some(e) => {
                            let vec2 = e;
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            (1i32, ptr2.cast_mut(), len2)
                        }
                        None => (0i32, ::core::ptr::null_mut(), 0usize),
                    };
                    let vec12 = capabilities0;
                    let len12 = vec12.len();
                    let layout12 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec12.len() * 40,
                        4,
                    );
                    let result12 = if layout12.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout12).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout12);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec12.into_iter().enumerate() {
                        let base = result12.add(i * 40);
                        {
                            let Capability { issuer: issuer4, params: params4 } = e;
                            let Address { node: node5, process: process5 } = issuer4;
                            let vec6 = node5;
                            let ptr6 = vec6.as_ptr().cast::<u8>();
                            let len6 = vec6.len();
                            *base.add(4).cast::<usize>() = len6;
                            *base.add(0).cast::<*mut u8>() = ptr6.cast_mut();
                            let ProcessId {
                                process_name: process_name7,
                                package_name: package_name7,
                                publisher_node: publisher_node7,
                            } = process5;
                            let vec8 = process_name7;
                            let ptr8 = vec8.as_ptr().cast::<u8>();
                            let len8 = vec8.len();
                            *base.add(12).cast::<usize>() = len8;
                            *base.add(8).cast::<*mut u8>() = ptr8.cast_mut();
                            let vec9 = package_name7;
                            let ptr9 = vec9.as_ptr().cast::<u8>();
                            let len9 = vec9.len();
                            *base.add(20).cast::<usize>() = len9;
                            *base.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                            let vec10 = publisher_node7;
                            let ptr10 = vec10.as_ptr().cast::<u8>();
                            let len10 = vec10.len();
                            *base.add(28).cast::<usize>() = len10;
                            *base.add(24).cast::<*mut u8>() = ptr10.cast_mut();
                            let vec11 = params4;
                            let ptr11 = vec11.as_ptr().cast::<u8>();
                            let len11 = vec11.len();
                            *base.add(36).cast::<usize>() = len11;
                            *base.add(32).cast::<*mut u8>() = ptr11.cast_mut();
                        }
                    }
                    let (
                        result17_0,
                        result17_1,
                        result17_2,
                        result17_3,
                        result17_4,
                        result17_5,
                    ) = match lazy_load_blob {
                        Some(e) => {
                            let LazyLoadBlob { mime: mime13, bytes: bytes13 } = e;
                            let (result15_0, result15_1, result15_2) = match mime13 {
                                Some(e) => {
                                    let vec14 = e;
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    (1i32, ptr14.cast_mut(), len14)
                                }
                                None => (0i32, ::core::ptr::null_mut(), 0usize),
                            };
                            let vec16 = bytes13;
                            let ptr16 = vec16.as_ptr().cast::<u8>();
                            let len16 = vec16.len();
                            (
                                1i32,
                                result15_0,
                                result15_1,
                                result15_2,
                                ptr16.cast_mut(),
                                len16,
                            )
                        }
                        None => {
                            (
                                0i32,
                                0i32,
                                ::core::ptr::null_mut(),
                                0usize,
                                ::core::ptr::null_mut(),
                                0usize,
                            )
                        }
                    };
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: i32,
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                    ) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(
                        match inherit0 {
                            true => 1,
                            false => 0,
                        },
                        ptr1.cast_mut(),
                        len1,
                        result3_0,
                        result3_1,
                        result3_2,
                        result12,
                        len12,
                        result17_0,
                        result17_1,
                        result17_2,
                        result17_3,
                        result17_4,
                        result17_5,
                    );
                    if layout12.size() != 0 {
                        _rt::alloc::dealloc(result12.cast(), layout12);
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Send a single request, then block (internally) until its response. The
            /// type returned is Message but will always contain Response.
            pub fn send_and_await_response(
                target: &Address,
                request: &Request,
                lazy_load_blob: Option<&LazyLoadBlob>,
            ) -> Result<(Address, Message), SendError> {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 136]);
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 136],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    let Address { node: node1, process: process1 } = target;
                    let vec2 = node1;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    *ptr0.add(4).cast::<usize>() = len2;
                    *ptr0.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    let ProcessId {
                        process_name: process_name3,
                        package_name: package_name3,
                        publisher_node: publisher_node3,
                    } = process1;
                    let vec4 = process_name3;
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    *ptr0.add(12).cast::<usize>() = len4;
                    *ptr0.add(8).cast::<*mut u8>() = ptr4.cast_mut();
                    let vec5 = package_name3;
                    let ptr5 = vec5.as_ptr().cast::<u8>();
                    let len5 = vec5.len();
                    *ptr0.add(20).cast::<usize>() = len5;
                    *ptr0.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                    let vec6 = publisher_node3;
                    let ptr6 = vec6.as_ptr().cast::<u8>();
                    let len6 = vec6.len();
                    *ptr0.add(28).cast::<usize>() = len6;
                    *ptr0.add(24).cast::<*mut u8>() = ptr6.cast_mut();
                    let Request {
                        inherit: inherit7,
                        expects_response: expects_response7,
                        body: body7,
                        metadata: metadata7,
                        capabilities: capabilities7,
                    } = request;
                    *ptr0.add(32).cast::<u8>() = (match inherit7 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    match expects_response7 {
                        Some(e) => {
                            *ptr0.add(40).cast::<u8>() = (1i32) as u8;
                            *ptr0.add(48).cast::<i64>() = _rt::as_i64(e);
                        }
                        None => {
                            *ptr0.add(40).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    let vec8 = body7;
                    let ptr8 = vec8.as_ptr().cast::<u8>();
                    let len8 = vec8.len();
                    *ptr0.add(60).cast::<usize>() = len8;
                    *ptr0.add(56).cast::<*mut u8>() = ptr8.cast_mut();
                    match metadata7 {
                        Some(e) => {
                            *ptr0.add(64).cast::<u8>() = (1i32) as u8;
                            let vec9 = e;
                            let ptr9 = vec9.as_ptr().cast::<u8>();
                            let len9 = vec9.len();
                            *ptr0.add(72).cast::<usize>() = len9;
                            *ptr0.add(68).cast::<*mut u8>() = ptr9.cast_mut();
                        }
                        None => {
                            *ptr0.add(64).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    let vec18 = capabilities7;
                    let len18 = vec18.len();
                    let layout18 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec18.len() * 40,
                        4,
                    );
                    let result18 = if layout18.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout18).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout18);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec18.into_iter().enumerate() {
                        let base = result18.add(i * 40);
                        {
                            let Capability { issuer: issuer10, params: params10 } = e;
                            let Address { node: node11, process: process11 } = issuer10;
                            let vec12 = node11;
                            let ptr12 = vec12.as_ptr().cast::<u8>();
                            let len12 = vec12.len();
                            *base.add(4).cast::<usize>() = len12;
                            *base.add(0).cast::<*mut u8>() = ptr12.cast_mut();
                            let ProcessId {
                                process_name: process_name13,
                                package_name: package_name13,
                                publisher_node: publisher_node13,
                            } = process11;
                            let vec14 = process_name13;
                            let ptr14 = vec14.as_ptr().cast::<u8>();
                            let len14 = vec14.len();
                            *base.add(12).cast::<usize>() = len14;
                            *base.add(8).cast::<*mut u8>() = ptr14.cast_mut();
                            let vec15 = package_name13;
                            let ptr15 = vec15.as_ptr().cast::<u8>();
                            let len15 = vec15.len();
                            *base.add(20).cast::<usize>() = len15;
                            *base.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                            let vec16 = publisher_node13;
                            let ptr16 = vec16.as_ptr().cast::<u8>();
                            let len16 = vec16.len();
                            *base.add(28).cast::<usize>() = len16;
                            *base.add(24).cast::<*mut u8>() = ptr16.cast_mut();
                            let vec17 = params10;
                            let ptr17 = vec17.as_ptr().cast::<u8>();
                            let len17 = vec17.len();
                            *base.add(36).cast::<usize>() = len17;
                            *base.add(32).cast::<*mut u8>() = ptr17.cast_mut();
                        }
                    }
                    *ptr0.add(80).cast::<usize>() = len18;
                    *ptr0.add(76).cast::<*mut u8>() = result18;
                    match lazy_load_blob {
                        Some(e) => {
                            *ptr0.add(88).cast::<u8>() = (1i32) as u8;
                            let LazyLoadBlob { mime: mime19, bytes: bytes19 } = e;
                            match mime19 {
                                Some(e) => {
                                    *ptr0.add(92).cast::<u8>() = (1i32) as u8;
                                    let vec20 = e;
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    *ptr0.add(100).cast::<usize>() = len20;
                                    *ptr0.add(96).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                None => {
                                    *ptr0.add(92).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            let vec21 = bytes19;
                            let ptr21 = vec21.as_ptr().cast::<u8>();
                            let len21 = vec21.len();
                            *ptr0.add(108).cast::<usize>() = len21;
                            *ptr0.add(104).cast::<*mut u8>() = ptr21.cast_mut();
                        }
                        None => {
                            *ptr0.add(88).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    let ptr22 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0, ptr22);
                    let l23 = i32::from(*ptr22.add(0).cast::<u8>());
                    if layout18.size() != 0 {
                        _rt::alloc::dealloc(result18.cast(), layout18);
                    }
                    match l23 {
                        0 => {
                            let e = {
                                let l24 = *ptr22.add(8).cast::<*mut u8>();
                                let l25 = *ptr22.add(12).cast::<usize>();
                                let len26 = l25;
                                let bytes26 = _rt::Vec::from_raw_parts(
                                    l24.cast(),
                                    len26,
                                    len26,
                                );
                                let l27 = *ptr22.add(16).cast::<*mut u8>();
                                let l28 = *ptr22.add(20).cast::<usize>();
                                let len29 = l28;
                                let bytes29 = _rt::Vec::from_raw_parts(
                                    l27.cast(),
                                    len29,
                                    len29,
                                );
                                let l30 = *ptr22.add(24).cast::<*mut u8>();
                                let l31 = *ptr22.add(28).cast::<usize>();
                                let len32 = l31;
                                let bytes32 = _rt::Vec::from_raw_parts(
                                    l30.cast(),
                                    len32,
                                    len32,
                                );
                                let l33 = *ptr22.add(32).cast::<*mut u8>();
                                let l34 = *ptr22.add(36).cast::<usize>();
                                let len35 = l34;
                                let bytes35 = _rt::Vec::from_raw_parts(
                                    l33.cast(),
                                    len35,
                                    len35,
                                );
                                let l36 = i32::from(*ptr22.add(40).cast::<u8>());
                                let v95 = match l36 {
                                    0 => {
                                        let e95 = {
                                            let l37 = i32::from(*ptr22.add(48).cast::<u8>());
                                            let l38 = i32::from(*ptr22.add(56).cast::<u8>());
                                            let l40 = *ptr22.add(72).cast::<*mut u8>();
                                            let l41 = *ptr22.add(76).cast::<usize>();
                                            let len42 = l41;
                                            let l43 = i32::from(*ptr22.add(80).cast::<u8>());
                                            let l47 = *ptr22.add(92).cast::<*mut u8>();
                                            let l48 = *ptr22.add(96).cast::<usize>();
                                            let base64 = l47;
                                            let len64 = l48;
                                            let mut result64 = _rt::Vec::with_capacity(len64);
                                            for i in 0..len64 {
                                                let base = base64.add(i * 40);
                                                let e64 = {
                                                    let l49 = *base.add(0).cast::<*mut u8>();
                                                    let l50 = *base.add(4).cast::<usize>();
                                                    let len51 = l50;
                                                    let bytes51 = _rt::Vec::from_raw_parts(
                                                        l49.cast(),
                                                        len51,
                                                        len51,
                                                    );
                                                    let l52 = *base.add(8).cast::<*mut u8>();
                                                    let l53 = *base.add(12).cast::<usize>();
                                                    let len54 = l53;
                                                    let bytes54 = _rt::Vec::from_raw_parts(
                                                        l52.cast(),
                                                        len54,
                                                        len54,
                                                    );
                                                    let l55 = *base.add(16).cast::<*mut u8>();
                                                    let l56 = *base.add(20).cast::<usize>();
                                                    let len57 = l56;
                                                    let bytes57 = _rt::Vec::from_raw_parts(
                                                        l55.cast(),
                                                        len57,
                                                        len57,
                                                    );
                                                    let l58 = *base.add(24).cast::<*mut u8>();
                                                    let l59 = *base.add(28).cast::<usize>();
                                                    let len60 = l59;
                                                    let bytes60 = _rt::Vec::from_raw_parts(
                                                        l58.cast(),
                                                        len60,
                                                        len60,
                                                    );
                                                    let l61 = *base.add(32).cast::<*mut u8>();
                                                    let l62 = *base.add(36).cast::<usize>();
                                                    let len63 = l62;
                                                    let bytes63 = _rt::Vec::from_raw_parts(
                                                        l61.cast(),
                                                        len63,
                                                        len63,
                                                    );
                                                    Capability {
                                                        issuer: Address {
                                                            node: _rt::string_lift(bytes51),
                                                            process: ProcessId {
                                                                process_name: _rt::string_lift(bytes54),
                                                                package_name: _rt::string_lift(bytes57),
                                                                publisher_node: _rt::string_lift(bytes60),
                                                            },
                                                        },
                                                        params: _rt::string_lift(bytes63),
                                                    }
                                                };
                                                result64.push(e64);
                                            }
                                            _rt::cabi_dealloc(base64, len64 * 40, 4);
                                            Request {
                                                inherit: _rt::bool_lift(l37 as u8),
                                                expects_response: match l38 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l39 = *ptr22.add(64).cast::<i64>();
                                                            l39 as u64
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                body: _rt::Vec::from_raw_parts(l40.cast(), len42, len42),
                                                metadata: match l43 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l44 = *ptr22.add(84).cast::<*mut u8>();
                                                            let l45 = *ptr22.add(88).cast::<usize>();
                                                            let len46 = l45;
                                                            let bytes46 = _rt::Vec::from_raw_parts(
                                                                l44.cast(),
                                                                len46,
                                                                len46,
                                                            );
                                                            _rt::string_lift(bytes46)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                capabilities: result64,
                                            }
                                        };
                                        Message::Request(e95)
                                    }
                                    n => {
                                        if true {
                                            match (&n, &1) {
                                                (left_val, right_val) => {
                                                    if !(*left_val == *right_val) {
                                                        let kind = ::core::panicking::AssertKind::Eq;
                                                        ::core::panicking::assert_failed(
                                                            kind,
                                                            &*left_val,
                                                            &*right_val,
                                                            ::core::option::Option::Some(
                                                                format_args!("invalid enum discriminant"),
                                                            ),
                                                        );
                                                    }
                                                }
                                            };
                                        }
                                        let e95 = {
                                            let l65 = i32::from(*ptr22.add(48).cast::<u8>());
                                            let l66 = *ptr22.add(52).cast::<*mut u8>();
                                            let l67 = *ptr22.add(56).cast::<usize>();
                                            let len68 = l67;
                                            let l69 = i32::from(*ptr22.add(60).cast::<u8>());
                                            let l73 = *ptr22.add(72).cast::<*mut u8>();
                                            let l74 = *ptr22.add(76).cast::<usize>();
                                            let base90 = l73;
                                            let len90 = l74;
                                            let mut result90 = _rt::Vec::with_capacity(len90);
                                            for i in 0..len90 {
                                                let base = base90.add(i * 40);
                                                let e90 = {
                                                    let l75 = *base.add(0).cast::<*mut u8>();
                                                    let l76 = *base.add(4).cast::<usize>();
                                                    let len77 = l76;
                                                    let bytes77 = _rt::Vec::from_raw_parts(
                                                        l75.cast(),
                                                        len77,
                                                        len77,
                                                    );
                                                    let l78 = *base.add(8).cast::<*mut u8>();
                                                    let l79 = *base.add(12).cast::<usize>();
                                                    let len80 = l79;
                                                    let bytes80 = _rt::Vec::from_raw_parts(
                                                        l78.cast(),
                                                        len80,
                                                        len80,
                                                    );
                                                    let l81 = *base.add(16).cast::<*mut u8>();
                                                    let l82 = *base.add(20).cast::<usize>();
                                                    let len83 = l82;
                                                    let bytes83 = _rt::Vec::from_raw_parts(
                                                        l81.cast(),
                                                        len83,
                                                        len83,
                                                    );
                                                    let l84 = *base.add(24).cast::<*mut u8>();
                                                    let l85 = *base.add(28).cast::<usize>();
                                                    let len86 = l85;
                                                    let bytes86 = _rt::Vec::from_raw_parts(
                                                        l84.cast(),
                                                        len86,
                                                        len86,
                                                    );
                                                    let l87 = *base.add(32).cast::<*mut u8>();
                                                    let l88 = *base.add(36).cast::<usize>();
                                                    let len89 = l88;
                                                    let bytes89 = _rt::Vec::from_raw_parts(
                                                        l87.cast(),
                                                        len89,
                                                        len89,
                                                    );
                                                    Capability {
                                                        issuer: Address {
                                                            node: _rt::string_lift(bytes77),
                                                            process: ProcessId {
                                                                process_name: _rt::string_lift(bytes80),
                                                                package_name: _rt::string_lift(bytes83),
                                                                publisher_node: _rt::string_lift(bytes86),
                                                            },
                                                        },
                                                        params: _rt::string_lift(bytes89),
                                                    }
                                                };
                                                result90.push(e90);
                                            }
                                            _rt::cabi_dealloc(base90, len90 * 40, 4);
                                            let l91 = i32::from(*ptr22.add(80).cast::<u8>());
                                            (
                                                Response {
                                                    inherit: _rt::bool_lift(l65 as u8),
                                                    body: _rt::Vec::from_raw_parts(l66.cast(), len68, len68),
                                                    metadata: match l69 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l70 = *ptr22.add(64).cast::<*mut u8>();
                                                                let l71 = *ptr22.add(68).cast::<usize>();
                                                                let len72 = l71;
                                                                let bytes72 = _rt::Vec::from_raw_parts(
                                                                    l70.cast(),
                                                                    len72,
                                                                    len72,
                                                                );
                                                                _rt::string_lift(bytes72)
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                    capabilities: result90,
                                                },
                                                match l91 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l92 = *ptr22.add(84).cast::<*mut u8>();
                                                            let l93 = *ptr22.add(88).cast::<usize>();
                                                            let len94 = l93;
                                                            _rt::Vec::from_raw_parts(l92.cast(), len94, len94)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                            )
                                        };
                                        Message::Response(e95)
                                    }
                                };
                                (
                                    Address {
                                        node: _rt::string_lift(bytes26),
                                        process: ProcessId {
                                            process_name: _rt::string_lift(bytes29),
                                            package_name: _rt::string_lift(bytes32),
                                            publisher_node: _rt::string_lift(bytes35),
                                        },
                                    },
                                    v95,
                                )
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l96 = i32::from(*ptr22.add(8).cast::<u8>());
                                let l97 = *ptr22.add(12).cast::<*mut u8>();
                                let l98 = *ptr22.add(16).cast::<usize>();
                                let len99 = l98;
                                let bytes99 = _rt::Vec::from_raw_parts(
                                    l97.cast(),
                                    len99,
                                    len99,
                                );
                                let l100 = *ptr22.add(20).cast::<*mut u8>();
                                let l101 = *ptr22.add(24).cast::<usize>();
                                let len102 = l101;
                                let bytes102 = _rt::Vec::from_raw_parts(
                                    l100.cast(),
                                    len102,
                                    len102,
                                );
                                let l103 = *ptr22.add(28).cast::<*mut u8>();
                                let l104 = *ptr22.add(32).cast::<usize>();
                                let len105 = l104;
                                let bytes105 = _rt::Vec::from_raw_parts(
                                    l103.cast(),
                                    len105,
                                    len105,
                                );
                                let l106 = *ptr22.add(36).cast::<*mut u8>();
                                let l107 = *ptr22.add(40).cast::<usize>();
                                let len108 = l107;
                                let bytes108 = _rt::Vec::from_raw_parts(
                                    l106.cast(),
                                    len108,
                                    len108,
                                );
                                let l109 = i32::from(*ptr22.add(48).cast::<u8>());
                                let v168 = match l109 {
                                    0 => {
                                        let e168 = {
                                            let l110 = i32::from(*ptr22.add(56).cast::<u8>());
                                            let l111 = i32::from(*ptr22.add(64).cast::<u8>());
                                            let l113 = *ptr22.add(80).cast::<*mut u8>();
                                            let l114 = *ptr22.add(84).cast::<usize>();
                                            let len115 = l114;
                                            let l116 = i32::from(*ptr22.add(88).cast::<u8>());
                                            let l120 = *ptr22.add(100).cast::<*mut u8>();
                                            let l121 = *ptr22.add(104).cast::<usize>();
                                            let base137 = l120;
                                            let len137 = l121;
                                            let mut result137 = _rt::Vec::with_capacity(len137);
                                            for i in 0..len137 {
                                                let base = base137.add(i * 40);
                                                let e137 = {
                                                    let l122 = *base.add(0).cast::<*mut u8>();
                                                    let l123 = *base.add(4).cast::<usize>();
                                                    let len124 = l123;
                                                    let bytes124 = _rt::Vec::from_raw_parts(
                                                        l122.cast(),
                                                        len124,
                                                        len124,
                                                    );
                                                    let l125 = *base.add(8).cast::<*mut u8>();
                                                    let l126 = *base.add(12).cast::<usize>();
                                                    let len127 = l126;
                                                    let bytes127 = _rt::Vec::from_raw_parts(
                                                        l125.cast(),
                                                        len127,
                                                        len127,
                                                    );
                                                    let l128 = *base.add(16).cast::<*mut u8>();
                                                    let l129 = *base.add(20).cast::<usize>();
                                                    let len130 = l129;
                                                    let bytes130 = _rt::Vec::from_raw_parts(
                                                        l128.cast(),
                                                        len130,
                                                        len130,
                                                    );
                                                    let l131 = *base.add(24).cast::<*mut u8>();
                                                    let l132 = *base.add(28).cast::<usize>();
                                                    let len133 = l132;
                                                    let bytes133 = _rt::Vec::from_raw_parts(
                                                        l131.cast(),
                                                        len133,
                                                        len133,
                                                    );
                                                    let l134 = *base.add(32).cast::<*mut u8>();
                                                    let l135 = *base.add(36).cast::<usize>();
                                                    let len136 = l135;
                                                    let bytes136 = _rt::Vec::from_raw_parts(
                                                        l134.cast(),
                                                        len136,
                                                        len136,
                                                    );
                                                    Capability {
                                                        issuer: Address {
                                                            node: _rt::string_lift(bytes124),
                                                            process: ProcessId {
                                                                process_name: _rt::string_lift(bytes127),
                                                                package_name: _rt::string_lift(bytes130),
                                                                publisher_node: _rt::string_lift(bytes133),
                                                            },
                                                        },
                                                        params: _rt::string_lift(bytes136),
                                                    }
                                                };
                                                result137.push(e137);
                                            }
                                            _rt::cabi_dealloc(base137, len137 * 40, 4);
                                            Request {
                                                inherit: _rt::bool_lift(l110 as u8),
                                                expects_response: match l111 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l112 = *ptr22.add(72).cast::<i64>();
                                                            l112 as u64
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                body: _rt::Vec::from_raw_parts(l113.cast(), len115, len115),
                                                metadata: match l116 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l117 = *ptr22.add(92).cast::<*mut u8>();
                                                            let l118 = *ptr22.add(96).cast::<usize>();
                                                            let len119 = l118;
                                                            let bytes119 = _rt::Vec::from_raw_parts(
                                                                l117.cast(),
                                                                len119,
                                                                len119,
                                                            );
                                                            _rt::string_lift(bytes119)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                capabilities: result137,
                                            }
                                        };
                                        Message::Request(e168)
                                    }
                                    n => {
                                        if true {
                                            match (&n, &1) {
                                                (left_val, right_val) => {
                                                    if !(*left_val == *right_val) {
                                                        let kind = ::core::panicking::AssertKind::Eq;
                                                        ::core::panicking::assert_failed(
                                                            kind,
                                                            &*left_val,
                                                            &*right_val,
                                                            ::core::option::Option::Some(
                                                                format_args!("invalid enum discriminant"),
                                                            ),
                                                        );
                                                    }
                                                }
                                            };
                                        }
                                        let e168 = {
                                            let l138 = i32::from(*ptr22.add(56).cast::<u8>());
                                            let l139 = *ptr22.add(60).cast::<*mut u8>();
                                            let l140 = *ptr22.add(64).cast::<usize>();
                                            let len141 = l140;
                                            let l142 = i32::from(*ptr22.add(68).cast::<u8>());
                                            let l146 = *ptr22.add(80).cast::<*mut u8>();
                                            let l147 = *ptr22.add(84).cast::<usize>();
                                            let base163 = l146;
                                            let len163 = l147;
                                            let mut result163 = _rt::Vec::with_capacity(len163);
                                            for i in 0..len163 {
                                                let base = base163.add(i * 40);
                                                let e163 = {
                                                    let l148 = *base.add(0).cast::<*mut u8>();
                                                    let l149 = *base.add(4).cast::<usize>();
                                                    let len150 = l149;
                                                    let bytes150 = _rt::Vec::from_raw_parts(
                                                        l148.cast(),
                                                        len150,
                                                        len150,
                                                    );
                                                    let l151 = *base.add(8).cast::<*mut u8>();
                                                    let l152 = *base.add(12).cast::<usize>();
                                                    let len153 = l152;
                                                    let bytes153 = _rt::Vec::from_raw_parts(
                                                        l151.cast(),
                                                        len153,
                                                        len153,
                                                    );
                                                    let l154 = *base.add(16).cast::<*mut u8>();
                                                    let l155 = *base.add(20).cast::<usize>();
                                                    let len156 = l155;
                                                    let bytes156 = _rt::Vec::from_raw_parts(
                                                        l154.cast(),
                                                        len156,
                                                        len156,
                                                    );
                                                    let l157 = *base.add(24).cast::<*mut u8>();
                                                    let l158 = *base.add(28).cast::<usize>();
                                                    let len159 = l158;
                                                    let bytes159 = _rt::Vec::from_raw_parts(
                                                        l157.cast(),
                                                        len159,
                                                        len159,
                                                    );
                                                    let l160 = *base.add(32).cast::<*mut u8>();
                                                    let l161 = *base.add(36).cast::<usize>();
                                                    let len162 = l161;
                                                    let bytes162 = _rt::Vec::from_raw_parts(
                                                        l160.cast(),
                                                        len162,
                                                        len162,
                                                    );
                                                    Capability {
                                                        issuer: Address {
                                                            node: _rt::string_lift(bytes150),
                                                            process: ProcessId {
                                                                process_name: _rt::string_lift(bytes153),
                                                                package_name: _rt::string_lift(bytes156),
                                                                publisher_node: _rt::string_lift(bytes159),
                                                            },
                                                        },
                                                        params: _rt::string_lift(bytes162),
                                                    }
                                                };
                                                result163.push(e163);
                                            }
                                            _rt::cabi_dealloc(base163, len163 * 40, 4);
                                            let l164 = i32::from(*ptr22.add(88).cast::<u8>());
                                            (
                                                Response {
                                                    inherit: _rt::bool_lift(l138 as u8),
                                                    body: _rt::Vec::from_raw_parts(l139.cast(), len141, len141),
                                                    metadata: match l142 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l143 = *ptr22.add(72).cast::<*mut u8>();
                                                                let l144 = *ptr22.add(76).cast::<usize>();
                                                                let len145 = l144;
                                                                let bytes145 = _rt::Vec::from_raw_parts(
                                                                    l143.cast(),
                                                                    len145,
                                                                    len145,
                                                                );
                                                                _rt::string_lift(bytes145)
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                    capabilities: result163,
                                                },
                                                match l164 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l165 = *ptr22.add(92).cast::<*mut u8>();
                                                            let l166 = *ptr22.add(96).cast::<usize>();
                                                            let len167 = l166;
                                                            _rt::Vec::from_raw_parts(l165.cast(), len167, len167)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                            )
                                        };
                                        Message::Response(e168)
                                    }
                                };
                                let l169 = i32::from(*ptr22.add(112).cast::<u8>());
                                SendError {
                                    kind: SendErrorKind::_lift(l96 as u8),
                                    target: Address {
                                        node: _rt::string_lift(bytes99),
                                        process: ProcessId {
                                            process_name: _rt::string_lift(bytes102),
                                            package_name: _rt::string_lift(bytes105),
                                            publisher_node: _rt::string_lift(bytes108),
                                        },
                                    },
                                    message: v168,
                                    lazy_load_blob: match l169 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l170 = i32::from(*ptr22.add(116).cast::<u8>());
                                                let l174 = *ptr22.add(128).cast::<*mut u8>();
                                                let l175 = *ptr22.add(132).cast::<usize>();
                                                let len176 = l175;
                                                LazyLoadBlob {
                                                    mime: match l170 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l171 = *ptr22.add(120).cast::<*mut u8>();
                                                                let l172 = *ptr22.add(124).cast::<usize>();
                                                                let len173 = l172;
                                                                let bytes173 = _rt::Vec::from_raw_parts(
                                                                    l171.cast(),
                                                                    len173,
                                                                    len173,
                                                                );
                                                                _rt::string_lift(bytes173)
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                    bytes: _rt::Vec::from_raw_parts(l174.cast(), len176, len176),
                                                }
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                }
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    }
                }
            }
        }
        #[allow(dead_code, clippy::all)]
        pub mod voice {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Address = super::super::super::hyperware::process::standard::Address;
            pub struct ChatMessage {
                pub id: _rt::String,
                pub sender_id: _rt::String,
                pub sender_name: _rt::String,
                pub content: _rt::String,
                pub timestamp: u64,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ChatMessage {
                #[inline]
                fn clone(&self) -> ChatMessage {
                    ChatMessage {
                        id: ::core::clone::Clone::clone(&self.id),
                        sender_id: ::core::clone::Clone::clone(&self.sender_id),
                        sender_name: ::core::clone::Clone::clone(&self.sender_name),
                        content: ::core::clone::Clone::clone(&self.content),
                        timestamp: ::core::clone::Clone::clone(&self.timestamp),
                    }
                }
            }
            impl From<ChatMessage> for Vec<u8> {
                fn from(value: ChatMessage) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a ChatMessage> for Vec<u8> {
                fn from(value: &'a ChatMessage) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for ChatMessage {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for ChatMessage {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ChatMessage {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "id" => _serde::__private::Ok(__Field::__field0),
                                    "sender_id" => _serde::__private::Ok(__Field::__field1),
                                    "sender_name" => _serde::__private::Ok(__Field::__field2),
                                    "content" => _serde::__private::Ok(__Field::__field3),
                                    "timestamp" => _serde::__private::Ok(__Field::__field4),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"id" => _serde::__private::Ok(__Field::__field0),
                                    b"sender_id" => _serde::__private::Ok(__Field::__field1),
                                    b"sender_name" => _serde::__private::Ok(__Field::__field2),
                                    b"content" => _serde::__private::Ok(__Field::__field3),
                                    b"timestamp" => _serde::__private::Ok(__Field::__field4),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<ChatMessage>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ChatMessage;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ChatMessage",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ChatMessage with 5 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ChatMessage with 5 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct ChatMessage with 5 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct ChatMessage with 5 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field4 = match _serde::de::SeqAccess::next_element::<
                                    u64,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                4usize,
                                                &"struct ChatMessage with 5 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(ChatMessage {
                                    id: __field0,
                                    sender_id: __field1,
                                    sender_name: __field2,
                                    content: __field3,
                                    timestamp: __field4,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field4: _serde::__private::Option<u64> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "sender_id",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "sender_name",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "content",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field4 => {
                                            if _serde::__private::Option::is_some(&__field4) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "timestamp",
                                                    ),
                                                );
                                            }
                                            __field4 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("id")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("sender_id")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("sender_name")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("content")?
                                    }
                                };
                                let __field4 = match __field4 {
                                    _serde::__private::Some(__field4) => __field4,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("timestamp")?
                                    }
                                };
                                _serde::__private::Ok(ChatMessage {
                                    id: __field0,
                                    sender_id: __field1,
                                    sender_name: __field2,
                                    content: __field3,
                                    timestamp: __field4,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "id",
                            "sender_id",
                            "sender_name",
                            "content",
                            "timestamp",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ChatMessage",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<ChatMessage>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ChatMessage {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "ChatMessage",
                            false as usize + 1 + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "id",
                            &self.id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "sender_id",
                            &self.sender_id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "sender_name",
                            &self.sender_name,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "content",
                            &self.content,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "timestamp",
                            &self.timestamp,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for ChatMessage {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ChatMessage")
                        .field("id", &self.id)
                        .field("sender-id", &self.sender_id)
                        .field("sender-name", &self.sender_name)
                        .field("content", &self.content)
                        .field("timestamp", &self.timestamp)
                        .finish()
                }
            }
            pub struct JoinCallReq {
                pub call_id: _rt::String,
                pub node_auth: Option<_rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for JoinCallReq {
                #[inline]
                fn clone(&self) -> JoinCallReq {
                    JoinCallReq {
                        call_id: ::core::clone::Clone::clone(&self.call_id),
                        node_auth: ::core::clone::Clone::clone(&self.node_auth),
                    }
                }
            }
            impl From<JoinCallReq> for Vec<u8> {
                fn from(value: JoinCallReq) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a JoinCallReq> for Vec<u8> {
                fn from(value: &'a JoinCallReq) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for JoinCallReq {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for JoinCallReq {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for JoinCallReq {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "call_id" => _serde::__private::Ok(__Field::__field0),
                                    "node_auth" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"call_id" => _serde::__private::Ok(__Field::__field0),
                                    b"node_auth" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<JoinCallReq>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = JoinCallReq;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct JoinCallReq",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct JoinCallReq with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Option<_rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct JoinCallReq with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(JoinCallReq {
                                    call_id: __field0,
                                    node_auth: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    Option<_rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "call_id",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "node_auth",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<_rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("call_id")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("node_auth")?
                                    }
                                };
                                _serde::__private::Ok(JoinCallReq {
                                    call_id: __field0,
                                    node_auth: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "call_id",
                            "node_auth",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "JoinCallReq",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<JoinCallReq>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for JoinCallReq {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "JoinCallReq",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "call_id",
                            &self.call_id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "node_auth",
                            &self.node_auth,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for JoinCallReq {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("JoinCallReq")
                        .field("call-id", &self.call_id)
                        .field("node-auth", &self.node_auth)
                        .finish()
                }
            }
            pub struct LeaveCallReq {
                pub call_id: _rt::String,
                pub participant_id: _rt::String,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for LeaveCallReq {
                #[inline]
                fn clone(&self) -> LeaveCallReq {
                    LeaveCallReq {
                        call_id: ::core::clone::Clone::clone(&self.call_id),
                        participant_id: ::core::clone::Clone::clone(&self.participant_id),
                    }
                }
            }
            impl From<LeaveCallReq> for Vec<u8> {
                fn from(value: LeaveCallReq) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a LeaveCallReq> for Vec<u8> {
                fn from(value: &'a LeaveCallReq) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for LeaveCallReq {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for LeaveCallReq {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for LeaveCallReq {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "call_id" => _serde::__private::Ok(__Field::__field0),
                                    "participant_id" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"call_id" => _serde::__private::Ok(__Field::__field0),
                                    b"participant_id" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<LeaveCallReq>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = LeaveCallReq;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct LeaveCallReq",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct LeaveCallReq with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct LeaveCallReq with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(LeaveCallReq {
                                    call_id: __field0,
                                    participant_id: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "call_id",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "participant_id",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("call_id")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("participant_id")?
                                    }
                                };
                                _serde::__private::Ok(LeaveCallReq {
                                    call_id: __field0,
                                    participant_id: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "call_id",
                            "participant_id",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "LeaveCallReq",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<LeaveCallReq>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for LeaveCallReq {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "LeaveCallReq",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "call_id",
                            &self.call_id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "participant_id",
                            &self.participant_id,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for LeaveCallReq {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("LeaveCallReq")
                        .field("call-id", &self.call_id)
                        .field("participant-id", &self.participant_id)
                        .finish()
                }
            }
            pub struct NodeHandshakeReq {
                pub call_id: _rt::String,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for NodeHandshakeReq {
                #[inline]
                fn clone(&self) -> NodeHandshakeReq {
                    NodeHandshakeReq {
                        call_id: ::core::clone::Clone::clone(&self.call_id),
                    }
                }
            }
            impl From<NodeHandshakeReq> for Vec<u8> {
                fn from(value: NodeHandshakeReq) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a NodeHandshakeReq> for Vec<u8> {
                fn from(value: &'a NodeHandshakeReq) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for NodeHandshakeReq {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for NodeHandshakeReq {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for NodeHandshakeReq {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "call_id" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"call_id" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<NodeHandshakeReq>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = NodeHandshakeReq;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct NodeHandshakeReq",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct NodeHandshakeReq with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(NodeHandshakeReq {
                                    call_id: __field0,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "call_id",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("call_id")?
                                    }
                                };
                                _serde::__private::Ok(NodeHandshakeReq {
                                    call_id: __field0,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["call_id"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "NodeHandshakeReq",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<NodeHandshakeReq>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for NodeHandshakeReq {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "NodeHandshakeReq",
                            false as usize + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "call_id",
                            &self.call_id,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for NodeHandshakeReq {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("NodeHandshakeReq")
                        .field("call-id", &self.call_id)
                        .finish()
                }
            }
            pub struct NodeHandshakeResp {
                pub auth_token: _rt::String,
                pub redirect_url: _rt::String,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for NodeHandshakeResp {
                #[inline]
                fn clone(&self) -> NodeHandshakeResp {
                    NodeHandshakeResp {
                        auth_token: ::core::clone::Clone::clone(&self.auth_token),
                        redirect_url: ::core::clone::Clone::clone(&self.redirect_url),
                    }
                }
            }
            impl From<NodeHandshakeResp> for Vec<u8> {
                fn from(value: NodeHandshakeResp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a NodeHandshakeResp> for Vec<u8> {
                fn from(value: &'a NodeHandshakeResp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for NodeHandshakeResp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for NodeHandshakeResp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for NodeHandshakeResp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "auth_token" => _serde::__private::Ok(__Field::__field0),
                                    "redirect_url" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"auth_token" => _serde::__private::Ok(__Field::__field0),
                                    b"redirect_url" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<NodeHandshakeResp>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = NodeHandshakeResp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct NodeHandshakeResp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct NodeHandshakeResp with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct NodeHandshakeResp with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(NodeHandshakeResp {
                                    auth_token: __field0,
                                    redirect_url: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "auth_token",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "redirect_url",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("auth_token")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("redirect_url")?
                                    }
                                };
                                _serde::__private::Ok(NodeHandshakeResp {
                                    auth_token: __field0,
                                    redirect_url: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "auth_token",
                            "redirect_url",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "NodeHandshakeResp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<NodeHandshakeResp>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for NodeHandshakeResp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "NodeHandshakeResp",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "auth_token",
                            &self.auth_token,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "redirect_url",
                            &self.redirect_url,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for NodeHandshakeResp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("NodeHandshakeResp")
                        .field("auth-token", &self.auth_token)
                        .field("redirect-url", &self.redirect_url)
                        .finish()
                }
            }
            pub enum Role {
                Listener,
                Chatter,
                Speaker,
                Admin,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Role {
                #[inline]
                fn clone(&self) -> Role {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Role {}
            impl From<Role> for Vec<u8> {
                fn from(value: Role) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a Role> for Vec<u8> {
                fn from(value: &'a Role) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for Role {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for Role {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Role {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 4",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "Listener" => _serde::__private::Ok(__Field::__field0),
                                    "Chatter" => _serde::__private::Ok(__Field::__field1),
                                    "Speaker" => _serde::__private::Ok(__Field::__field2),
                                    "Admin" => _serde::__private::Ok(__Field::__field3),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"Listener" => _serde::__private::Ok(__Field::__field0),
                                    b"Chatter" => _serde::__private::Ok(__Field::__field1),
                                    b"Speaker" => _serde::__private::Ok(__Field::__field2),
                                    b"Admin" => _serde::__private::Ok(__Field::__field3),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Role>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Role;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum Role",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(Role::Listener)
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(Role::Chatter)
                                    }
                                    (__Field::__field2, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(Role::Speaker)
                                    }
                                    (__Field::__field3, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(Role::Admin)
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "Listener",
                            "Chatter",
                            "Speaker",
                            "Admin",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "Role",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Role>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Role {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            Role::Listener => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "Role",
                                    0u32,
                                    "Listener",
                                )
                            }
                            Role::Chatter => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "Role",
                                    1u32,
                                    "Chatter",
                                )
                            }
                            Role::Speaker => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "Role",
                                    2u32,
                                    "Speaker",
                                )
                            }
                            Role::Admin => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "Role",
                                    3u32,
                                    "Admin",
                                )
                            }
                        }
                    }
                }
            };
            impl ::core::fmt::Debug for Role {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        Role::Listener => f.debug_tuple("Role::Listener").finish(),
                        Role::Chatter => f.debug_tuple("Role::Chatter").finish(),
                        Role::Speaker => f.debug_tuple("Role::Speaker").finish(),
                        Role::Admin => f.debug_tuple("Role::Admin").finish(),
                    }
                }
            }
            pub struct CallInfo {
                pub id: _rt::String,
                pub created_at: u64,
                pub participant_count: u32,
                pub default_role: Role,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for CallInfo {
                #[inline]
                fn clone(&self) -> CallInfo {
                    CallInfo {
                        id: ::core::clone::Clone::clone(&self.id),
                        created_at: ::core::clone::Clone::clone(&self.created_at),
                        participant_count: ::core::clone::Clone::clone(
                            &self.participant_count,
                        ),
                        default_role: ::core::clone::Clone::clone(&self.default_role),
                    }
                }
            }
            impl From<CallInfo> for Vec<u8> {
                fn from(value: CallInfo) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a CallInfo> for Vec<u8> {
                fn from(value: &'a CallInfo) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for CallInfo {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for CallInfo {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for CallInfo {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "id" => _serde::__private::Ok(__Field::__field0),
                                    "created_at" => _serde::__private::Ok(__Field::__field1),
                                    "participant_count" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    "default_role" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"id" => _serde::__private::Ok(__Field::__field0),
                                    b"created_at" => _serde::__private::Ok(__Field::__field1),
                                    b"participant_count" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    b"default_role" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<CallInfo>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = CallInfo;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct CallInfo",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct CallInfo with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    u64,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct CallInfo with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    u32,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct CallInfo with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    Role,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct CallInfo with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(CallInfo {
                                    id: __field0,
                                    created_at: __field1,
                                    participant_count: __field2,
                                    default_role: __field3,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<u64> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<u32> = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<Role> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "created_at",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "participant_count",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "default_role",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Role>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("id")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("created_at")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("participant_count")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("default_role")?
                                    }
                                };
                                _serde::__private::Ok(CallInfo {
                                    id: __field0,
                                    created_at: __field1,
                                    participant_count: __field2,
                                    default_role: __field3,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "id",
                            "created_at",
                            "participant_count",
                            "default_role",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "CallInfo",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<CallInfo>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for CallInfo {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "CallInfo",
                            false as usize + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "id",
                            &self.id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "created_at",
                            &self.created_at,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "participant_count",
                            &self.participant_count,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "default_role",
                            &self.default_role,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for CallInfo {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("CallInfo")
                        .field("id", &self.id)
                        .field("created-at", &self.created_at)
                        .field("participant-count", &self.participant_count)
                        .field("default-role", &self.default_role)
                        .finish()
                }
            }
            #[repr(C)]
            pub struct CreateCallReq {
                pub default_role: Role,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for CreateCallReq {
                #[inline]
                fn clone(&self) -> CreateCallReq {
                    let _: ::core::clone::AssertParamIsClone<Role>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for CreateCallReq {}
            impl From<CreateCallReq> for Vec<u8> {
                fn from(value: CreateCallReq) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a CreateCallReq> for Vec<u8> {
                fn from(value: &'a CreateCallReq) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for CreateCallReq {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for CreateCallReq {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for CreateCallReq {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "default_role" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"default_role" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<CreateCallReq>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = CreateCallReq;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct CreateCallReq",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    Role,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct CreateCallReq with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(CreateCallReq {
                                    default_role: __field0,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<Role> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "default_role",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Role>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("default_role")?
                                    }
                                };
                                _serde::__private::Ok(CreateCallReq {
                                    default_role: __field0,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["default_role"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "CreateCallReq",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<CreateCallReq>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for CreateCallReq {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "CreateCallReq",
                            false as usize + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "default_role",
                            &self.default_role,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for CreateCallReq {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("CreateCallReq")
                        .field("default-role", &self.default_role)
                        .finish()
                }
            }
            pub struct JoinInfo {
                pub call_id: _rt::String,
                pub participant_id: _rt::String,
                pub role: Role,
                pub auth_token: Option<_rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for JoinInfo {
                #[inline]
                fn clone(&self) -> JoinInfo {
                    JoinInfo {
                        call_id: ::core::clone::Clone::clone(&self.call_id),
                        participant_id: ::core::clone::Clone::clone(
                            &self.participant_id,
                        ),
                        role: ::core::clone::Clone::clone(&self.role),
                        auth_token: ::core::clone::Clone::clone(&self.auth_token),
                    }
                }
            }
            impl From<JoinInfo> for Vec<u8> {
                fn from(value: JoinInfo) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a JoinInfo> for Vec<u8> {
                fn from(value: &'a JoinInfo) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for JoinInfo {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for JoinInfo {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for JoinInfo {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "call_id" => _serde::__private::Ok(__Field::__field0),
                                    "participant_id" => _serde::__private::Ok(__Field::__field1),
                                    "role" => _serde::__private::Ok(__Field::__field2),
                                    "auth_token" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"call_id" => _serde::__private::Ok(__Field::__field0),
                                    b"participant_id" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    b"role" => _serde::__private::Ok(__Field::__field2),
                                    b"auth_token" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<JoinInfo>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = JoinInfo;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct JoinInfo",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct JoinInfo with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct JoinInfo with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Role,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct JoinInfo with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    Option<_rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct JoinInfo with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(JoinInfo {
                                    call_id: __field0,
                                    participant_id: __field1,
                                    role: __field2,
                                    auth_token: __field3,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<Role> = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<
                                    Option<_rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "call_id",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "participant_id",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("role"),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Role>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "auth_token",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<_rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("call_id")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("participant_id")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("role")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("auth_token")?
                                    }
                                };
                                _serde::__private::Ok(JoinInfo {
                                    call_id: __field0,
                                    participant_id: __field1,
                                    role: __field2,
                                    auth_token: __field3,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "call_id",
                            "participant_id",
                            "role",
                            "auth_token",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "JoinInfo",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<JoinInfo>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for JoinInfo {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "JoinInfo",
                            false as usize + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "call_id",
                            &self.call_id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "participant_id",
                            &self.participant_id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "role",
                            &self.role,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "auth_token",
                            &self.auth_token,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for JoinInfo {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("JoinInfo")
                        .field("call-id", &self.call_id)
                        .field("participant-id", &self.participant_id)
                        .field("role", &self.role)
                        .field("auth-token", &self.auth_token)
                        .finish()
                }
            }
            pub struct ParticipantInfo {
                pub id: _rt::String,
                pub display_name: _rt::String,
                pub role: Role,
                pub is_muted: bool,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ParticipantInfo {
                #[inline]
                fn clone(&self) -> ParticipantInfo {
                    ParticipantInfo {
                        id: ::core::clone::Clone::clone(&self.id),
                        display_name: ::core::clone::Clone::clone(&self.display_name),
                        role: ::core::clone::Clone::clone(&self.role),
                        is_muted: ::core::clone::Clone::clone(&self.is_muted),
                    }
                }
            }
            impl From<ParticipantInfo> for Vec<u8> {
                fn from(value: ParticipantInfo) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a ParticipantInfo> for Vec<u8> {
                fn from(value: &'a ParticipantInfo) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for ParticipantInfo {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for ParticipantInfo {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ParticipantInfo {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "id" => _serde::__private::Ok(__Field::__field0),
                                    "display_name" => _serde::__private::Ok(__Field::__field1),
                                    "role" => _serde::__private::Ok(__Field::__field2),
                                    "is_muted" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"id" => _serde::__private::Ok(__Field::__field0),
                                    b"display_name" => _serde::__private::Ok(__Field::__field1),
                                    b"role" => _serde::__private::Ok(__Field::__field2),
                                    b"is_muted" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<ParticipantInfo>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ParticipantInfo;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ParticipantInfo",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ParticipantInfo with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ParticipantInfo with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Role,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct ParticipantInfo with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    bool,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct ParticipantInfo with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(ParticipantInfo {
                                    id: __field0,
                                    display_name: __field1,
                                    role: __field2,
                                    is_muted: __field3,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<Role> = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<bool> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "display_name",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("role"),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Role>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "is_muted",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("id")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("display_name")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("role")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("is_muted")?
                                    }
                                };
                                _serde::__private::Ok(ParticipantInfo {
                                    id: __field0,
                                    display_name: __field1,
                                    role: __field2,
                                    is_muted: __field3,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "id",
                            "display_name",
                            "role",
                            "is_muted",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ParticipantInfo",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<ParticipantInfo>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ParticipantInfo {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "ParticipantInfo",
                            false as usize + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "id",
                            &self.id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "display_name",
                            &self.display_name,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "role",
                            &self.role,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "is_muted",
                            &self.is_muted,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for ParticipantInfo {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ParticipantInfo")
                        .field("id", &self.id)
                        .field("display-name", &self.display_name)
                        .field("role", &self.role)
                        .field("is-muted", &self.is_muted)
                        .finish()
                }
            }
            pub struct CallState {
                pub call_info: CallInfo,
                pub participants: _rt::Vec<ParticipantInfo>,
                pub chat_history: _rt::Vec<ChatMessage>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for CallState {
                #[inline]
                fn clone(&self) -> CallState {
                    CallState {
                        call_info: ::core::clone::Clone::clone(&self.call_info),
                        participants: ::core::clone::Clone::clone(&self.participants),
                        chat_history: ::core::clone::Clone::clone(&self.chat_history),
                    }
                }
            }
            impl From<CallState> for Vec<u8> {
                fn from(value: CallState) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a CallState> for Vec<u8> {
                fn from(value: &'a CallState) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for CallState {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for CallState {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for CallState {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "call_info" => _serde::__private::Ok(__Field::__field0),
                                    "participants" => _serde::__private::Ok(__Field::__field1),
                                    "chat_history" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"call_info" => _serde::__private::Ok(__Field::__field0),
                                    b"participants" => _serde::__private::Ok(__Field::__field1),
                                    b"chat_history" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<CallState>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = CallState;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct CallState",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    CallInfo,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct CallState with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::Vec<ParticipantInfo>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct CallState with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    _rt::Vec<ChatMessage>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct CallState with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(CallState {
                                    call_info: __field0,
                                    participants: __field1,
                                    chat_history: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<CallInfo> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    _rt::Vec<ParticipantInfo>,
                                > = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    _rt::Vec<ChatMessage>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "call_info",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<CallInfo>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "participants",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::Vec<ParticipantInfo>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "chat_history",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::Vec<ChatMessage>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("call_info")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("participants")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("chat_history")?
                                    }
                                };
                                _serde::__private::Ok(CallState {
                                    call_info: __field0,
                                    participants: __field1,
                                    chat_history: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "call_info",
                            "participants",
                            "chat_history",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "CallState",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<CallState>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for CallState {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "CallState",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "call_info",
                            &self.call_info,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "participants",
                            &self.participants,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "chat_history",
                            &self.chat_history,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for CallState {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("CallState")
                        .field("call-info", &self.call_info)
                        .field("participants", &self.participants)
                        .field("chat-history", &self.chat_history)
                        .finish()
                }
            }
            pub struct UpdateRoleReq {
                pub call_id: _rt::String,
                pub requester_id: _rt::String,
                pub target_id: _rt::String,
                pub new_role: Role,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for UpdateRoleReq {
                #[inline]
                fn clone(&self) -> UpdateRoleReq {
                    UpdateRoleReq {
                        call_id: ::core::clone::Clone::clone(&self.call_id),
                        requester_id: ::core::clone::Clone::clone(&self.requester_id),
                        target_id: ::core::clone::Clone::clone(&self.target_id),
                        new_role: ::core::clone::Clone::clone(&self.new_role),
                    }
                }
            }
            impl From<UpdateRoleReq> for Vec<u8> {
                fn from(value: UpdateRoleReq) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a UpdateRoleReq> for Vec<u8> {
                fn from(value: &'a UpdateRoleReq) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for UpdateRoleReq {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for UpdateRoleReq {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for UpdateRoleReq {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "call_id" => _serde::__private::Ok(__Field::__field0),
                                    "requester_id" => _serde::__private::Ok(__Field::__field1),
                                    "target_id" => _serde::__private::Ok(__Field::__field2),
                                    "new_role" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"call_id" => _serde::__private::Ok(__Field::__field0),
                                    b"requester_id" => _serde::__private::Ok(__Field::__field1),
                                    b"target_id" => _serde::__private::Ok(__Field::__field2),
                                    b"new_role" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<UpdateRoleReq>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = UpdateRoleReq;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct UpdateRoleReq",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct UpdateRoleReq with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct UpdateRoleReq with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct UpdateRoleReq with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    Role,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct UpdateRoleReq with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(UpdateRoleReq {
                                    call_id: __field0,
                                    requester_id: __field1,
                                    target_id: __field2,
                                    new_role: __field3,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<Role> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "call_id",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "requester_id",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "target_id",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "new_role",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Role>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("call_id")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("requester_id")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target_id")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("new_role")?
                                    }
                                };
                                _serde::__private::Ok(UpdateRoleReq {
                                    call_id: __field0,
                                    requester_id: __field1,
                                    target_id: __field2,
                                    new_role: __field3,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "call_id",
                            "requester_id",
                            "target_id",
                            "new_role",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "UpdateRoleReq",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<UpdateRoleReq>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for UpdateRoleReq {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "UpdateRoleReq",
                            false as usize + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "call_id",
                            &self.call_id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "requester_id",
                            &self.requester_id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target_id",
                            &self.target_id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "new_role",
                            &self.new_role,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for UpdateRoleReq {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("UpdateRoleReq")
                        .field("call-id", &self.call_id)
                        .field("requester-id", &self.requester_id)
                        .field("target-id", &self.target_id)
                        .field("new-role", &self.new_role)
                        .finish()
                }
            }
            /// Function signature for: create-call (http)
            /// HTTP: POST POST
            pub struct CreateCallSignatureHttp {
                pub target: _rt::String,
                pub request: CreateCallReq,
                pub returning: Result<CallInfo, _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for CreateCallSignatureHttp {
                #[inline]
                fn clone(&self) -> CreateCallSignatureHttp {
                    CreateCallSignatureHttp {
                        target: ::core::clone::Clone::clone(&self.target),
                        request: ::core::clone::Clone::clone(&self.request),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<CreateCallSignatureHttp> for Vec<u8> {
                fn from(value: CreateCallSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a CreateCallSignatureHttp> for Vec<u8> {
                fn from(value: &'a CreateCallSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for CreateCallSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for CreateCallSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for CreateCallSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "target" => _serde::__private::Ok(__Field::__field0),
                                    "request" => _serde::__private::Ok(__Field::__field1),
                                    "returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"target" => _serde::__private::Ok(__Field::__field0),
                                    b"request" => _serde::__private::Ok(__Field::__field1),
                                    b"returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                CreateCallSignatureHttp,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = CreateCallSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct CreateCallSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct CreateCallSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    CreateCallReq,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct CreateCallSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Result<CallInfo, _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct CreateCallSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(CreateCallSignatureHttp {
                                    target: __field0,
                                    request: __field1,
                                    returning: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    CreateCallReq,
                                > = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    Result<CallInfo, _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "request",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    CreateCallReq,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<CallInfo, _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("request")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(CreateCallSignatureHttp {
                                    target: __field0,
                                    request: __field1,
                                    returning: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "target",
                            "request",
                            "returning",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "CreateCallSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    CreateCallSignatureHttp,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for CreateCallSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "CreateCallSignatureHttp",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "request",
                            &self.request,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for CreateCallSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("CreateCallSignatureHttp")
                        .field("target", &self.target)
                        .field("request", &self.request)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
            /// Function signature for: get-call-info (http)
            /// HTTP: POST POST
            pub struct GetCallInfoSignatureHttp {
                pub target: _rt::String,
                pub call_id: _rt::String,
                pub returning: Result<CallState, _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for GetCallInfoSignatureHttp {
                #[inline]
                fn clone(&self) -> GetCallInfoSignatureHttp {
                    GetCallInfoSignatureHttp {
                        target: ::core::clone::Clone::clone(&self.target),
                        call_id: ::core::clone::Clone::clone(&self.call_id),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<GetCallInfoSignatureHttp> for Vec<u8> {
                fn from(value: GetCallInfoSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a GetCallInfoSignatureHttp> for Vec<u8> {
                fn from(value: &'a GetCallInfoSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for GetCallInfoSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for GetCallInfoSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for GetCallInfoSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "target" => _serde::__private::Ok(__Field::__field0),
                                    "call_id" => _serde::__private::Ok(__Field::__field1),
                                    "returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"target" => _serde::__private::Ok(__Field::__field0),
                                    b"call_id" => _serde::__private::Ok(__Field::__field1),
                                    b"returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                GetCallInfoSignatureHttp,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = GetCallInfoSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct GetCallInfoSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct GetCallInfoSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct GetCallInfoSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Result<CallState, _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct GetCallInfoSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(GetCallInfoSignatureHttp {
                                    target: __field0,
                                    call_id: __field1,
                                    returning: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    Result<CallState, _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "call_id",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<CallState, _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("call_id")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(GetCallInfoSignatureHttp {
                                    target: __field0,
                                    call_id: __field1,
                                    returning: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "target",
                            "call_id",
                            "returning",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "GetCallInfoSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    GetCallInfoSignatureHttp,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for GetCallInfoSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "GetCallInfoSignatureHttp",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "call_id",
                            &self.call_id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for GetCallInfoSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("GetCallInfoSignatureHttp")
                        .field("target", &self.target)
                        .field("call-id", &self.call_id)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
            /// Function signature for: join-call (http)
            /// HTTP: POST POST
            pub struct JoinCallSignatureHttp {
                pub target: _rt::String,
                pub request: JoinCallReq,
                pub returning: Result<JoinInfo, _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for JoinCallSignatureHttp {
                #[inline]
                fn clone(&self) -> JoinCallSignatureHttp {
                    JoinCallSignatureHttp {
                        target: ::core::clone::Clone::clone(&self.target),
                        request: ::core::clone::Clone::clone(&self.request),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<JoinCallSignatureHttp> for Vec<u8> {
                fn from(value: JoinCallSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a JoinCallSignatureHttp> for Vec<u8> {
                fn from(value: &'a JoinCallSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for JoinCallSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for JoinCallSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for JoinCallSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "target" => _serde::__private::Ok(__Field::__field0),
                                    "request" => _serde::__private::Ok(__Field::__field1),
                                    "returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"target" => _serde::__private::Ok(__Field::__field0),
                                    b"request" => _serde::__private::Ok(__Field::__field1),
                                    b"returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                JoinCallSignatureHttp,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = JoinCallSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct JoinCallSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct JoinCallSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    JoinCallReq,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct JoinCallSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Result<JoinInfo, _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct JoinCallSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(JoinCallSignatureHttp {
                                    target: __field0,
                                    request: __field1,
                                    returning: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<JoinCallReq> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    Result<JoinInfo, _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "request",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    JoinCallReq,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<JoinInfo, _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("request")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(JoinCallSignatureHttp {
                                    target: __field0,
                                    request: __field1,
                                    returning: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "target",
                            "request",
                            "returning",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "JoinCallSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    JoinCallSignatureHttp,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for JoinCallSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "JoinCallSignatureHttp",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "request",
                            &self.request,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for JoinCallSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("JoinCallSignatureHttp")
                        .field("target", &self.target)
                        .field("request", &self.request)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
            /// Function signature for: join-call-unauthenticated (http)
            /// HTTP: POST POST
            pub struct JoinCallUnauthenticatedSignatureHttp {
                pub target: _rt::String,
                pub call_id: _rt::String,
                pub request: JoinCallReq,
                pub returning: Result<JoinInfo, _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for JoinCallUnauthenticatedSignatureHttp {
                #[inline]
                fn clone(&self) -> JoinCallUnauthenticatedSignatureHttp {
                    JoinCallUnauthenticatedSignatureHttp {
                        target: ::core::clone::Clone::clone(&self.target),
                        call_id: ::core::clone::Clone::clone(&self.call_id),
                        request: ::core::clone::Clone::clone(&self.request),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<JoinCallUnauthenticatedSignatureHttp> for Vec<u8> {
                fn from(value: JoinCallUnauthenticatedSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a JoinCallUnauthenticatedSignatureHttp> for Vec<u8> {
                fn from(value: &'a JoinCallUnauthenticatedSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for JoinCallUnauthenticatedSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for JoinCallUnauthenticatedSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de>
                for JoinCallUnauthenticatedSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "target" => _serde::__private::Ok(__Field::__field0),
                                    "call_id" => _serde::__private::Ok(__Field::__field1),
                                    "request" => _serde::__private::Ok(__Field::__field2),
                                    "returning" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"target" => _serde::__private::Ok(__Field::__field0),
                                    b"call_id" => _serde::__private::Ok(__Field::__field1),
                                    b"request" => _serde::__private::Ok(__Field::__field2),
                                    b"returning" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                JoinCallUnauthenticatedSignatureHttp,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = JoinCallUnauthenticatedSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct JoinCallUnauthenticatedSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct JoinCallUnauthenticatedSignatureHttp with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct JoinCallUnauthenticatedSignatureHttp with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    JoinCallReq,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct JoinCallUnauthenticatedSignatureHttp with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    Result<JoinInfo, _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct JoinCallUnauthenticatedSignatureHttp with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(JoinCallUnauthenticatedSignatureHttp {
                                    target: __field0,
                                    call_id: __field1,
                                    request: __field2,
                                    returning: __field3,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<JoinCallReq> = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<
                                    Result<JoinInfo, _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "call_id",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "request",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    JoinCallReq,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<JoinInfo, _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("call_id")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("request")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(JoinCallUnauthenticatedSignatureHttp {
                                    target: __field0,
                                    call_id: __field1,
                                    request: __field2,
                                    returning: __field3,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "target",
                            "call_id",
                            "request",
                            "returning",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "JoinCallUnauthenticatedSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    JoinCallUnauthenticatedSignatureHttp,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for JoinCallUnauthenticatedSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "JoinCallUnauthenticatedSignatureHttp",
                            false as usize + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "call_id",
                            &self.call_id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "request",
                            &self.request,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for JoinCallUnauthenticatedSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("JoinCallUnauthenticatedSignatureHttp")
                        .field("target", &self.target)
                        .field("call-id", &self.call_id)
                        .field("request", &self.request)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
            /// Function signature for: join-call-unauthenticated-http (http)
            /// HTTP: POST POST
            pub struct JoinCallUnauthenticatedHttpSignatureHttp {
                pub target: _rt::String,
                pub call_id: _rt::String,
                pub request: JoinCallReq,
                pub returning: Result<JoinInfo, _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for JoinCallUnauthenticatedHttpSignatureHttp {
                #[inline]
                fn clone(&self) -> JoinCallUnauthenticatedHttpSignatureHttp {
                    JoinCallUnauthenticatedHttpSignatureHttp {
                        target: ::core::clone::Clone::clone(&self.target),
                        call_id: ::core::clone::Clone::clone(&self.call_id),
                        request: ::core::clone::Clone::clone(&self.request),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<JoinCallUnauthenticatedHttpSignatureHttp> for Vec<u8> {
                fn from(value: JoinCallUnauthenticatedHttpSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a JoinCallUnauthenticatedHttpSignatureHttp> for Vec<u8> {
                fn from(value: &'a JoinCallUnauthenticatedHttpSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for JoinCallUnauthenticatedHttpSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for JoinCallUnauthenticatedHttpSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de>
                for JoinCallUnauthenticatedHttpSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "target" => _serde::__private::Ok(__Field::__field0),
                                    "call_id" => _serde::__private::Ok(__Field::__field1),
                                    "request" => _serde::__private::Ok(__Field::__field2),
                                    "returning" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"target" => _serde::__private::Ok(__Field::__field0),
                                    b"call_id" => _serde::__private::Ok(__Field::__field1),
                                    b"request" => _serde::__private::Ok(__Field::__field2),
                                    b"returning" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                JoinCallUnauthenticatedHttpSignatureHttp,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = JoinCallUnauthenticatedHttpSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct JoinCallUnauthenticatedHttpSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct JoinCallUnauthenticatedHttpSignatureHttp with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct JoinCallUnauthenticatedHttpSignatureHttp with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    JoinCallReq,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct JoinCallUnauthenticatedHttpSignatureHttp with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    Result<JoinInfo, _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct JoinCallUnauthenticatedHttpSignatureHttp with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(JoinCallUnauthenticatedHttpSignatureHttp {
                                    target: __field0,
                                    call_id: __field1,
                                    request: __field2,
                                    returning: __field3,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<JoinCallReq> = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<
                                    Result<JoinInfo, _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "call_id",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "request",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    JoinCallReq,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<JoinInfo, _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("call_id")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("request")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(JoinCallUnauthenticatedHttpSignatureHttp {
                                    target: __field0,
                                    call_id: __field1,
                                    request: __field2,
                                    returning: __field3,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "target",
                            "call_id",
                            "request",
                            "returning",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "JoinCallUnauthenticatedHttpSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    JoinCallUnauthenticatedHttpSignatureHttp,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for JoinCallUnauthenticatedHttpSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "JoinCallUnauthenticatedHttpSignatureHttp",
                            false as usize + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "call_id",
                            &self.call_id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "request",
                            &self.request,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for JoinCallUnauthenticatedHttpSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("JoinCallUnauthenticatedHttpSignatureHttp")
                        .field("target", &self.target)
                        .field("call-id", &self.call_id)
                        .field("request", &self.request)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
            /// Function signature for: leave-call (http)
            /// HTTP: POST POST
            pub struct LeaveCallSignatureHttp {
                pub target: _rt::String,
                pub request: LeaveCallReq,
                pub returning: Result<(), _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for LeaveCallSignatureHttp {
                #[inline]
                fn clone(&self) -> LeaveCallSignatureHttp {
                    LeaveCallSignatureHttp {
                        target: ::core::clone::Clone::clone(&self.target),
                        request: ::core::clone::Clone::clone(&self.request),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<LeaveCallSignatureHttp> for Vec<u8> {
                fn from(value: LeaveCallSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a LeaveCallSignatureHttp> for Vec<u8> {
                fn from(value: &'a LeaveCallSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for LeaveCallSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for LeaveCallSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for LeaveCallSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "target" => _serde::__private::Ok(__Field::__field0),
                                    "request" => _serde::__private::Ok(__Field::__field1),
                                    "returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"target" => _serde::__private::Ok(__Field::__field0),
                                    b"request" => _serde::__private::Ok(__Field::__field1),
                                    b"returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                LeaveCallSignatureHttp,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = LeaveCallSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct LeaveCallSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct LeaveCallSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    LeaveCallReq,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct LeaveCallSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Result<(), _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct LeaveCallSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(LeaveCallSignatureHttp {
                                    target: __field0,
                                    request: __field1,
                                    returning: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<LeaveCallReq> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    Result<(), _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "request",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    LeaveCallReq,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<(), _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("request")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(LeaveCallSignatureHttp {
                                    target: __field0,
                                    request: __field1,
                                    returning: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "target",
                            "request",
                            "returning",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "LeaveCallSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    LeaveCallSignatureHttp,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for LeaveCallSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "LeaveCallSignatureHttp",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "request",
                            &self.request,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for LeaveCallSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("LeaveCallSignatureHttp")
                        .field("target", &self.target)
                        .field("request", &self.request)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
            /// Function signature for: node-handshake (http)
            /// HTTP: POST POST
            pub struct NodeHandshakeSignatureHttp {
                pub target: _rt::String,
                pub request: NodeHandshakeReq,
                pub returning: Result<NodeHandshakeResp, _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for NodeHandshakeSignatureHttp {
                #[inline]
                fn clone(&self) -> NodeHandshakeSignatureHttp {
                    NodeHandshakeSignatureHttp {
                        target: ::core::clone::Clone::clone(&self.target),
                        request: ::core::clone::Clone::clone(&self.request),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<NodeHandshakeSignatureHttp> for Vec<u8> {
                fn from(value: NodeHandshakeSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a NodeHandshakeSignatureHttp> for Vec<u8> {
                fn from(value: &'a NodeHandshakeSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for NodeHandshakeSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for NodeHandshakeSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for NodeHandshakeSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "target" => _serde::__private::Ok(__Field::__field0),
                                    "request" => _serde::__private::Ok(__Field::__field1),
                                    "returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"target" => _serde::__private::Ok(__Field::__field0),
                                    b"request" => _serde::__private::Ok(__Field::__field1),
                                    b"returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                NodeHandshakeSignatureHttp,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = NodeHandshakeSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct NodeHandshakeSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct NodeHandshakeSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    NodeHandshakeReq,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct NodeHandshakeSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Result<NodeHandshakeResp, _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct NodeHandshakeSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(NodeHandshakeSignatureHttp {
                                    target: __field0,
                                    request: __field1,
                                    returning: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    NodeHandshakeReq,
                                > = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    Result<NodeHandshakeResp, _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "request",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    NodeHandshakeReq,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<NodeHandshakeResp, _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("request")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(NodeHandshakeSignatureHttp {
                                    target: __field0,
                                    request: __field1,
                                    returning: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "target",
                            "request",
                            "returning",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "NodeHandshakeSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    NodeHandshakeSignatureHttp,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for NodeHandshakeSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "NodeHandshakeSignatureHttp",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "request",
                            &self.request,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for NodeHandshakeSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("NodeHandshakeSignatureHttp")
                        .field("target", &self.target)
                        .field("request", &self.request)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
            /// Function signature for: serve-call-page (http)
            /// HTTP: GET GET
            pub struct ServeCallPageSignatureHttp {
                pub target: _rt::String,
                pub call_id: _rt::String,
                pub returning: Result<_rt::Vec<u8>, _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ServeCallPageSignatureHttp {
                #[inline]
                fn clone(&self) -> ServeCallPageSignatureHttp {
                    ServeCallPageSignatureHttp {
                        target: ::core::clone::Clone::clone(&self.target),
                        call_id: ::core::clone::Clone::clone(&self.call_id),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<ServeCallPageSignatureHttp> for Vec<u8> {
                fn from(value: ServeCallPageSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a ServeCallPageSignatureHttp> for Vec<u8> {
                fn from(value: &'a ServeCallPageSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for ServeCallPageSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for ServeCallPageSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ServeCallPageSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "target" => _serde::__private::Ok(__Field::__field0),
                                    "call_id" => _serde::__private::Ok(__Field::__field1),
                                    "returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"target" => _serde::__private::Ok(__Field::__field0),
                                    b"call_id" => _serde::__private::Ok(__Field::__field1),
                                    b"returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                ServeCallPageSignatureHttp,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ServeCallPageSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ServeCallPageSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ServeCallPageSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ServeCallPageSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Result<_rt::Vec<u8>, _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct ServeCallPageSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(ServeCallPageSignatureHttp {
                                    target: __field0,
                                    call_id: __field1,
                                    returning: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    Result<_rt::Vec<u8>, _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "call_id",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<_rt::Vec<u8>, _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("call_id")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(ServeCallPageSignatureHttp {
                                    target: __field0,
                                    call_id: __field1,
                                    returning: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "target",
                            "call_id",
                            "returning",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ServeCallPageSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    ServeCallPageSignatureHttp,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ServeCallPageSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "ServeCallPageSignatureHttp",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "call_id",
                            &self.call_id,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for ServeCallPageSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ServeCallPageSignatureHttp")
                        .field("target", &self.target)
                        .field("call-id", &self.call_id)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
            /// Function signature for: update-role (http)
            /// HTTP: POST POST
            pub struct UpdateRoleSignatureHttp {
                pub target: _rt::String,
                pub request: UpdateRoleReq,
                pub returning: Result<(), _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for UpdateRoleSignatureHttp {
                #[inline]
                fn clone(&self) -> UpdateRoleSignatureHttp {
                    UpdateRoleSignatureHttp {
                        target: ::core::clone::Clone::clone(&self.target),
                        request: ::core::clone::Clone::clone(&self.request),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<UpdateRoleSignatureHttp> for Vec<u8> {
                fn from(value: UpdateRoleSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a UpdateRoleSignatureHttp> for Vec<u8> {
                fn from(value: &'a UpdateRoleSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for UpdateRoleSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for UpdateRoleSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for UpdateRoleSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "target" => _serde::__private::Ok(__Field::__field0),
                                    "request" => _serde::__private::Ok(__Field::__field1),
                                    "returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"target" => _serde::__private::Ok(__Field::__field0),
                                    b"request" => _serde::__private::Ok(__Field::__field1),
                                    b"returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                UpdateRoleSignatureHttp,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = UpdateRoleSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct UpdateRoleSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct UpdateRoleSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    UpdateRoleReq,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct UpdateRoleSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Result<(), _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct UpdateRoleSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(UpdateRoleSignatureHttp {
                                    target: __field0,
                                    request: __field1,
                                    returning: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    UpdateRoleReq,
                                > = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    Result<(), _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "request",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    UpdateRoleReq,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<(), _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("request")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(UpdateRoleSignatureHttp {
                                    target: __field0,
                                    request: __field1,
                                    returning: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "target",
                            "request",
                            "returning",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "UpdateRoleSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    UpdateRoleSignatureHttp,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for UpdateRoleSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "UpdateRoleSignatureHttp",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "request",
                            &self.request,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for UpdateRoleSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("UpdateRoleSignatureHttp")
                        .field("target", &self.target)
                        .field("request", &self.request)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
        }
    }
}
mod _rt {
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if true {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if true {
            match val {
                0 => false,
                1 => true,
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!("invalid bool discriminant"),
                    );
                }
            }
        } else {
            val != 0
        }
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if true {
            {
                ::core::panicking::panic_fmt(format_args!("invalid enum discriminant"));
            }
        } else {
            core::hint::unreachable_unchecked()
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }
    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }
    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }
    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    pub use alloc_crate::alloc;
    extern crate alloc as alloc_crate;
}
#[doc(inline)]
pub(crate) use __export_voice_sys_v0_impl as export;
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen::rt::maybe_link_cabi_realloc();
}
const _: &[u8] = b"world voice-sys-v0 {\n    import voice;\n    include process-v1;\n}";
const _: &[u8] = b"package hyperware:process@1.0.0;\n\ninterface standard {\n\n    //     \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n    //    System Types\n    //     \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n\n    /// JSON is passed over Wasm boundary as a string.\n    type json = string;\n\n    /// In types passed from kernel, node-id will be a valid Kimap entry.\n    type node-id = string;\n\n    /// Context, like a message body, is a protocol-defined serialized byte\n    /// array. It is used when building a Request to save information that\n    /// will not be part of a Response, in order to more easily handle\n    /// (\"contextualize\") that Response.\n    type context = list<u8>;\n\n    record process-id {\n        process-name: string,\n        package-name: string,\n        publisher-node: node-id,\n    }\n\n    record package-id {\n        package-name: string,\n        publisher-node: node-id,\n    }\n\n    record address {\n        node: node-id,\n        process: process-id,\n    }\n\n    record lazy-load-blob {\n        mime: option<string>,\n        bytes: list<u8>,\n    }\n\n    record request {\n        // set in order to inherit lazy-load-blob from parent message, and if\n        // expects-response is none, direct response to source of parent.\n        // also carries forward certain aspects of parent message in kernel,\n        // see documentation for formal spec and examples:\n        // https://docs.rs/hyperware_process_lib/latest/hyperware_process_lib/struct.Request.html\n        inherit: bool,\n        // if some, request expects a response in the given number of seconds\n        expects-response: option<u64>,\n        body: list<u8>,\n        metadata: option<json>,\n        capabilities: list<capability>,\n        // to grab lazy-load-blob, use get_blob()\n    }\n\n    record response {\n        inherit: bool,\n        body: list<u8>,\n        metadata: option<json>,\n        capabilities: list<capability>,\n        // to grab lazy-load-blob, use get_blob()\n    }\n\n    /// A message can be a request or a response. Within a response, there is\n    /// a result which surfaces any error that happened because of a request.\n    /// A successful response will contain the context of the request it\n    /// matches, if any was set.\n    variant message {\n        request(request),\n        response(tuple<response, option<context>>),\n    }\n\n    record capability {\n        issuer: address,\n        params: json,\n    }\n\n    /// On-exit is a setting that determines what happens when a process\n    /// panics, completes, or otherwise \"ends\".\n    /// NOTE: requests will always have expects-response set to false by kernel.\n    variant on-exit {\n        none,\n        restart,\n        requests(list<tuple<address, request, option<lazy-load-blob>>>),\n    }\n\n    /// Send errors come from trying to send a message to another process,\n    /// either locally or on another node.\n    /// A message can fail by timing out, or by the node being entirely\n    /// unreachable (offline or can\'t be found in PKI). In either case,\n    /// the message is not delivered and the process that sent it receives\n    /// that message back along with any assigned context and/or lazy-load-blob,\n    /// and is free to handle it as it sees fit.\n    /// In the local case, only timeout errors are possible and also cover the case\n    /// in which a process is not running or does not exist.\n    record send-error {\n        kind: send-error-kind,\n        target: address,\n        message: message,\n        lazy-load-blob: option<lazy-load-blob>,\n    }\n\n    enum send-error-kind {\n        offline,\n        timeout,\n    }\n\n    enum spawn-error {\n        name-taken,\n        no-file-at-path,\n    }\n\n    //     \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n    //    System Utils\n    //     \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n\n    /// Prints to the terminal at a given verbosity level.\n    /// Higher verbosity levels print more information.\n    /// Level 0 is always printed -- use sparingly.\n    print-to-terminal: func(verbosity: u8, message: string);\n\n    /// Returns the address of the process.\n    our: func() -> address;\n\n    //        \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n    //    Process Management\n    //        \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n\n    get-on-exit: func() -> on-exit;\n\n    set-on-exit: func(on-exit: on-exit);\n\n    get-state: func() -> option<list<u8>>;\n\n    set-state: func(bytes: list<u8>);\n\n    clear-state: func();\n\n    spawn: func(\n        // name is optional. if not provided, name will be a random u64.\n        name: option<string>,\n        // wasm-path must be located within package\'s drive\n        wasm-path: string,\n        on-exit: on-exit,\n        // requested capabilities must be owned by the caller\n        request-capabilities: list<capability>,\n        // granted capabilities will be generated by the child process\n        // and handed out to the indicated process-id.\n        grant-capabilities: list<tuple<process-id, json>>,\n        public: bool\n    ) -> result<process-id, spawn-error>;\n\n    //           \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n    //    Capabilities Management\n    //           \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n\n    /// Saves the capabilities to persisted process state.\n    save-capabilities: func(caps: list<capability>);\n\n    /// Deletes the capabilities from persisted process state.\n    drop-capabilities: func(caps: list<capability>);\n\n    /// Gets all capabilities from persisted process state.\n    our-capabilities: func() -> list<capability>;\n\n    //     \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n    //    Message I/O\n    //     \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n\n    /// Ingest next message when it arrives along with its source.\n    /// Almost all long-running processes will call this in a loop.\n    receive: func() ->\n        result<tuple<address, message>, tuple<send-error, option<context>>>;\n\n    /// Returns whether or not the current message has a blob.\n    has-blob: func() -> bool;\n\n    /// Returns the blob of the current message, if any.\n    get-blob: func() -> option<lazy-load-blob>;\n\n    /// Returns the last blob this process received.\n    last-blob: func() -> option<lazy-load-blob>;\n\n    /// Send request to target.\n    send-request: func(\n        target: address,\n        request: request,\n        context: option<context>,\n        lazy-load-blob: option<lazy-load-blob>\n    );\n\n    /// Send requests to targets.\n    send-requests: func(\n        requests: list<tuple<address,\n                             request,\n                             option<context>,\n                             option<lazy-load-blob>>>\n    );\n\n    /// Send response to the request currently being handled.\n    send-response: func(\n        response: response,\n        lazy-load-blob: option<lazy-load-blob>\n    );\n\n    /// Send a single request, then block (internally) until its response. The\n    /// type returned is Message but will always contain Response.\n    send-and-await-response: func(\n        target: address,\n        request: request,\n        lazy-load-blob: option<lazy-load-blob>\n    ) -> result<tuple<address, message>, send-error>;\n}\n\nworld lib {\n    import standard;\n}\n\nworld process-v1 {\n    include lib;\n\n    export init: func(our: string);\n}\n";
const _: &[u8] = b"interface voice {\nuse standard.{address};\n\n    record call-info {\n        id: string,\n        created-at: u64,\n        participant-count: u32,\n        default-role: role\n    }\n\n    record call-state {\n        call-info: call-info,\n        participants: list<participant-info>,\n        chat-history: list<chat-message>\n    }\n\n    record chat-message {\n        id: string,\n        sender-id: string,\n        sender-name: string,\n        content: string,\n        timestamp: u64\n    }\n\n    record create-call-req {\n        default-role: role\n    }\n\n    record join-call-req {\n        call-id: string,\n        node-auth: option<string>\n    }\n\n    record join-info {\n        call-id: string,\n        participant-id: string,\n        role: role,\n        auth-token: option<string>\n    }\n\n    record leave-call-req {\n        call-id: string,\n        participant-id: string\n    }\n\n    record node-handshake-req {\n        call-id: string\n    }\n\n    record node-handshake-resp {\n        auth-token: string,\n        redirect-url: string\n    }\n\n    record participant-info {\n        id: string,\n        display-name: string,\n        role: role,\n        is-muted: bool\n    }\n\n    record update-role-req {\n        call-id: string,\n        requester-id: string,\n        target-id: string,\n        new-role: role\n    }\n\n    variant role {\n        listener,\n        chatter,\n        speaker,\n        admin\n    }\n\n    // Function signature for: create-call (http)\n    // HTTP: POST POST\n    record create-call-signature-http {\n        target: string,\n        request: create-call-req,\n        returning: result<call-info, string>\n    }\n\n    // Function signature for: get-call-info (http)\n    // HTTP: POST POST\n    record get-call-info-signature-http {\n        target: string,\n        call-id: string,\n        returning: result<call-state, string>\n    }\n\n    // Function signature for: join-call (http)\n    // HTTP: POST POST\n    record join-call-signature-http {\n        target: string,\n        request: join-call-req,\n        returning: result<join-info, string>\n    }\n\n    // Function signature for: join-call-unauthenticated (http)\n    // HTTP: POST POST\n    record join-call-unauthenticated-signature-http {\n        target: string,\n        call-id: string,\n        request: join-call-req,\n        returning: result<join-info, string>\n    }\n\n    // Function signature for: join-call-unauthenticated-http (http)\n    // HTTP: POST POST\n    record join-call-unauthenticated-http-signature-http {\n        target: string,\n        call-id: string,\n        request: join-call-req,\n        returning: result<join-info, string>\n    }\n\n    // Function signature for: leave-call (http)\n    // HTTP: POST POST\n    record leave-call-signature-http {\n        target: string,\n        request: leave-call-req,\n        returning: result<_, string>\n    }\n\n    // Function signature for: node-handshake (http)\n    // HTTP: POST POST\n    record node-handshake-signature-http {\n        target: string,\n        request: node-handshake-req,\n        returning: result<node-handshake-resp, string>\n    }\n\n    // Function signature for: serve-call-page (http)\n    // HTTP: GET GET\n    record serve-call-page-signature-http {\n        target: string,\n        call-id: string,\n        returning: result<list<u8>, string>\n    }\n\n    // Function signature for: update-role (http)\n    // HTTP: POST POST\n    record update-role-signature-http {\n        target: string,\n        request: update-role-req,\n        returning: result<_, string>\n    }\n}\n";
const _: &[u8] = b"world types-voice-sys-v0 {\n    import voice;\n    include lib;\n}";
use hyperware_app_common::hyperware_process_lib as hyperware_process_lib;
use hyperware_process_lib::http::server::HttpBindingConfig;
use hyperware_process_lib::http::server::WsBindingConfig;
use hyperware_app_common::Binding;
impl VoiceState {
    async fn init(&mut self) {
        self.word_dictionary = <[_]>::into_vec(
                #[rustc_box]
                ::alloc::boxed::Box::new([
                    "apple",
                    "banana",
                    "cherry",
                    "dog",
                    "elephant",
                    "forest",
                    "galaxy",
                    "hello",
                    "island",
                    "jungle",
                    "kitten",
                    "lemon",
                    "mountain",
                    "nebula",
                    "ocean",
                    "planet",
                    "quantum",
                    "rainbow",
                    "sunset",
                    "thunder",
                    "universe",
                    "volcano",
                    "waterfall",
                    "xylophone",
                    "yellow",
                    "zebra",
                    "acoustic",
                    "bicycle",
                    "chocolate",
                    "diamond",
                    "emerald",
                    "fountain",
                    "guitar",
                    "helicopter",
                    "illusion",
                    "jasmine",
                ]),
            )
            .into_iter()
            .map(String::from)
            .collect();
    }
    async fn create_call(&mut self, request: CreateCallReq) -> Result<CallInfo, String> {
        let call_id = generate_call_id(&self.word_dictionary);
        let call = Call {
            id: call_id.clone(),
            participants: HashMap::new(),
            chat_history: Vec::new(),
            created_at: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .map_err(|e| e.to_string())?
                .as_secs(),
            default_role: request.default_role.clone(),
            creator_id: None,
        };
        let call_info = CallInfo {
            id: call_id.clone(),
            created_at: call.created_at,
            participant_count: 0,
            default_role: call.default_role.clone(),
        };
        self.calls.insert(call_id.clone(), call);
        self.used_pleb_names.insert(call_id, Vec::new());
        Ok(call_info)
    }
    async fn join_call(&mut self, request: JoinCallReq) -> Result<JoinInfo, String> {
        let call = self
            .calls
            .get_mut(&request.call_id)
            .ok_or_else(|| "Call not found".to_string())?;
        let (participant_id, display_name, connection_type) = if let Some(auth_token) = request
            .node_auth
        {
            if let Some(node_id) = self.node_auth_tokens.get(&auth_token) {
                (node_id.clone(), node_id.clone(), ConnectionType::Node(node_id.clone()))
            } else {
                return Err("Invalid authentication token".to_string());
            }
        } else {
            let pleb_name = generate_pleb_name(
                &self.word_dictionary,
                self.used_pleb_names.get_mut(&request.call_id).unwrap(),
            );
            (pleb_name.clone(), pleb_name.clone(), ConnectionType::Browser)
        };
        let role = if call.creator_id.is_none() {
            call.creator_id = Some(participant_id.clone());
            Role::Admin
        } else {
            call.default_role.clone()
        };
        let participant = Participant {
            id: participant_id.clone(),
            display_name: display_name.clone(),
            role,
            connection_type,
            is_muted: true,
        };
        call.participants.insert(participant_id.clone(), participant.clone());
        let auth_token = generate_id();
        let join_info = JoinInfo {
            call_id: request.call_id,
            participant_id: participant_id.clone(),
            role: participant.role.clone(),
            auth_token: Some(auth_token),
        };
        Ok(join_info)
    }
    async fn get_call_info(&mut self, call_id: String) -> Result<CallState, String> {
        let call = self.calls.get(&call_id).ok_or_else(|| "Call not found".to_string())?;
        let participants: Vec<ParticipantInfo> = call
            .participants
            .values()
            .map(|p| ParticipantInfo {
                id: p.id.clone(),
                display_name: p.display_name.clone(),
                role: p.role.clone(),
                is_muted: p.is_muted,
            })
            .collect();
        let call_state = CallState {
            call_info: CallInfo {
                id: call.id.clone(),
                created_at: call.created_at,
                participant_count: call.participants.len() as u32,
                default_role: call.default_role.clone(),
            },
            participants,
            chat_history: call.chat_history.clone(),
        };
        Ok(call_state)
    }
    async fn leave_call(&mut self, request: LeaveCallReq) -> Result<(), String> {
        let call = self
            .calls
            .get_mut(&request.call_id)
            .ok_or_else(|| "Call not found".to_string())?;
        call.participants.remove(&request.participant_id);
        self.connections.retain(|_, pid| pid != &request.participant_id);
        if call.participants.is_empty() {
            self.calls.remove(&request.call_id);
            self.used_pleb_names.remove(&request.call_id);
        }
        Ok(())
    }
    async fn update_role(&mut self, request: UpdateRoleReq) -> Result<(), String> {
        let call = self
            .calls
            .get_mut(&request.call_id)
            .ok_or_else(|| "Call not found".to_string())?;
        let requester = call
            .participants
            .get(&request.requester_id)
            .ok_or_else(|| "Requester not found".to_string())?;
        if !match requester.role {
            Role::Admin => true,
            _ => false,
        } {
            return Err("Unauthorized: Only admins can update roles".to_string());
        }
        let participant = call
            .participants
            .get_mut(&request.target_id)
            .ok_or_else(|| "Target participant not found".to_string())?;
        participant.role = request.new_role.clone();
        Ok(())
    }
    async fn serve_call_page(&mut self, call_id: String) -> Result<Vec<u8>, String> {
        if self.calls.contains_key(&call_id) {
            let html = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!(
                        "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Voice Call - {0}</title>\n    <script type=\"module\" crossorigin src=\"/voice:voice:sys/assets/index.js\"></script>\n    <link rel=\"stylesheet\" crossorigin href=\"/voice:voice:sys/assets/index.css\">\n</head>\n<body>\n    <div id=\"root\"></div>\n    <script>\n        // Set the call ID for the frontend to use\n        window.VOICE_CALL_ID = \"{1}\";\n    </script>\n</body>\n</html>",
                        call_id,
                        call_id,
                    ),
                );
                res
            });
            Ok(html.into_bytes())
        } else {
            Err("Call not found".to_string())
        }
    }
    async fn join_call_unauthenticated(
        &mut self,
        call_id: String,
        request: JoinCallReq,
    ) -> Result<JoinInfo, String> {
        let mut req = request;
        req.call_id = call_id;
        self.join_call(req).await
    }
    async fn join_call_unauthenticated_http(
        &mut self,
        call_id: String,
        request: JoinCallReq,
    ) -> Result<JoinInfo, String> {
        self.join_call_unauthenticated(call_id, request).await
    }
    async fn node_handshake(
        &mut self,
        request: NodeHandshakeReq,
    ) -> Result<NodeHandshakeResp, String> {
        if !self.calls.contains_key(&request.call_id) {
            return Err("Call not found".to_string());
        }
        let auth_token = generate_id();
        let node_id = "requesting-node".to_string();
        self.node_auth_tokens.insert(auth_token.clone(), node_id);
        let host_url = "https://voice.example.com";
        let redirect_url = ::alloc::__export::must_use({
            let res = ::alloc::fmt::format(
                format_args!(
                    "{0}/call/{1}?auth={2}",
                    host_url,
                    request.call_id,
                    auth_token,
                ),
            );
            res
        });
        Ok(NodeHandshakeResp {
            auth_token,
            redirect_url,
        })
    }
    fn websocket(
        &mut self,
        channel_id: u32,
        message_type: WsMessageType,
        blob: LazyLoadBlob,
    ) {
        match message_type {
            WsMessageType::Text => {
                if let Ok(message) = String::from_utf8(blob.bytes.clone()) {
                    {
                        ::hyperware_process_lib::print_to_terminal(
                            0,
                            &::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Received WebSocket text message: {0}",
                                        message,
                                    ),
                                );
                                res
                            }),
                        );
                    };
                    match serde_json::from_str::<WsClientMessage>(&message) {
                        Ok(client_msg) => {
                            handle_client_message(self, channel_id, client_msg);
                        }
                        Err(e) => {
                            {
                                ::hyperware_process_lib::print_to_terminal(
                                    0,
                                    &::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("Failed to parse WebSocket message: {0}", e),
                                        );
                                        res
                                    }),
                                );
                            };
                            send_error_to_channel(channel_id, "Invalid message format");
                        }
                    }
                }
            }
            WsMessageType::Close => {
                {
                    ::hyperware_process_lib::print_to_terminal(
                        0,
                        &::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(
                                format_args!("WebSocket connection {0} closed", channel_id),
                            );
                            res
                        }),
                    );
                };
                handle_disconnect(self, channel_id);
            }
            _ => {
                {
                    ::hyperware_process_lib::print_to_terminal(
                        0,
                        &::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "Received other WebSocket message type: {0:?}",
                                    message_type,
                                ),
                            );
                            res
                        }),
                    );
                };
            }
        }
    }
}
enum HPMRequest {
    CreateCall(CreateCallReq),
    JoinCall(JoinCallReq),
    GetCallInfo(String),
    LeaveCall(LeaveCallReq),
    UpdateRole(UpdateRoleReq),
    ServeCallPage(String),
    JoinCallUnauthenticated(String, JoinCallReq),
    JoinCallUnauthenticatedHttp(String, JoinCallReq),
    NodeHandshake(NodeHandshakeReq),
}
#[automatically_derived]
impl ::core::fmt::Debug for HPMRequest {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            HPMRequest::CreateCall(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "CreateCall",
                    &__self_0,
                )
            }
            HPMRequest::JoinCall(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "JoinCall",
                    &__self_0,
                )
            }
            HPMRequest::GetCallInfo(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "GetCallInfo",
                    &__self_0,
                )
            }
            HPMRequest::LeaveCall(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "LeaveCall",
                    &__self_0,
                )
            }
            HPMRequest::UpdateRole(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "UpdateRole",
                    &__self_0,
                )
            }
            HPMRequest::ServeCallPage(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "ServeCallPage",
                    &__self_0,
                )
            }
            HPMRequest::JoinCallUnauthenticated(__self_0, __self_1) => {
                ::core::fmt::Formatter::debug_tuple_field2_finish(
                    f,
                    "JoinCallUnauthenticated",
                    __self_0,
                    &__self_1,
                )
            }
            HPMRequest::JoinCallUnauthenticatedHttp(__self_0, __self_1) => {
                ::core::fmt::Formatter::debug_tuple_field2_finish(
                    f,
                    "JoinCallUnauthenticatedHttp",
                    __self_0,
                    &__self_1,
                )
            }
            HPMRequest::NodeHandshake(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "NodeHandshake",
                    &__self_0,
                )
            }
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for HPMRequest {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                HPMRequest::CreateCall(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMRequest",
                        0u32,
                        "CreateCall",
                        __field0,
                    )
                }
                HPMRequest::JoinCall(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMRequest",
                        1u32,
                        "JoinCall",
                        __field0,
                    )
                }
                HPMRequest::GetCallInfo(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMRequest",
                        2u32,
                        "GetCallInfo",
                        __field0,
                    )
                }
                HPMRequest::LeaveCall(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMRequest",
                        3u32,
                        "LeaveCall",
                        __field0,
                    )
                }
                HPMRequest::UpdateRole(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMRequest",
                        4u32,
                        "UpdateRole",
                        __field0,
                    )
                }
                HPMRequest::ServeCallPage(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMRequest",
                        5u32,
                        "ServeCallPage",
                        __field0,
                    )
                }
                HPMRequest::JoinCallUnauthenticated(ref __field0, ref __field1) => {
                    let mut __serde_state = _serde::Serializer::serialize_tuple_variant(
                        __serializer,
                        "HPMRequest",
                        6u32,
                        "JoinCallUnauthenticated",
                        0 + 1 + 1,
                    )?;
                    _serde::ser::SerializeTupleVariant::serialize_field(
                        &mut __serde_state,
                        __field0,
                    )?;
                    _serde::ser::SerializeTupleVariant::serialize_field(
                        &mut __serde_state,
                        __field1,
                    )?;
                    _serde::ser::SerializeTupleVariant::end(__serde_state)
                }
                HPMRequest::JoinCallUnauthenticatedHttp(ref __field0, ref __field1) => {
                    let mut __serde_state = _serde::Serializer::serialize_tuple_variant(
                        __serializer,
                        "HPMRequest",
                        7u32,
                        "JoinCallUnauthenticatedHttp",
                        0 + 1 + 1,
                    )?;
                    _serde::ser::SerializeTupleVariant::serialize_field(
                        &mut __serde_state,
                        __field0,
                    )?;
                    _serde::ser::SerializeTupleVariant::serialize_field(
                        &mut __serde_state,
                        __field1,
                    )?;
                    _serde::ser::SerializeTupleVariant::end(__serde_state)
                }
                HPMRequest::NodeHandshake(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMRequest",
                        8u32,
                        "NodeHandshake",
                        __field0,
                    )
                }
            }
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for HPMRequest {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __field4,
                __field5,
                __field6,
                __field7,
                __field8,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "variant identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        4u64 => _serde::__private::Ok(__Field::__field4),
                        5u64 => _serde::__private::Ok(__Field::__field5),
                        6u64 => _serde::__private::Ok(__Field::__field6),
                        7u64 => _serde::__private::Ok(__Field::__field7),
                        8u64 => _serde::__private::Ok(__Field::__field8),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 9",
                                ),
                            )
                        }
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "CreateCall" => _serde::__private::Ok(__Field::__field0),
                        "JoinCall" => _serde::__private::Ok(__Field::__field1),
                        "GetCallInfo" => _serde::__private::Ok(__Field::__field2),
                        "LeaveCall" => _serde::__private::Ok(__Field::__field3),
                        "UpdateRole" => _serde::__private::Ok(__Field::__field4),
                        "ServeCallPage" => _serde::__private::Ok(__Field::__field5),
                        "JoinCallUnauthenticated" => {
                            _serde::__private::Ok(__Field::__field6)
                        }
                        "JoinCallUnauthenticatedHttp" => {
                            _serde::__private::Ok(__Field::__field7)
                        }
                        "NodeHandshake" => _serde::__private::Ok(__Field::__field8),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"CreateCall" => _serde::__private::Ok(__Field::__field0),
                        b"JoinCall" => _serde::__private::Ok(__Field::__field1),
                        b"GetCallInfo" => _serde::__private::Ok(__Field::__field2),
                        b"LeaveCall" => _serde::__private::Ok(__Field::__field3),
                        b"UpdateRole" => _serde::__private::Ok(__Field::__field4),
                        b"ServeCallPage" => _serde::__private::Ok(__Field::__field5),
                        b"JoinCallUnauthenticated" => {
                            _serde::__private::Ok(__Field::__field6)
                        }
                        b"JoinCallUnauthenticatedHttp" => {
                            _serde::__private::Ok(__Field::__field7)
                        }
                        b"NodeHandshake" => _serde::__private::Ok(__Field::__field8),
                        _ => {
                            let __value = &_serde::__private::from_utf8_lossy(__value);
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<HPMRequest>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = HPMRequest;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "enum HPMRequest",
                    )
                }
                fn visit_enum<__A>(
                    self,
                    __data: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::EnumAccess<'de>,
                {
                    match _serde::de::EnumAccess::variant(__data)? {
                        (__Field::__field0, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    CreateCallReq,
                                >(__variant),
                                HPMRequest::CreateCall,
                            )
                        }
                        (__Field::__field1, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    JoinCallReq,
                                >(__variant),
                                HPMRequest::JoinCall,
                            )
                        }
                        (__Field::__field2, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    String,
                                >(__variant),
                                HPMRequest::GetCallInfo,
                            )
                        }
                        (__Field::__field3, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    LeaveCallReq,
                                >(__variant),
                                HPMRequest::LeaveCall,
                            )
                        }
                        (__Field::__field4, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    UpdateRoleReq,
                                >(__variant),
                                HPMRequest::UpdateRole,
                            )
                        }
                        (__Field::__field5, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    String,
                                >(__variant),
                                HPMRequest::ServeCallPage,
                            )
                        }
                        (__Field::__field6, __variant) => {
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<HPMRequest>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = HPMRequest;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "tuple variant HPMRequest::JoinCallUnauthenticated",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"tuple variant HPMRequest::JoinCallUnauthenticated with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        JoinCallReq,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"tuple variant HPMRequest::JoinCallUnauthenticated with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(
                                        HPMRequest::JoinCallUnauthenticated(__field0, __field1),
                                    )
                                }
                            }
                            _serde::de::VariantAccess::tuple_variant(
                                __variant,
                                2usize,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<HPMRequest>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                        (__Field::__field7, __variant) => {
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<HPMRequest>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = HPMRequest;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "tuple variant HPMRequest::JoinCallUnauthenticatedHttp",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"tuple variant HPMRequest::JoinCallUnauthenticatedHttp with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        JoinCallReq,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"tuple variant HPMRequest::JoinCallUnauthenticatedHttp with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(
                                        HPMRequest::JoinCallUnauthenticatedHttp(__field0, __field1),
                                    )
                                }
                            }
                            _serde::de::VariantAccess::tuple_variant(
                                __variant,
                                2usize,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<HPMRequest>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                        (__Field::__field8, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    NodeHandshakeReq,
                                >(__variant),
                                HPMRequest::NodeHandshake,
                            )
                        }
                    }
                }
            }
            #[doc(hidden)]
            const VARIANTS: &'static [&'static str] = &[
                "CreateCall",
                "JoinCall",
                "GetCallInfo",
                "LeaveCall",
                "UpdateRole",
                "ServeCallPage",
                "JoinCallUnauthenticated",
                "JoinCallUnauthenticatedHttp",
                "NodeHandshake",
            ];
            _serde::Deserializer::deserialize_enum(
                __deserializer,
                "HPMRequest",
                VARIANTS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<HPMRequest>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
enum HPMResponse {
    CreateCall(Result<CallInfo, String>),
    JoinCall(Result<JoinInfo, String>),
    GetCallInfo(Result<CallState, String>),
    LeaveCall(Result<(), String>),
    UpdateRole(Result<(), String>),
    ServeCallPage(Result<Vec<u8>, String>),
    JoinCallUnauthenticated(Result<JoinInfo, String>),
    JoinCallUnauthenticatedHttp(Result<JoinInfo, String>),
    NodeHandshake(Result<NodeHandshakeResp, String>),
}
#[automatically_derived]
impl ::core::fmt::Debug for HPMResponse {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            HPMResponse::CreateCall(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "CreateCall",
                    &__self_0,
                )
            }
            HPMResponse::JoinCall(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "JoinCall",
                    &__self_0,
                )
            }
            HPMResponse::GetCallInfo(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "GetCallInfo",
                    &__self_0,
                )
            }
            HPMResponse::LeaveCall(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "LeaveCall",
                    &__self_0,
                )
            }
            HPMResponse::UpdateRole(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "UpdateRole",
                    &__self_0,
                )
            }
            HPMResponse::ServeCallPage(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "ServeCallPage",
                    &__self_0,
                )
            }
            HPMResponse::JoinCallUnauthenticated(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "JoinCallUnauthenticated",
                    &__self_0,
                )
            }
            HPMResponse::JoinCallUnauthenticatedHttp(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "JoinCallUnauthenticatedHttp",
                    &__self_0,
                )
            }
            HPMResponse::NodeHandshake(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "NodeHandshake",
                    &__self_0,
                )
            }
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for HPMResponse {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                HPMResponse::CreateCall(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        0u32,
                        "CreateCall",
                        __field0,
                    )
                }
                HPMResponse::JoinCall(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        1u32,
                        "JoinCall",
                        __field0,
                    )
                }
                HPMResponse::GetCallInfo(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        2u32,
                        "GetCallInfo",
                        __field0,
                    )
                }
                HPMResponse::LeaveCall(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        3u32,
                        "LeaveCall",
                        __field0,
                    )
                }
                HPMResponse::UpdateRole(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        4u32,
                        "UpdateRole",
                        __field0,
                    )
                }
                HPMResponse::ServeCallPage(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        5u32,
                        "ServeCallPage",
                        __field0,
                    )
                }
                HPMResponse::JoinCallUnauthenticated(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        6u32,
                        "JoinCallUnauthenticated",
                        __field0,
                    )
                }
                HPMResponse::JoinCallUnauthenticatedHttp(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        7u32,
                        "JoinCallUnauthenticatedHttp",
                        __field0,
                    )
                }
                HPMResponse::NodeHandshake(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        8u32,
                        "NodeHandshake",
                        __field0,
                    )
                }
            }
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for HPMResponse {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __field4,
                __field5,
                __field6,
                __field7,
                __field8,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "variant identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        4u64 => _serde::__private::Ok(__Field::__field4),
                        5u64 => _serde::__private::Ok(__Field::__field5),
                        6u64 => _serde::__private::Ok(__Field::__field6),
                        7u64 => _serde::__private::Ok(__Field::__field7),
                        8u64 => _serde::__private::Ok(__Field::__field8),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 9",
                                ),
                            )
                        }
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "CreateCall" => _serde::__private::Ok(__Field::__field0),
                        "JoinCall" => _serde::__private::Ok(__Field::__field1),
                        "GetCallInfo" => _serde::__private::Ok(__Field::__field2),
                        "LeaveCall" => _serde::__private::Ok(__Field::__field3),
                        "UpdateRole" => _serde::__private::Ok(__Field::__field4),
                        "ServeCallPage" => _serde::__private::Ok(__Field::__field5),
                        "JoinCallUnauthenticated" => {
                            _serde::__private::Ok(__Field::__field6)
                        }
                        "JoinCallUnauthenticatedHttp" => {
                            _serde::__private::Ok(__Field::__field7)
                        }
                        "NodeHandshake" => _serde::__private::Ok(__Field::__field8),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"CreateCall" => _serde::__private::Ok(__Field::__field0),
                        b"JoinCall" => _serde::__private::Ok(__Field::__field1),
                        b"GetCallInfo" => _serde::__private::Ok(__Field::__field2),
                        b"LeaveCall" => _serde::__private::Ok(__Field::__field3),
                        b"UpdateRole" => _serde::__private::Ok(__Field::__field4),
                        b"ServeCallPage" => _serde::__private::Ok(__Field::__field5),
                        b"JoinCallUnauthenticated" => {
                            _serde::__private::Ok(__Field::__field6)
                        }
                        b"JoinCallUnauthenticatedHttp" => {
                            _serde::__private::Ok(__Field::__field7)
                        }
                        b"NodeHandshake" => _serde::__private::Ok(__Field::__field8),
                        _ => {
                            let __value = &_serde::__private::from_utf8_lossy(__value);
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<HPMResponse>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = HPMResponse;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "enum HPMResponse",
                    )
                }
                fn visit_enum<__A>(
                    self,
                    __data: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::EnumAccess<'de>,
                {
                    match _serde::de::EnumAccess::variant(__data)? {
                        (__Field::__field0, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<CallInfo, String>,
                                >(__variant),
                                HPMResponse::CreateCall,
                            )
                        }
                        (__Field::__field1, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<JoinInfo, String>,
                                >(__variant),
                                HPMResponse::JoinCall,
                            )
                        }
                        (__Field::__field2, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<CallState, String>,
                                >(__variant),
                                HPMResponse::GetCallInfo,
                            )
                        }
                        (__Field::__field3, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<(), String>,
                                >(__variant),
                                HPMResponse::LeaveCall,
                            )
                        }
                        (__Field::__field4, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<(), String>,
                                >(__variant),
                                HPMResponse::UpdateRole,
                            )
                        }
                        (__Field::__field5, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<Vec<u8>, String>,
                                >(__variant),
                                HPMResponse::ServeCallPage,
                            )
                        }
                        (__Field::__field6, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<JoinInfo, String>,
                                >(__variant),
                                HPMResponse::JoinCallUnauthenticated,
                            )
                        }
                        (__Field::__field7, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<JoinInfo, String>,
                                >(__variant),
                                HPMResponse::JoinCallUnauthenticatedHttp,
                            )
                        }
                        (__Field::__field8, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<NodeHandshakeResp, String>,
                                >(__variant),
                                HPMResponse::NodeHandshake,
                            )
                        }
                    }
                }
            }
            #[doc(hidden)]
            const VARIANTS: &'static [&'static str] = &[
                "CreateCall",
                "JoinCall",
                "GetCallInfo",
                "LeaveCall",
                "UpdateRole",
                "ServeCallPage",
                "JoinCallUnauthenticated",
                "JoinCallUnauthenticatedHttp",
                "NodeHandshake",
            ];
            _serde::Deserializer::deserialize_enum(
                __deserializer,
                "HPMResponse",
                VARIANTS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<HPMResponse>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
/// Handle messages from the HTTP server
fn handle_http_server_message(
    state: *mut VoiceState,
    message: hyperware_process_lib::Message,
) {
    let blob_opt = message.blob();
    match serde_json::from_slice::<
        hyperware_process_lib::http::server::HttpServerRequest,
    >(message.body()) {
        Ok(http_server_request) => {
            match http_server_request {
                hyperware_process_lib::http::server::HttpServerRequest::Http(
                    http_request,
                ) => {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event voice/src/lib.rs:201",
                                    "voice",
                                    ::tracing::Level::DEBUG,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "voice/src/lib.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(201u32),
                                    ::tracing_core::__macro_support::Option::Some("voice"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::DEBUG
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::DEBUG
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!(
                                                        "Processing HTTP request, message has blob: {0}",
                                                        blob_opt.is_some(),
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    if let Some(ref blob) = blob_opt {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event voice/src/lib.rs:201",
                                        "voice",
                                        ::tracing::Level::DEBUG,
                                        ::tracing_core::__macro_support::Option::Some(
                                            "voice/src/lib.rs",
                                        ),
                                        ::tracing_core::__macro_support::Option::Some(201u32),
                                        ::tracing_core::__macro_support::Option::Some("voice"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::DEBUG
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::DEBUG
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::tracing::__macro_support::Option::Some(
                                                        &format_args!(
                                                            "Blob size: {0} bytes, content: {1}",
                                                            blob.bytes.len(),
                                                            String::from_utf8_lossy(
                                                                &blob.bytes[..std::cmp::min(200, blob.bytes.len())],
                                                            ),
                                                        ) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    let http_method = http_request
                        .method()
                        .map(|m| m.to_string())
                        .unwrap_or_else(|e| {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event voice/src/lib.rs:201",
                                            "voice",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "voice/src/lib.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(201u32),
                                            ::tracing_core::__macro_support::Option::Some("voice"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!("Failed to parse HTTP method: {0}", e)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                            "UNKNOWN".to_string()
                        });
                    let current_path = match http_request.path() {
                        Ok(path) => {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event voice/src/lib.rs:201",
                                            "voice",
                                            ::tracing::Level::DEBUG,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "voice/src/lib.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(201u32),
                                            ::tracing_core::__macro_support::Option::Some("voice"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::DEBUG
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::DEBUG
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!(
                                                                "Successfully parsed HTTP path: \'{0}\'",
                                                                path,
                                                            ) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                            path
                        }
                        Err(e) => {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event voice/src/lib.rs:201",
                                            "voice",
                                            ::tracing::Level::ERROR,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "voice/src/lib.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(201u32),
                                            ::tracing_core::__macro_support::Option::Some("voice"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!("Failed to parse HTTP path: {0}", e)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                            hyperware_process_lib::http::server::send_response(
                                hyperware_process_lib::http::StatusCode::BAD_REQUEST,
                                None,
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("Invalid path: {0}", e),
                                        );
                                        res
                                    })
                                    .into_bytes(),
                            );
                            return;
                        }
                    };
                    hyperware_app_common::APP_HELPERS
                        .with(|ctx| {
                            let mut ctx_mut = ctx.borrow_mut();
                            ctx_mut.current_path = Some(current_path.clone());
                            ctx_mut.current_http_method = Some(http_method.clone());
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event voice/src/lib.rs:201",
                                            "voice",
                                            ::tracing::Level::DEBUG,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "voice/src/lib.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(201u32),
                                            ::tracing_core::__macro_support::Option::Some("voice"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::DEBUG
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::DEBUG
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!(
                                                                "Set current_path to: {0:?}",
                                                                ctx_mut.current_path,
                                                            ) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event voice/src/lib.rs:201",
                                            "voice",
                                            ::tracing::Level::DEBUG,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "voice/src/lib.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(201u32),
                                            ::tracing_core::__macro_support::Option::Some("voice"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::DEBUG
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::DEBUG
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!(
                                                                "Set current_http_method to: {0:?}",
                                                                ctx_mut.current_http_method,
                                                            ) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        });
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event voice/src/lib.rs:201",
                                    "voice",
                                    ::tracing::Level::DEBUG,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "voice/src/lib.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(201u32),
                                    ::tracing_core::__macro_support::Option::Some("voice"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::DEBUG
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::DEBUG
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!(
                                                        "Starting handler matching for {0} {1}",
                                                        http_method,
                                                        current_path,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    if blob_opt.is_some() && !blob_opt.as_ref().unwrap().bytes.is_empty()
                    {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event voice/src/lib.rs:201",
                                        "voice",
                                        ::tracing::Level::DEBUG,
                                        ::tracing_core::__macro_support::Option::Some(
                                            "voice/src/lib.rs",
                                        ),
                                        ::tracing_core::__macro_support::Option::Some(201u32),
                                        ::tracing_core::__macro_support::Option::Some("voice"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::DEBUG
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::DEBUG
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::tracing::__macro_support::Option::Some(
                                                        &format_args!("Request has body, using two-phase matching")
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        if let Some(ref blob) = blob_opt {
                            match serde_json::from_slice::<HPMRequest>(&blob.bytes) {
                                Ok(request) => {
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "event voice/src/lib.rs:201",
                                                    "voice",
                                                    ::tracing::Level::DEBUG,
                                                    ::tracing_core::__macro_support::Option::Some(
                                                        "voice/src/lib.rs",
                                                    ),
                                                    ::tracing_core::__macro_support::Option::Some(201u32),
                                                    ::tracing_core::__macro_support::Option::Some("voice"),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["message"],
                                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::EVENT,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let enabled = ::tracing::Level::DEBUG
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::tracing::Level::DEBUG
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                let interest = __CALLSITE.interest();
                                                !interest.is_never()
                                                    && ::tracing::__macro_support::__is_enabled(
                                                        __CALLSITE.metadata(),
                                                        interest,
                                                    )
                                            };
                                        if enabled {
                                            (|value_set: ::tracing::field::ValueSet| {
                                                let meta = __CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                            })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::tracing::__macro_support::Option::Some(
                                                                    &format_args!(
                                                                        "Successfully parsed request body, dispatching to specific handler",
                                                                    ) as &dyn Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            });
                                        } else {
                                        }
                                    };
                                    unsafe {
                                        match request {
                                            HPMRequest::CreateCall(param) => {
                                                let param_captured = param;
                                                let state_ptr: *mut VoiceState = state;
                                                ::hyperware_app_common::APP_CONTEXT
                                                    .with(|ctx| {
                                                        ctx.borrow_mut()
                                                            .executor
                                                            .spawn(async move {
                                                                let result = unsafe {
                                                                    (*state_ptr).create_call(param_captured).await
                                                                };
                                                                let response_bytes = serde_json::to_vec(&result).unwrap();
                                                                let headers_opt = hyperware_app_common::APP_HELPERS
                                                                    .with(|ctx| {
                                                                        let helpers = ctx.borrow();
                                                                        if helpers.response_headers.is_empty() {
                                                                            None
                                                                        } else {
                                                                            Some(helpers.response_headers.clone())
                                                                        }
                                                                    });
                                                                hyperware_process_lib::http::server::send_response(
                                                                    hyperware_process_lib::http::StatusCode::OK,
                                                                    headers_opt,
                                                                    response_bytes,
                                                                );
                                                                hyperware_app_common::clear_response_headers();
                                                            })
                                                    })
                                            }
                                            HPMRequest::JoinCall(param) => {
                                                let param_captured = param;
                                                let state_ptr: *mut VoiceState = state;
                                                ::hyperware_app_common::APP_CONTEXT
                                                    .with(|ctx| {
                                                        ctx.borrow_mut()
                                                            .executor
                                                            .spawn(async move {
                                                                let result = unsafe {
                                                                    (*state_ptr).join_call(param_captured).await
                                                                };
                                                                let response_bytes = serde_json::to_vec(&result).unwrap();
                                                                let headers_opt = hyperware_app_common::APP_HELPERS
                                                                    .with(|ctx| {
                                                                        let helpers = ctx.borrow();
                                                                        if helpers.response_headers.is_empty() {
                                                                            None
                                                                        } else {
                                                                            Some(helpers.response_headers.clone())
                                                                        }
                                                                    });
                                                                hyperware_process_lib::http::server::send_response(
                                                                    hyperware_process_lib::http::StatusCode::OK,
                                                                    headers_opt,
                                                                    response_bytes,
                                                                );
                                                                hyperware_app_common::clear_response_headers();
                                                            })
                                                    })
                                            }
                                            HPMRequest::GetCallInfo(param) => {
                                                let param_captured = param;
                                                let state_ptr: *mut VoiceState = state;
                                                ::hyperware_app_common::APP_CONTEXT
                                                    .with(|ctx| {
                                                        ctx.borrow_mut()
                                                            .executor
                                                            .spawn(async move {
                                                                let result = unsafe {
                                                                    (*state_ptr).get_call_info(param_captured).await
                                                                };
                                                                let response_bytes = serde_json::to_vec(&result).unwrap();
                                                                let headers_opt = hyperware_app_common::APP_HELPERS
                                                                    .with(|ctx| {
                                                                        let helpers = ctx.borrow();
                                                                        if helpers.response_headers.is_empty() {
                                                                            None
                                                                        } else {
                                                                            Some(helpers.response_headers.clone())
                                                                        }
                                                                    });
                                                                hyperware_process_lib::http::server::send_response(
                                                                    hyperware_process_lib::http::StatusCode::OK,
                                                                    headers_opt,
                                                                    response_bytes,
                                                                );
                                                                hyperware_app_common::clear_response_headers();
                                                            })
                                                    })
                                            }
                                            HPMRequest::LeaveCall(param) => {
                                                let param_captured = param;
                                                let state_ptr: *mut VoiceState = state;
                                                ::hyperware_app_common::APP_CONTEXT
                                                    .with(|ctx| {
                                                        ctx.borrow_mut()
                                                            .executor
                                                            .spawn(async move {
                                                                let result = unsafe {
                                                                    (*state_ptr).leave_call(param_captured).await
                                                                };
                                                                let response_bytes = serde_json::to_vec(&result).unwrap();
                                                                let headers_opt = hyperware_app_common::APP_HELPERS
                                                                    .with(|ctx| {
                                                                        let helpers = ctx.borrow();
                                                                        if helpers.response_headers.is_empty() {
                                                                            None
                                                                        } else {
                                                                            Some(helpers.response_headers.clone())
                                                                        }
                                                                    });
                                                                hyperware_process_lib::http::server::send_response(
                                                                    hyperware_process_lib::http::StatusCode::OK,
                                                                    headers_opt,
                                                                    response_bytes,
                                                                );
                                                                hyperware_app_common::clear_response_headers();
                                                            })
                                                    })
                                            }
                                            HPMRequest::UpdateRole(param) => {
                                                let param_captured = param;
                                                let state_ptr: *mut VoiceState = state;
                                                ::hyperware_app_common::APP_CONTEXT
                                                    .with(|ctx| {
                                                        ctx.borrow_mut()
                                                            .executor
                                                            .spawn(async move {
                                                                let result = unsafe {
                                                                    (*state_ptr).update_role(param_captured).await
                                                                };
                                                                let response_bytes = serde_json::to_vec(&result).unwrap();
                                                                let headers_opt = hyperware_app_common::APP_HELPERS
                                                                    .with(|ctx| {
                                                                        let helpers = ctx.borrow();
                                                                        if helpers.response_headers.is_empty() {
                                                                            None
                                                                        } else {
                                                                            Some(helpers.response_headers.clone())
                                                                        }
                                                                    });
                                                                hyperware_process_lib::http::server::send_response(
                                                                    hyperware_process_lib::http::StatusCode::OK,
                                                                    headers_opt,
                                                                    response_bytes,
                                                                );
                                                                hyperware_app_common::clear_response_headers();
                                                            })
                                                    })
                                            }
                                            HPMRequest::ServeCallPage(param) => {
                                                let param_captured = param;
                                                let state_ptr: *mut VoiceState = state;
                                                ::hyperware_app_common::APP_CONTEXT
                                                    .with(|ctx| {
                                                        ctx.borrow_mut()
                                                            .executor
                                                            .spawn(async move {
                                                                let result = unsafe {
                                                                    (*state_ptr).serve_call_page(param_captured).await
                                                                };
                                                                let response_bytes = serde_json::to_vec(&result).unwrap();
                                                                let headers_opt = hyperware_app_common::APP_HELPERS
                                                                    .with(|ctx| {
                                                                        let helpers = ctx.borrow();
                                                                        if helpers.response_headers.is_empty() {
                                                                            None
                                                                        } else {
                                                                            Some(helpers.response_headers.clone())
                                                                        }
                                                                    });
                                                                hyperware_process_lib::http::server::send_response(
                                                                    hyperware_process_lib::http::StatusCode::OK,
                                                                    headers_opt,
                                                                    response_bytes,
                                                                );
                                                                hyperware_app_common::clear_response_headers();
                                                            })
                                                    })
                                            }
                                            HPMRequest::JoinCallUnauthenticated(param0, param1) => {
                                                let param0_captured = param0;
                                                let param1_captured = param1;
                                                let state_ptr: *mut VoiceState = state;
                                                ::hyperware_app_common::APP_CONTEXT
                                                    .with(|ctx| {
                                                        ctx.borrow_mut()
                                                            .executor
                                                            .spawn(async move {
                                                                let result = unsafe {
                                                                    (*state_ptr)
                                                                        .join_call_unauthenticated(param0_captured, param1_captured)
                                                                        .await
                                                                };
                                                                let response_bytes = serde_json::to_vec(&result).unwrap();
                                                                let headers_opt = hyperware_app_common::APP_HELPERS
                                                                    .with(|ctx| {
                                                                        let helpers = ctx.borrow();
                                                                        if helpers.response_headers.is_empty() {
                                                                            None
                                                                        } else {
                                                                            Some(helpers.response_headers.clone())
                                                                        }
                                                                    });
                                                                hyperware_process_lib::http::server::send_response(
                                                                    hyperware_process_lib::http::StatusCode::OK,
                                                                    headers_opt,
                                                                    response_bytes,
                                                                );
                                                                hyperware_app_common::clear_response_headers();
                                                            })
                                                    })
                                            }
                                            HPMRequest::JoinCallUnauthenticatedHttp(param0, param1) => {
                                                let param0_captured = param0;
                                                let param1_captured = param1;
                                                let state_ptr: *mut VoiceState = state;
                                                ::hyperware_app_common::APP_CONTEXT
                                                    .with(|ctx| {
                                                        ctx.borrow_mut()
                                                            .executor
                                                            .spawn(async move {
                                                                let result = unsafe {
                                                                    (*state_ptr)
                                                                        .join_call_unauthenticated_http(
                                                                            param0_captured,
                                                                            param1_captured,
                                                                        )
                                                                        .await
                                                                };
                                                                let response_bytes = serde_json::to_vec(&result).unwrap();
                                                                let headers_opt = hyperware_app_common::APP_HELPERS
                                                                    .with(|ctx| {
                                                                        let helpers = ctx.borrow();
                                                                        if helpers.response_headers.is_empty() {
                                                                            None
                                                                        } else {
                                                                            Some(helpers.response_headers.clone())
                                                                        }
                                                                    });
                                                                hyperware_process_lib::http::server::send_response(
                                                                    hyperware_process_lib::http::StatusCode::OK,
                                                                    headers_opt,
                                                                    response_bytes,
                                                                );
                                                                hyperware_app_common::clear_response_headers();
                                                            })
                                                    })
                                            }
                                            HPMRequest::NodeHandshake(param) => {
                                                let param_captured = param;
                                                let state_ptr: *mut VoiceState = state;
                                                ::hyperware_app_common::APP_CONTEXT
                                                    .with(|ctx| {
                                                        ctx.borrow_mut()
                                                            .executor
                                                            .spawn(async move {
                                                                let result = unsafe {
                                                                    (*state_ptr).node_handshake(param_captured).await
                                                                };
                                                                let response_bytes = serde_json::to_vec(&result).unwrap();
                                                                let headers_opt = hyperware_app_common::APP_HELPERS
                                                                    .with(|ctx| {
                                                                        let helpers = ctx.borrow();
                                                                        if helpers.response_headers.is_empty() {
                                                                            None
                                                                        } else {
                                                                            Some(helpers.response_headers.clone())
                                                                        }
                                                                    });
                                                                hyperware_process_lib::http::server::send_response(
                                                                    hyperware_process_lib::http::StatusCode::OK,
                                                                    headers_opt,
                                                                    response_bytes,
                                                                );
                                                                hyperware_app_common::clear_response_headers();
                                                            })
                                                    })
                                            }
                                            _ => {
                                                ::core::panicking::panic_fmt(
                                                    format_args!(
                                                        "internal error: entered unreachable code: {0}",
                                                        format_args!(
                                                            "Non-http request variant received in http handler",
                                                        ),
                                                    ),
                                                );
                                            }
                                        }
                                        hyperware_app_common::maybe_save_state(&mut *state);
                                    }
                                    hyperware_app_common::APP_HELPERS
                                        .with(|ctx| {
                                            ctx.borrow_mut().current_path = None;
                                        });
                                    return;
                                }
                                Err(e) => {
                                    let error_details = if blob.bytes.is_empty() {
                                        "Request body is empty but was expected to contain handler parameters."
                                            .to_string()
                                    } else if let Ok(json_value) = serde_json::from_slice::<
                                        serde_json::Value,
                                    >(&blob.bytes) {
                                        ::alloc::__export::must_use({
                                            let res = ::alloc::fmt::format(
                                                format_args!(
                                                    "Invalid request format. Expected one of the parameterized handler formats, but got: {0}",
                                                    serde_json::to_string(&json_value)
                                                        .unwrap_or_else(|_| "invalid JSON".to_string()),
                                                ),
                                            );
                                            res
                                        })
                                    } else {
                                        ::alloc::__export::must_use({
                                            let res = ::alloc::fmt::format(
                                                format_args!(
                                                    "Invalid JSON in request body. Parse error: {0}",
                                                    e,
                                                ),
                                            );
                                            res
                                        })
                                    };
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "event voice/src/lib.rs:201",
                                                    "voice",
                                                    ::tracing::Level::ERROR,
                                                    ::tracing_core::__macro_support::Option::Some(
                                                        "voice/src/lib.rs",
                                                    ),
                                                    ::tracing_core::__macro_support::Option::Some(201u32),
                                                    ::tracing_core::__macro_support::Option::Some("voice"),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["message"],
                                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::EVENT,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let enabled = ::tracing::Level::ERROR
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::tracing::Level::ERROR
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                let interest = __CALLSITE.interest();
                                                !interest.is_never()
                                                    && ::tracing::__macro_support::__is_enabled(
                                                        __CALLSITE.metadata(),
                                                        interest,
                                                    )
                                            };
                                        if enabled {
                                            (|value_set: ::tracing::field::ValueSet| {
                                                let meta = __CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                            })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::tracing::__macro_support::Option::Some(
                                                                    &format_args!(
                                                                        "Failed to parse request body for {0} {1}: {2}",
                                                                        http_method,
                                                                        current_path,
                                                                        error_details,
                                                                    ) as &dyn Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            });
                                        } else {
                                        }
                                    };
                                    hyperware_process_lib::http::server::send_response(
                                        hyperware_process_lib::http::StatusCode::BAD_REQUEST,
                                        None,
                                        error_details.into_bytes(),
                                    );
                                    hyperware_app_common::APP_HELPERS
                                        .with(|ctx| {
                                            ctx.borrow_mut().current_path = None;
                                        });
                                    return;
                                }
                            }
                        }
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event voice/src/lib.rs:201",
                                        "voice",
                                        ::tracing::Level::DEBUG,
                                        ::tracing_core::__macro_support::Option::Some(
                                            "voice/src/lib.rs",
                                        ),
                                        ::tracing_core::__macro_support::Option::Some(201u32),
                                        ::tracing_core::__macro_support::Option::Some("voice"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::DEBUG
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::DEBUG
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::tracing::__macro_support::Option::Some(
                                                        &format_args!(
                                                            "Request has no body, trying parameter-less handlers first",
                                                        ) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event voice/src/lib.rs:201",
                                    "voice",
                                    ::tracing::Level::ERROR,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "voice/src/lib.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(201u32),
                                    ::tracing_core::__macro_support::Option::Some("voice"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::ERROR
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::ERROR
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!(
                                                        "No handler found for {0} {1} - all handlers checked",
                                                        http_method,
                                                        current_path,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    hyperware_process_lib::http::server::send_response(
                        hyperware_process_lib::http::StatusCode::NOT_FOUND,
                        None,
                        ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "No handler found for {0} {1}",
                                        http_method,
                                        current_path,
                                    ),
                                );
                                res
                            })
                            .into_bytes(),
                    );
                    hyperware_app_common::APP_HELPERS
                        .with(|ctx| {
                            ctx.borrow_mut().current_path = None;
                        });
                }
                hyperware_process_lib::http::server::HttpServerRequest::WebSocketPush {
                    channel_id,
                    message_type,
                } => {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event voice/src/lib.rs:201",
                                    "voice",
                                    ::tracing::Level::DEBUG,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "voice/src/lib.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(201u32),
                                    ::tracing_core::__macro_support::Option::Some("voice"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::DEBUG
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::DEBUG
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!(
                                                        "Received WebSocket message on channel {0}, type: {1:?}",
                                                        channel_id,
                                                        message_type,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let Some(blob) = blob_opt else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event voice/src/lib.rs:201",
                                        "voice",
                                        ::tracing::Level::ERROR,
                                        ::tracing_core::__macro_support::Option::Some(
                                            "voice/src/lib.rs",
                                        ),
                                        ::tracing_core::__macro_support::Option::Some(201u32),
                                        ::tracing_core::__macro_support::Option::Some("voice"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::tracing::__macro_support::Option::Some(
                                                        &format_args!(
                                                            "Failed to get blob for WebSocketPush on channel {0}. This indicates a malformed WebSocket message.",
                                                            channel_id,
                                                        ) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        return;
                    };
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event voice/src/lib.rs:201",
                                    "voice",
                                    ::tracing::Level::DEBUG,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "voice/src/lib.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(201u32),
                                    ::tracing_core::__macro_support::Option::Some("voice"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::DEBUG
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::DEBUG
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!(
                                                        "Processing WebSocket message with {0} bytes",
                                                        blob.bytes.len(),
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    unsafe { (*state).websocket(channel_id, message_type, blob) };
                    unsafe {
                        hyperware_app_common::maybe_save_state(&mut *state);
                    }
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event voice/src/lib.rs:201",
                                    "voice",
                                    ::tracing::Level::DEBUG,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "voice/src/lib.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(201u32),
                                    ::tracing_core::__macro_support::Option::Some("voice"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::DEBUG
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::DEBUG
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!("WebSocket message processed successfully")
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                }
                hyperware_process_lib::http::server::HttpServerRequest::WebSocketOpen {
                    path,
                    channel_id,
                } => {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event voice/src/lib.rs:201",
                                    "voice",
                                    ::tracing::Level::DEBUG,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "voice/src/lib.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(201u32),
                                    ::tracing_core::__macro_support::Option::Some("voice"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::DEBUG
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::DEBUG
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!(
                                                        "WebSocket connection opened on path \'{0}\' with channel {1}",
                                                        path,
                                                        channel_id,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    match hyperware_app_common::get_server() {
                        Some(server) => server.handle_websocket_open(&path, channel_id),
                        None => {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event voice/src/lib.rs:201",
                                        "voice",
                                        ::tracing::Level::ERROR,
                                        ::tracing_core::__macro_support::Option::Some(
                                            "voice/src/lib.rs",
                                        ),
                                        ::tracing_core::__macro_support::Option::Some(201u32),
                                        ::tracing_core::__macro_support::Option::Some("voice"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::tracing::__macro_support::Option::Some(
                                                        &format_args!(
                                                            "Failed to get server instance for WebSocket open event",
                                                        ) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        }
                    }
                }
                hyperware_process_lib::http::server::HttpServerRequest::WebSocketClose(
                    channel_id,
                ) => {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event voice/src/lib.rs:201",
                                    "voice",
                                    ::tracing::Level::DEBUG,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "voice/src/lib.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(201u32),
                                    ::tracing_core::__macro_support::Option::Some("voice"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::DEBUG
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::DEBUG
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!(
                                                        "WebSocket connection closed on channel {0}",
                                                        channel_id,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    match hyperware_app_common::get_server() {
                        Some(server) => server.handle_websocket_close(channel_id),
                        None => {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event voice/src/lib.rs:201",
                                        "voice",
                                        ::tracing::Level::ERROR,
                                        ::tracing_core::__macro_support::Option::Some(
                                            "voice/src/lib.rs",
                                        ),
                                        ::tracing_core::__macro_support::Option::Some(201u32),
                                        ::tracing_core::__macro_support::Option::Some("voice"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::tracing::__macro_support::Option::Some(
                                                        &format_args!(
                                                            "Failed to get server instance for WebSocket close event",
                                                        ) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        }
                    }
                }
            }
        }
        Err(e) => {
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event voice/src/lib.rs:201",
                            "voice",
                            ::tracing::Level::ERROR,
                            ::tracing_core::__macro_support::Option::Some(
                                "voice/src/lib.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(201u32),
                            ::tracing_core::__macro_support::Option::Some("voice"),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::ERROR
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::ERROR
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = __CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = __CALLSITE.metadata().fields().iter();
                        __CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::tracing::__macro_support::Option::Some(
                                            &format_args!(
                                                "Failed to parse HTTP server request: {0}\nThis usually indicates a malformed message to the HTTP server.",
                                                e,
                                            ) as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                }
            };
        }
    }
}
/// Handle local messages
fn handle_local_message(
    state: *mut VoiceState,
    message: hyperware_process_lib::Message,
) {
    {
        use ::tracing::__macro_support::Callsite as _;
        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
            static META: ::tracing::Metadata<'static> = {
                ::tracing_core::metadata::Metadata::new(
                    "event voice/src/lib.rs:201",
                    "voice",
                    ::tracing::Level::DEBUG,
                    ::tracing_core::__macro_support::Option::Some("voice/src/lib.rs"),
                    ::tracing_core::__macro_support::Option::Some(201u32),
                    ::tracing_core::__macro_support::Option::Some("voice"),
                    ::tracing_core::field::FieldSet::new(
                        &["message"],
                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                    ),
                    ::tracing::metadata::Kind::EVENT,
                )
            };
            ::tracing::callsite::DefaultCallsite::new(&META)
        };
        let enabled = ::tracing::Level::DEBUG
            <= ::tracing::level_filters::STATIC_MAX_LEVEL
            && ::tracing::Level::DEBUG
                <= ::tracing::level_filters::LevelFilter::current()
            && {
                let interest = __CALLSITE.interest();
                !interest.is_never()
                    && ::tracing::__macro_support::__is_enabled(
                        __CALLSITE.metadata(),
                        interest,
                    )
            };
        if enabled {
            (|value_set: ::tracing::field::ValueSet| {
                let meta = __CALLSITE.metadata();
                ::tracing::Event::dispatch(meta, &value_set);
            })({
                #[allow(unused_imports)]
                use ::tracing::field::{debug, display, Value};
                let mut iter = __CALLSITE.metadata().fields().iter();
                __CALLSITE
                    .metadata()
                    .fields()
                    .value_set(
                        &[
                            (
                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                    .expect("FieldSet corrupted (this is a bug)"),
                                ::tracing::__macro_support::Option::Some(
                                    &format_args!(
                                        "Processing local message from: {0:?}",
                                        message.source(),
                                    ) as &dyn Value,
                                ),
                            ),
                        ],
                    )
            });
        } else {
        }
    };
    match serde_json::from_slice::<HPMRequest>(message.body()) {
        Ok(request) => {
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event voice/src/lib.rs:201",
                            "voice",
                            ::tracing::Level::DEBUG,
                            ::tracing_core::__macro_support::Option::Some(
                                "voice/src/lib.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(201u32),
                            ::tracing_core::__macro_support::Option::Some("voice"),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::DEBUG
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::DEBUG
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = __CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = __CALLSITE.metadata().fields().iter();
                        __CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::tracing::__macro_support::Option::Some(
                                            &format_args!("Successfully deserialized local request")
                                                as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                }
            };
            unsafe {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event voice/src/lib.rs:201",
                                "voice",
                                ::tracing::Level::WARN,
                                ::tracing_core::__macro_support::Option::Some(
                                    "voice/src/lib.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(201u32),
                                ::tracing_core::__macro_support::Option::Some("voice"),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::WARN
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::WARN
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &format_args!(
                                                    "No local handlers defined but received a local request",
                                                ) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                hyperware_app_common::maybe_save_state(&mut *state);
            }
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event voice/src/lib.rs:201",
                            "voice",
                            ::tracing::Level::DEBUG,
                            ::tracing_core::__macro_support::Option::Some(
                                "voice/src/lib.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(201u32),
                            ::tracing_core::__macro_support::Option::Some("voice"),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::DEBUG
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::DEBUG
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = __CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = __CALLSITE.metadata().fields().iter();
                        __CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::tracing::__macro_support::Option::Some(
                                            &format_args!("Local message processed successfully")
                                                as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                }
            };
        }
        Err(e) => {
            let raw_body = String::from_utf8_lossy(message.body());
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event voice/src/lib.rs:201",
                            "voice",
                            ::tracing::Level::ERROR,
                            ::tracing_core::__macro_support::Option::Some(
                                "voice/src/lib.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(201u32),
                            ::tracing_core::__macro_support::Option::Some("voice"),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::ERROR
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::ERROR
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = __CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = __CALLSITE.metadata().fields().iter();
                        __CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::tracing::__macro_support::Option::Some(
                                            &format_args!(
                                                "Failed to deserialize local request into HPMRequest enum.\nError: {0}\nSource: {1:?}\nBody: {2}\n\n This usually means the message format doesn\'t match any of your #[local] or #[remote] handlers.",
                                                e,
                                                message.source(),
                                                raw_body,
                                            ) as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                }
            };
        }
    }
}
/// Handle remote messages
fn handle_remote_message(
    state: *mut VoiceState,
    message: hyperware_process_lib::Message,
) {
    {
        use ::tracing::__macro_support::Callsite as _;
        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
            static META: ::tracing::Metadata<'static> = {
                ::tracing_core::metadata::Metadata::new(
                    "event voice/src/lib.rs:201",
                    "voice",
                    ::tracing::Level::DEBUG,
                    ::tracing_core::__macro_support::Option::Some("voice/src/lib.rs"),
                    ::tracing_core::__macro_support::Option::Some(201u32),
                    ::tracing_core::__macro_support::Option::Some("voice"),
                    ::tracing_core::field::FieldSet::new(
                        &["message"],
                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                    ),
                    ::tracing::metadata::Kind::EVENT,
                )
            };
            ::tracing::callsite::DefaultCallsite::new(&META)
        };
        let enabled = ::tracing::Level::DEBUG
            <= ::tracing::level_filters::STATIC_MAX_LEVEL
            && ::tracing::Level::DEBUG
                <= ::tracing::level_filters::LevelFilter::current()
            && {
                let interest = __CALLSITE.interest();
                !interest.is_never()
                    && ::tracing::__macro_support::__is_enabled(
                        __CALLSITE.metadata(),
                        interest,
                    )
            };
        if enabled {
            (|value_set: ::tracing::field::ValueSet| {
                let meta = __CALLSITE.metadata();
                ::tracing::Event::dispatch(meta, &value_set);
            })({
                #[allow(unused_imports)]
                use ::tracing::field::{debug, display, Value};
                let mut iter = __CALLSITE.metadata().fields().iter();
                __CALLSITE
                    .metadata()
                    .fields()
                    .value_set(
                        &[
                            (
                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                    .expect("FieldSet corrupted (this is a bug)"),
                                ::tracing::__macro_support::Option::Some(
                                    &format_args!(
                                        "Processing remote message from: {0:?}",
                                        message.source(),
                                    ) as &dyn Value,
                                ),
                            ),
                        ],
                    )
            });
        } else {
        }
    };
    match serde_json::from_slice::<HPMRequest>(message.body()) {
        Ok(request) => {
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event voice/src/lib.rs:201",
                            "voice",
                            ::tracing::Level::DEBUG,
                            ::tracing_core::__macro_support::Option::Some(
                                "voice/src/lib.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(201u32),
                            ::tracing_core::__macro_support::Option::Some("voice"),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::DEBUG
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::DEBUG
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = __CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = __CALLSITE.metadata().fields().iter();
                        __CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::tracing::__macro_support::Option::Some(
                                            &format_args!("Successfully deserialized remote request")
                                                as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                }
            };
            unsafe {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event voice/src/lib.rs:201",
                                "voice",
                                ::tracing::Level::WARN,
                                ::tracing_core::__macro_support::Option::Some(
                                    "voice/src/lib.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(201u32),
                                ::tracing_core::__macro_support::Option::Some("voice"),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::WARN
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::WARN
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &format_args!(
                                                    "No remote handlers defined but received a remote request",
                                                ) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                hyperware_app_common::maybe_save_state(&mut *state);
            }
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event voice/src/lib.rs:201",
                            "voice",
                            ::tracing::Level::DEBUG,
                            ::tracing_core::__macro_support::Option::Some(
                                "voice/src/lib.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(201u32),
                            ::tracing_core::__macro_support::Option::Some("voice"),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::DEBUG
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::DEBUG
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = __CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = __CALLSITE.metadata().fields().iter();
                        __CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::tracing::__macro_support::Option::Some(
                                            &format_args!("Remote message processed successfully")
                                                as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                }
            };
        }
        Err(e) => {
            let raw_body = String::from_utf8_lossy(message.body());
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event voice/src/lib.rs:201",
                            "voice",
                            ::tracing::Level::ERROR,
                            ::tracing_core::__macro_support::Option::Some(
                                "voice/src/lib.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(201u32),
                            ::tracing_core::__macro_support::Option::Some("voice"),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::ERROR
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::ERROR
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = __CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = __CALLSITE.metadata().fields().iter();
                        __CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::tracing::__macro_support::Option::Some(
                                            &format_args!(
                                                "Failed to deserialize remote request into HPMRequest enum.\nError: {0}\nSource: {1:?}\nBody: {2}\n\n This usually means the message format doesn\'t match any of your #[remote] handlers.",
                                                e,
                                                message.source(),
                                                raw_body,
                                            ) as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                }
            };
        }
    }
}
struct Component;
impl Guest for Component {
    fn init(_our: String) {
        let mut state = hyperware_app_common::initialize_state::<VoiceState>();
        hyperware_app_common::APP_CONTEXT
            .with(|ctx| {
                ctx.borrow_mut().hidden_state = Some(
                    hyperware_app_common::HiddenState::new(
                        hyperware_app_common::SaveOptions::Never,
                    ),
                );
            });
        let app_name = "voice";
        let app_icon = None;
        let app_widget = None;
        let ui_config = Some(HttpBindingConfig::default());
        let endpoints = <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                Binding::Http {
                    path: "/api",
                    config: HttpBindingConfig::default(),
                },
                Binding::Ws {
                    path: "/ws",
                    config: WsBindingConfig::default().authenticated(false),
                },
                Binding::Http {
                    path: "/call/*",
                    config: HttpBindingConfig::default().authenticated(false),
                },
            ]),
        );
        if app_icon.is_some() && app_widget.is_some() {
            hyperware_process_lib::homepage::add_to_homepage(
                app_name,
                app_icon,
                Some("/"),
                app_widget,
            );
        }
        hyperware_process_lib::logging::init_logging(
                hyperware_process_lib::logging::Level::DEBUG,
                hyperware_process_lib::logging::Level::INFO,
                None,
                Some((0, 0, 1, 1)),
                None,
            )
            .unwrap();
        let mut server = hyperware_app_common::setup_server(
            ui_config.as_ref(),
            &endpoints,
        );
        hyperware_app_common::APP_HELPERS
            .with(|ctx| {
                ctx.borrow_mut().current_server = Some(&mut server);
            });
        if Some("init").is_some() {
            let state_ptr: *mut VoiceState = &mut state;
            ::hyperware_app_common::APP_CONTEXT
                .with(|ctx| {
                    ctx.borrow_mut()
                        .executor
                        .spawn(async move {
                            unsafe { (*state_ptr).init().await };
                        })
                })
        }
        loop {
            hyperware_app_common::APP_CONTEXT
                .with(|ctx| {
                    ctx.borrow_mut().executor.poll_all_tasks();
                });
            match hyperware_process_lib::await_message() {
                Ok(message) => {
                    hyperware_app_common::APP_HELPERS
                        .with(|ctx| {
                            ctx.borrow_mut().current_message = Some(message.clone());
                        });
                    hyperware_app_common::store_old_state(&state);
                    match message {
                        hyperware_process_lib::Message::Response {
                            body,
                            context,
                            ..
                        } => {
                            let correlation_id = context
                                .as_deref()
                                .map(|bytes| String::from_utf8_lossy(bytes).to_string())
                                .unwrap_or_else(|| "no context".to_string());
                            hyperware_app_common::RESPONSE_REGISTRY
                                .with(|registry| {
                                    let mut registry_mut = registry.borrow_mut();
                                    registry_mut.insert(correlation_id, body);
                                });
                        }
                        hyperware_process_lib::Message::Request { .. } => {
                            if message.is_local()
                                && message.source().process == "http-server:distro:sys"
                            {
                                handle_http_server_message(&mut state, message);
                            } else if message.is_local() {
                                handle_local_message(&mut state, message);
                            } else {
                                handle_remote_message(&mut state, message);
                            }
                        }
                    }
                }
                Err(ref error) => {
                    if let hyperware_process_lib::SendError {
                        context: Some(context),
                        ..
                    } = error {
                        let correlation_id = String::from_utf8_lossy(context)
                            .to_string();
                        hyperware_app_common::RESPONSE_REGISTRY
                            .with(|registry| {
                                let mut registry_mut = registry.borrow_mut();
                                registry_mut
                                    .insert(correlation_id, serde_json::to_vec(error).unwrap());
                            });
                    }
                }
            }
        }
    }
}
const _: () = {
    #[export_name = "init"]
    unsafe extern "C" fn export_init(arg0: *mut u8, arg1: usize) {
        self::_export_init_cabi::<Component>(arg0, arg1)
    }
};
fn handle_client_message(state: &mut VoiceState, channel_id: u32, msg: WsClientMessage) {
    match msg {
        WsClientMessage::Authenticate { participant_id, auth_token: _ } => {
            if let Some((call_id, _)) = find_participant_call(state, &participant_id) {
                state.connections.insert(channel_id, participant_id.clone());
                state.participant_channels.insert(participant_id.clone(), channel_id);
                if let Some(call) = state.calls.get(&call_id) {
                    let participants: Vec<ParticipantInfo> = call
                        .participants
                        .values()
                        .map(|p| ParticipantInfo {
                            id: p.id.clone(),
                            display_name: p.display_name.clone(),
                            role: p.role.clone(),
                            is_muted: p.is_muted,
                        })
                        .collect();
                    if let Some(participant) = call.participants.get(&participant_id) {
                        let participant_info = ParticipantInfo {
                            id: participant.id.clone(),
                            display_name: participant.display_name.clone(),
                            role: participant.role.clone(),
                            is_muted: participant.is_muted,
                        };
                        broadcast_to_call(
                            state,
                            &call_id,
                            WsServerMessage::ParticipantJoined(WsParticipantJoined {
                                participant: participant_info,
                            }),
                        );
                    }
                }
            } else {
                send_error_to_channel(channel_id, "Invalid authentication");
            }
            return;
        }
        _ => {}
    }
    let participant_id = match state.connections.get(&channel_id) {
        Some(id) => id.clone(),
        None => {
            send_error_to_channel(channel_id, "Not authenticated");
            return;
        }
    };
    let (call_id, participant_role) = match find_participant_call(
        state,
        &participant_id,
    ) {
        Some((cid, role)) => (cid, role),
        None => {
            send_error_to_channel(channel_id, "Not in a call");
            return;
        }
    };
    match msg {
        WsClientMessage::Authenticate { .. } => {
            ::core::panicking::panic("internal error: entered unreachable code")
        }
        WsClientMessage::Chat(content) => {
            if !can_chat(&participant_role) {
                send_error_to_channel(channel_id, "No chat permission");
                return;
            }
            if let Some(call) = state.calls.get_mut(&call_id) {
                if let Some(participant) = call.participants.get(&participant_id) {
                    let chat_msg = ChatMessage {
                        id: generate_id(),
                        sender_id: participant_id.clone(),
                        sender_name: participant.display_name.clone(),
                        content,
                        timestamp: current_timestamp().unwrap_or(0),
                    };
                    call.chat_history.push(chat_msg.clone());
                    broadcast_to_call(
                        state,
                        &call_id,
                        WsServerMessage::Chat(WsChatMessage { message: chat_msg }),
                    );
                }
            }
        }
        WsClientMessage::Mute(is_muted) => {
            if let Some(call) = state.calls.get_mut(&call_id) {
                if let Some(participant) = call.participants.get_mut(&participant_id) {
                    participant.is_muted = is_muted;
                    broadcast_to_call(
                        state,
                        &call_id,
                        WsServerMessage::ParticipantMuted(WsParticipantMuted {
                            participant_id: participant_id.clone(),
                            is_muted,
                        }),
                    );
                }
            }
        }
        WsClientMessage::WebrtcSignal(signal) => {
            let target = signal.target.clone();
            send_to_participant(
                state,
                &target,
                WsServerMessage::WebrtcSignal(WsWebrtcSignal {
                    sender_id: participant_id,
                    signal,
                }),
            );
        }
        WsClientMessage::Heartbeat => {}
    }
}
fn generate_call_id(dictionary: &[String]) -> String {
    let mut rng = rand::thread_rng();
    let words: Vec<String> = dictionary
        .choose_multiple(&mut rng, 3)
        .map(|s| s.clone())
        .collect();
    words.join("-")
}
fn generate_pleb_name(dictionary: &[String], used_names: &mut Vec<String>) -> String {
    let mut rng = rand::thread_rng();
    loop {
        let word = dictionary.choose(&mut rng).unwrap();
        let name = ::alloc::__export::must_use({
            let res = ::alloc::fmt::format(format_args!("pleb-{0}", word));
            res
        });
        if !used_names.contains(&name) {
            used_names.push(name.clone());
            return name;
        }
    }
}
fn generate_id() -> String {
    use rand::Rng;
    let mut rng = rand::thread_rng();
    ::alloc::__export::must_use({
        let res = ::alloc::fmt::format(format_args!("{0:x}", rng.gen::<u64>()));
        res
    })
}
fn current_timestamp() -> Result<u64, String> {
    std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .map(|d| d.as_secs())
        .map_err(|e| e.to_string())
}
fn can_chat(role: &Role) -> bool {
    match role {
        Role::Chatter | Role::Speaker | Role::Admin => true,
        _ => false,
    }
}
fn can_speak(role: &Role) -> bool {
    match role {
        Role::Speaker | Role::Admin => true,
        _ => false,
    }
}
fn handle_disconnect(state: &mut VoiceState, channel_id: u32) {
    if let Some(participant_id) = state.connections.remove(&channel_id) {
        state.participant_channels.remove(&participant_id);
        let call_info = state
            .calls
            .iter()
            .find_map(|(cid, call)| {
                if call.participants.contains_key(&participant_id) {
                    Some((cid.clone(), call.participants.is_empty()))
                } else {
                    None
                }
            });
        if let Some((call_id, _)) = call_info {
            if let Some(call) = state.calls.get_mut(&call_id) {
                call.participants.remove(&participant_id);
                let is_empty = call.participants.is_empty();
                let notification = WsServerMessage::ParticipantLeft(
                    participant_id.clone(),
                );
                if !is_empty {
                    broadcast_to_call(state, &call_id, notification);
                }
                if is_empty {
                    state.calls.remove(&call_id);
                    state.used_pleb_names.remove(&call_id);
                }
            }
        }
    }
}
fn find_participant_call(
    state: &VoiceState,
    participant_id: &str,
) -> Option<(String, Role)> {
    for (call_id, call) in &state.calls {
        if let Some(participant) = call.participants.get(participant_id) {
            return Some((call_id.clone(), participant.role.clone()));
        }
    }
    None
}
fn broadcast_to_call(state: &VoiceState, call_id: &str, message: WsServerMessage) {
    if let Some(call) = state.calls.get(call_id) {
        let message_json = serde_json::to_string(&message).unwrap_or_default();
        let message_bytes = message_json.into_bytes();
        for participant_id in call.participants.keys() {
            if let Some(&channel_id) = state.participant_channels.get(participant_id) {
                let blob = LazyLoadBlob {
                    mime: Some("application/json".to_string()),
                    bytes: message_bytes.clone(),
                };
                send_ws_push(channel_id, WsMessageType::Text, blob);
            }
        }
    }
}
fn send_to_participant(
    state: &VoiceState,
    participant_id: &str,
    message: WsServerMessage,
) {
    if let Some(&channel_id) = state.participant_channels.get(participant_id) {
        let message_json = serde_json::to_string(&message).unwrap_or_default();
        let blob = LazyLoadBlob {
            mime: Some("application/json".to_string()),
            bytes: message_json.into_bytes(),
        };
        send_ws_push(channel_id, WsMessageType::Text, blob);
    }
}
fn send_error_to_channel(channel_id: u32, error: &str) {
    let message = WsServerMessage::Error(error.to_string());
    let message_json = serde_json::to_string(&message).unwrap_or_default();
    let blob = LazyLoadBlob {
        mime: Some("application/json".to_string()),
        bytes: message_json.into_bytes(),
    };
    send_ws_push(channel_id, WsMessageType::Text, blob);
}
